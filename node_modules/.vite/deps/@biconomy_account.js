import {
  require_src as require_src4
} from "./chunk-OHR3QC7M.js";
import {
  require_src as require_src2,
  require_utils
} from "./chunk-VBAP6WG5.js";
import {
  require_src
} from "./chunk-5T4TPRHY.js";
import {
  require_src as require_src3
} from "./chunk-A3M5VZPE.js";
import "./chunk-JN4UB7ZE.js";
import {
  init_lib7 as init_lib2,
  lib_exports7 as lib_exports2
} from "./chunk-QW2AHC3C.js";
import {
  init_lib20 as init_lib,
  lib_exports17 as lib_exports
} from "./chunk-VF42ZICC.js";
import "./chunk-NNQCPY7Z.js";
import {
  Buffer,
  __commonJS,
  __toCommonJS,
  init_buffer,
  init_process
} from "./chunk-YS2TNBJ3.js";

// node_modules/@biconomy/account/dist/src/interfaces/ISmartAccount.js
var require_ISmartAccount = __commonJS({
  "node_modules/@biconomy/account/dist/src/interfaces/ISmartAccount.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@biconomy/account/dist/src/utils/Types.js
var require_Types = __commonJS({
  "node_modules/@biconomy/account/dist/src/utils/Types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@biconomy/account/dist/src/utils/Preverificaiton.js
var require_Preverificaiton = __commonJS({
  "node_modules/@biconomy/account/dist/src/utils/Preverificaiton.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calcPreVerificationGas = exports.DefaultGasLimits = exports.DefaultGasOverheads = void 0;
    var common_1 = require_src2();
    var utils_1 = require_utils();
    var ethers_1 = (init_lib2(), __toCommonJS(lib_exports2));
    exports.DefaultGasOverheads = {
      fixed: 21e3,
      perUserOp: 18300,
      perUserOpWord: 4,
      zeroByte: 4,
      nonZeroByte: 16,
      bundleSize: 1,
      sigSize: 65
    };
    exports.DefaultGasLimits = {
      validateUserOpGas: 1e5,
      validatePaymasterUserOpGas: 1e5,
      postOpGas: 10877
    };
    function calcPreVerificationGas(userOp, overheads) {
      const ov = { ...exports.DefaultGasOverheads, ...overheads !== null && overheads !== void 0 ? overheads : {} };
      const p = {
        // dummy values, in case the UserOp is incomplete.
        paymasterAndData: "0x",
        preVerificationGas: ethers_1.BigNumber.from(21e3),
        signature: (0, utils_1.hexlify)(Buffer.alloc(ov.sigSize, 1)),
        ...userOp
      };
      const packed = (0, utils_1.arrayify)((0, common_1.packUserOp)(p, false));
      const lengthInWord = (packed.length + 31) / 32;
      const callDataCost = packed.map((x) => x === 0 ? ov.zeroByte : ov.nonZeroByte).reduce((sum, x) => sum + x);
      const ret = Math.round(callDataCost + ov.fixed / ov.bundleSize + ov.perUserOp + ov.perUserOpWord * lengthInWord);
      return ethers_1.BigNumber.from(ret);
    }
    exports.calcPreVerificationGas = calcPreVerificationGas;
  }
});

// node_modules/@biconomy/account/dist/src/SmartAccount.js
var require_SmartAccount = __commonJS({
  "node_modules/@biconomy/account/dist/src/SmartAccount.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SmartAccount = void 0;
    var ethers_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var utils_1 = require_utils();
    var Preverificaiton_1 = require_Preverificaiton();
    var common_1 = require_src2();
    var common_2 = require_src2();
    var SmartAccount = class {
      constructor(_smartAccountConfig) {
        this.initCode = "0x";
        this.smartAccountConfig = _smartAccountConfig;
      }
      setEntryPointAddress(entryPointAddress) {
        this.smartAccountConfig.entryPointAddress = entryPointAddress;
      }
      validateUserOp(userOp, requiredFields) {
        for (const field of requiredFields) {
          if (!userOp[field]) {
            throw new Error(`${field} is missing`);
          }
        }
        return true;
      }
      isProxyDefined() {
        if (!this.proxy)
          throw new Error("Proxy is undefined");
        return true;
      }
      isSignerDefined() {
        if (!this.signer)
          throw new Error("Signer is undefined");
        return true;
      }
      isProviderDefined() {
        if (!this.provider)
          throw new Error("Provider is undefined");
        return true;
      }
      async calculateUserOpGasValues(userOp) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!this.provider)
          throw new Error("Provider is not present for making rpc calls");
        const feeData = await this.provider.getFeeData();
        userOp.maxFeePerGas = (_c = (_b = (_a = userOp.maxFeePerGas) !== null && _a !== void 0 ? _a : feeData.maxFeePerGas) !== null && _b !== void 0 ? _b : feeData.gasPrice) !== null && _c !== void 0 ? _c : await this.provider.getGasPrice();
        userOp.maxPriorityFeePerGas = (_f = (_e = (_d = userOp.maxPriorityFeePerGas) !== null && _d !== void 0 ? _d : feeData.maxPriorityFeePerGas) !== null && _e !== void 0 ? _e : feeData.gasPrice) !== null && _f !== void 0 ? _f : await this.provider.getGasPrice();
        if (userOp.initCode)
          userOp.verificationGasLimit = (_g = userOp.verificationGasLimit) !== null && _g !== void 0 ? _g : await this.getVerificationGasLimit(userOp.initCode);
        userOp.callGasLimit = (_h = userOp.callGasLimit) !== null && _h !== void 0 ? _h : await this.provider.estimateGas({
          from: this.smartAccountConfig.entryPointAddress,
          to: userOp.sender,
          data: userOp.callData
        });
        userOp.preVerificationGas = (_j = userOp.preVerificationGas) !== null && _j !== void 0 ? _j : this.getPreVerificationGas(userOp);
        return userOp;
      }
      async estimateUserOpGas(userOp, overrides, skipBundlerGasEstimation) {
        var _a, _b, _c, _d;
        const requiredFields = ["sender", "nonce", "initCode", "callData"];
        this.validateUserOp(userOp, requiredFields);
        let finalUserOp = userOp;
        const skipBundlerCall = skipBundlerGasEstimation !== null && skipBundlerGasEstimation !== void 0 ? skipBundlerGasEstimation : false;
        if (overrides) {
          userOp = { ...userOp, ...overrides };
        }
        common_2.Logger.log("userOp in estimation", userOp);
        if (!this.bundler || skipBundlerCall) {
          if (!this.provider)
            throw new Error("Provider is not present for making rpc calls");
          finalUserOp = await this.calculateUserOpGasValues(finalUserOp);
        } else {
          const { callGasLimit, verificationGasLimit, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } = await this.bundler.estimateUserOpGas(userOp);
          if (!userOp.maxFeePerGas && !userOp.maxPriorityFeePerGas && (!maxFeePerGas || !maxPriorityFeePerGas)) {
            const feeData = await this.provider.getFeeData();
            finalUserOp.maxFeePerGas = (_b = (_a = feeData.maxFeePerGas) !== null && _a !== void 0 ? _a : feeData.gasPrice) !== null && _b !== void 0 ? _b : await this.provider.getGasPrice();
            finalUserOp.maxPriorityFeePerGas = (_d = (_c = feeData.maxPriorityFeePerGas) !== null && _c !== void 0 ? _c : feeData.gasPrice) !== null && _d !== void 0 ? _d : await this.provider.getGasPrice();
          } else {
            finalUserOp.maxFeePerGas = maxFeePerGas !== null && maxFeePerGas !== void 0 ? maxFeePerGas : userOp.maxFeePerGas;
            finalUserOp.maxPriorityFeePerGas = maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : userOp.maxPriorityFeePerGas;
          }
          finalUserOp.verificationGasLimit = verificationGasLimit !== null && verificationGasLimit !== void 0 ? verificationGasLimit : userOp.verificationGasLimit;
          finalUserOp.callGasLimit = callGasLimit !== null && callGasLimit !== void 0 ? callGasLimit : userOp.callGasLimit;
          finalUserOp.preVerificationGas = preVerificationGas !== null && preVerificationGas !== void 0 ? preVerificationGas : userOp.preVerificationGas;
        }
        return finalUserOp;
      }
      async isAccountDeployed(address) {
        this.isProviderDefined();
        let contractCode;
        try {
          contractCode = await this.provider.getCode(address);
          return contractCode !== "0x";
        } catch (error) {
          throw error;
        }
      }
      // Would only be used if paymaster is attached
      async getPaymasterAndData(userOp) {
        if (this.paymaster) {
          const paymasterAndDataResponse = await this.paymaster.getPaymasterAndData(userOp);
          return paymasterAndDataResponse.paymasterAndData;
        }
        return "0x";
      }
      nonce() {
        this.isProxyDefined();
        return this.proxy.nonce();
      }
      async signUserOpHash(userOpHash, signer) {
        if (signer) {
          return signer.signMessage((0, utils_1.arrayify)(userOpHash));
        }
        if (this.signer) {
          return this.signer.signMessage((0, utils_1.arrayify)(userOpHash));
        }
        throw new Error("No signer provided to sign userOp");
      }
      getPreVerificationGas(userOp) {
        return (0, Preverificaiton_1.calcPreVerificationGas)(userOp);
      }
      async getVerificationGasLimit(initCode) {
        const initGas = await this.estimateCreationGas(initCode);
        const validateUserOpGas = ethers_1.BigNumber.from(Preverificaiton_1.DefaultGasLimits.validatePaymasterUserOpGas + Preverificaiton_1.DefaultGasLimits.validateUserOpGas);
        const postOpGas = ethers_1.BigNumber.from(Preverificaiton_1.DefaultGasLimits.postOpGas);
        let verificationGasLimit = ethers_1.BigNumber.from(validateUserOpGas).add(initGas);
        if (ethers_1.BigNumber.from(postOpGas).gt(verificationGasLimit)) {
          verificationGasLimit = postOpGas;
        }
        return verificationGasLimit;
      }
      async getUserOpHash(userOp) {
        const userOpHash = (0, utils_1.keccak256)((0, common_1.packUserOp)(userOp, true));
        const enc = utils_1.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, this.entryPoint.address, this.chainId]);
        return (0, utils_1.keccak256)(enc);
      }
      async estimateCreationGas(initCode) {
        if (initCode == null || initCode === "0x")
          return ethers_1.BigNumber.from("0");
        const deployerAddress = initCode.substring(0, 42);
        const deployerCallData = "0x" + initCode.substring(42);
        return await this.provider.estimateGas({ to: deployerAddress, data: deployerCallData });
      }
      async signUserOp(userOp) {
        const requiredFields = [
          "sender",
          "nonce",
          "initCode",
          "callData",
          "callGasLimit",
          "verificationGasLimit",
          "preVerificationGas",
          "maxFeePerGas",
          "maxPriorityFeePerGas",
          "paymasterAndData"
        ];
        this.validateUserOp(userOp, requiredFields);
        const userOpHash = await this.getUserOpHash(userOp);
        let signature = await this.signUserOpHash(userOpHash, this.signer);
        const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);
        if (![27, 28].includes(potentiallyIncorrectV)) {
          const correctV = potentiallyIncorrectV + 27;
          signature = signature.slice(0, -2) + correctV.toString(16);
        }
        if (signature.slice(0, 2) !== "0x") {
          signature = "0x" + signature;
        }
        userOp.signature = signature;
        return userOp;
      }
      /**
       *
       * @param userOp
       * @description This function call will take 'unsignedUserOp' as an input, sign it with the owner key, and send it to the bundler.
       * @returns Promise<UserOpResponse>
       */
      async sendUserOp(userOp) {
        common_2.Logger.log("userOp received in base account ", userOp);
        const userOperation = await this.signUserOp(userOp);
        const bundlerResponse = await this.sendSignedUserOp(userOperation);
        return bundlerResponse;
      }
      /**
       *
       * @param userOp
       * @description This function call will take 'signedUserOp' as input and send it to the bundler
       * @returns
       */
      async sendSignedUserOp(userOp) {
        const requiredFields = [
          "sender",
          "nonce",
          "initCode",
          "callData",
          "callGasLimit",
          "verificationGasLimit",
          "preVerificationGas",
          "maxFeePerGas",
          "maxPriorityFeePerGas",
          "paymasterAndData",
          "signature"
        ];
        this.validateUserOp(userOp, requiredFields);
        common_2.Logger.log("userOp validated");
        if (!this.bundler)
          throw new Error("Bundler is not provided");
        const bundlerResponse = await this.bundler.sendUserOp(userOp);
        return bundlerResponse;
      }
    };
    exports.SmartAccount = SmartAccount;
  }
});

// node_modules/@biconomy/account/dist/src/utils/Constants.js
var require_Constants = __commonJS({
  "node_modules/@biconomy/account/dist/src/utils/Constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EIP1559_UNSUPPORTED_NETWORKS = exports.DEFAULT_BICONOMY_IMPLEMENTATION_ADDRESS = exports.BICONOMY_IMPLEMENTATION_ADDRESSES = exports.BICONOMY_FACTORY_ADDRESSES = exports.DEFAULT_BICONOMY_FACTORY_ADDRESS = exports.ENTRYPOINT_ADDRESSES = exports.DEFAULT_ENTRYPOINT_ADDRESS = void 0;
    exports.DEFAULT_ENTRYPOINT_ADDRESS = "0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789";
    exports.ENTRYPOINT_ADDRESSES = {
      "0x27a4db290b89ae3373ce4313cbeae72112ae7da9": "V0_0_5",
      "0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789": "V0_0_6"
    };
    exports.DEFAULT_BICONOMY_FACTORY_ADDRESS = "0x000000f9ee1842bb72f6bbdd75e6d3d4e3e9594c";
    exports.BICONOMY_FACTORY_ADDRESSES = {
      "0x000000f9ee1842bb72f6bbdd75e6d3d4e3e9594c": "V1_0_0"
    };
    exports.BICONOMY_IMPLEMENTATION_ADDRESSES = {
      "0x00006b7e42e01957da540dc6a8f7c30c4d816af5": "V1_0_0"
    };
    exports.DEFAULT_BICONOMY_IMPLEMENTATION_ADDRESS = "0x00006b7e42e01957da540dc6a8f7c30c4d816af5";
    exports.EIP1559_UNSUPPORTED_NETWORKS = [97, 56, 1442, 1101];
  }
});

// node_modules/@biconomy/account/dist/src/BiconomySmartAccount.js
var require_BiconomySmartAccount = __commonJS({
  "node_modules/@biconomy/account/dist/src/BiconomySmartAccount.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BiconomySmartAccount = void 0;
    var providers_1 = (init_lib(), __toCommonJS(lib_exports));
    var ethers_1 = (init_lib2(), __toCommonJS(lib_exports2));
    var SmartAccount_1 = require_SmartAccount();
    var common_1 = require_src2();
    var core_types_1 = require_src();
    var node_client_1 = __importDefault(require_src3());
    var paymaster_1 = require_src4();
    var Constants_1 = require_Constants();
    var BiconomySmartAccount = class extends SmartAccount_1.SmartAccount {
      constructor(biconomySmartAccountConfig) {
        const { signer, rpcUrl, entryPointAddress, bundler, paymaster, chainId, nodeClientUrl } = biconomySmartAccountConfig;
        const _entryPointAddress = entryPointAddress !== null && entryPointAddress !== void 0 ? entryPointAddress : Constants_1.DEFAULT_ENTRYPOINT_ADDRESS;
        super({
          bundler,
          entryPointAddress: _entryPointAddress
        });
        this.biconomySmartAccountConfig = biconomySmartAccountConfig;
        const _rpcUrl = rpcUrl !== null && rpcUrl !== void 0 ? rpcUrl : common_1.RPC_PROVIDER_URLS[chainId];
        if (!_rpcUrl) {
          throw new Error(`Chain Id ${chainId} is not supported. Please refer to the following link for supported chains list https://docs.biconomy.io/build-with-biconomy-sdk/gasless-transactions#supported-chains`);
        }
        this.provider = new providers_1.JsonRpcProvider(_rpcUrl);
        this.nodeClient = new node_client_1.default({ txServiceUrl: nodeClientUrl !== null && nodeClientUrl !== void 0 ? nodeClientUrl : common_1.NODE_CLIENT_URL });
        this.signer = signer;
        if (paymaster) {
          this.paymaster = paymaster;
        }
        if (bundler)
          this.bundler = bundler;
      }
      /**
       * @description This function will initialise BiconomyAccount class state
       * @returns Promise<BiconomyAccount>
       */
      async init(initilizationData) {
        try {
          let _accountIndex, signerAddress;
          if (initilizationData) {
            _accountIndex = initilizationData.accountIndex;
            signerAddress = initilizationData.signerAddress;
          }
          if (!_accountIndex)
            _accountIndex = 0;
          this.isProviderDefined();
          this.isSignerDefined();
          if (signerAddress) {
            this.owner = signerAddress;
          } else {
            this.owner = await this.signer.getAddress();
          }
          this.chainId = await this.provider.getNetwork().then((net) => net.chainId);
          await this.initializeAccountAtIndex(_accountIndex);
          this._isInitialised = true;
        } catch (error) {
          common_1.Logger.error(`Failed to call init: ${error}`);
          throw error;
        }
        return this;
      }
      isInitialized() {
        if (!this._isInitialised)
          throw new Error("BiconomySmartAccount is not initialized. Please call init() on BiconomySmartAccount instance before interacting with any other function");
        return true;
      }
      setProxyContractState() {
        if (!Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES[this.smartAccountInfo.implementationAddress])
          throw new Error("Could not find attached implementation address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const proxyInstanceDto = {
          smartAccountType: core_types_1.SmartAccountType.BICONOMY,
          version: Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES[this.address],
          contractAddress: this.address,
          provider: this.provider
        };
        this.proxy = (0, common_1.getSAProxyContract)(proxyInstanceDto);
      }
      setEntryPointContractState() {
        const _entryPointAddress = this.smartAccountInfo.entryPointAddress;
        this.setEntryPointAddress(_entryPointAddress);
        if (!Constants_1.ENTRYPOINT_ADDRESSES[_entryPointAddress])
          throw new Error("Could not find attached entrypoint address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const entryPointInstanceDto = {
          smartAccountType: core_types_1.SmartAccountType.BICONOMY,
          version: Constants_1.ENTRYPOINT_ADDRESSES[_entryPointAddress],
          contractAddress: _entryPointAddress,
          provider: this.provider
        };
        this.entryPoint = (0, common_1.getEntryPointContract)(entryPointInstanceDto);
      }
      setFactoryContractState() {
        const _factoryAddress = this.smartAccountInfo.factoryAddress;
        if (!Constants_1.BICONOMY_FACTORY_ADDRESSES[_factoryAddress])
          throw new Error("Could not find attached factory address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
        const factoryInstanceDto = {
          smartAccountType: core_types_1.SmartAccountType.BICONOMY,
          version: Constants_1.BICONOMY_FACTORY_ADDRESSES[_factoryAddress],
          contractAddress: _factoryAddress,
          provider: this.provider
        };
        this.factory = (0, common_1.getSAFactoryContract)(factoryInstanceDto);
      }
      async setContractsState() {
        this.setProxyContractState();
        this.setEntryPointContractState();
        this.setFactoryContractState();
      }
      async initializeAccountAtIndex(accountIndex) {
        this.accountIndex = accountIndex;
        this.address = await this.getSmartAccountAddress(accountIndex);
        await this.setContractsState();
        await this.setInitCode(this.accountIndex);
      }
      async getSmartAccountAddress(accountIndex = 0) {
        try {
          this.isSignerDefined();
          let smartAccountsList = (await this.getSmartAccountsByOwner({
            chainId: this.chainId,
            owner: this.owner,
            index: accountIndex
          })).data;
          if (!smartAccountsList)
            throw new Error("Failed to get smart account address. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
          smartAccountsList = smartAccountsList.filter((smartAccount) => {
            return accountIndex === smartAccount.index;
          });
          if (smartAccountsList.length === 0)
            throw new Error("Failed to get smart account address. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.");
          this.smartAccountInfo = smartAccountsList[0];
          return this.smartAccountInfo.smartAccountAddress;
        } catch (error) {
          common_1.Logger.error(`Failed to get smart account address: ${error}`);
          throw error;
        }
      }
      async setInitCode(accountIndex = 0) {
        this.initCode = ethers_1.ethers.utils.hexConcat([
          this.factory.address,
          this.factory.interface.encodeFunctionData("deployCounterFactualAccount", [
            this.owner,
            ethers_1.ethers.BigNumber.from(accountIndex)
          ])
        ]);
        return this.initCode;
      }
      /**
       * @description an overrided function to showcase overriding example
       * @returns
       */
      nonce() {
        this.isProxyDefined();
        return this.proxy.nonce();
      }
      /**
       *
       * @param to { target } address of transaction
       * @param value  represents amount of native tokens
       * @param data represent data associated with transaction
       * @returns
       */
      getExecuteCallData(to, value, data) {
        this.isInitialized();
        this.isProxyDefined();
        const executeCallData = this.proxy.interface.encodeFunctionData("executeCall", [
          to,
          value,
          data
        ]);
        return executeCallData;
      }
      /**
       *
       * @param to { target } array of addresses in transaction
       * @param value  represents array of amount of native tokens associated with each transaction
       * @param data represent array of data associated with each transaction
       * @returns
       */
      getExecuteBatchCallData(to, value, data) {
        this.isInitialized();
        this.isProxyDefined();
        const executeBatchCallData = this.proxy.interface.encodeFunctionData("executeBatchCall", [
          to,
          value,
          data
        ]);
        return executeBatchCallData;
      }
      getDummySignature() {
        return "0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b";
      }
      getDummyPaymasterData() {
        return "0x";
      }
      async buildUserOp(transactions, overrides, skipBundlerGasEstimation) {
        this.isInitialized();
        const to = transactions.map((element) => element.to);
        const data = transactions.map((element) => {
          var _a;
          return (_a = element.data) !== null && _a !== void 0 ? _a : "0x";
        });
        const value = transactions.map((element) => {
          var _a;
          return (_a = element.value) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from("0");
        });
        this.isProxyDefined();
        let callData = "";
        if (transactions.length === 1) {
          callData = this.getExecuteCallData(to[0], value[0], data[0]);
        } else {
          callData = this.getExecuteBatchCallData(to, value, data);
        }
        let nonce = ethers_1.BigNumber.from(0);
        try {
          nonce = await this.nonce();
        } catch (error) {
        }
        let userOp = {
          sender: this.address,
          nonce,
          initCode: nonce.eq(0) ? this.initCode : "0x",
          callData
        };
        userOp.signature = this.getDummySignature();
        userOp = await this.estimateUserOpGas(userOp, overrides, skipBundlerGasEstimation);
        common_1.Logger.log("userOp after estimation ", userOp);
        userOp.paymasterAndData = "0x";
        return userOp;
      }
      validateUserOpAndRequest(userOp, tokenPaymasterRequest) {
        var _a;
        if (!userOp.callData) {
          throw new Error("Userop callData cannot be undefined");
        }
        const feeTokenAddress = (_a = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.feeQuote) === null || _a === void 0 ? void 0 : _a.tokenAddress;
        common_1.Logger.log("requested fee token is ", feeTokenAddress);
        if (!feeTokenAddress || feeTokenAddress == ethers_1.ethers.constants.AddressZero) {
          throw new Error("Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest");
        }
        const spender = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.spender;
        common_1.Logger.log("fee token approval to be checked and added for spender: ", spender);
        if (!spender || spender == ethers_1.ethers.constants.AddressZero) {
          throw new Error("Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest");
        }
      }
      /**
       *
       * @param userOp partial user operation without signature and paymasterAndData
       * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
       *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
       * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
       * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
       * @returns updated userOp with new callData, callGasLimit
       */
      async buildTokenPaymasterUserOp(userOp, tokenPaymasterRequest) {
        this.validateUserOpAndRequest(userOp, tokenPaymasterRequest);
        try {
          let batchTo = [];
          let batchValue = [];
          let batchData = [];
          let newCallData = userOp.callData;
          common_1.Logger.log("received information about fee token address and quote ", tokenPaymasterRequest);
          if (this.paymaster && this.paymaster instanceof paymaster_1.BiconomyPaymaster) {
            const approvalRequest = await this.paymaster.buildTokenApprovalTransaction(tokenPaymasterRequest, this.provider);
            common_1.Logger.log("approvalRequest is for erc20 token ", approvalRequest.to);
            if (approvalRequest.data == "0x" || approvalRequest.to == ethers_1.ethers.constants.AddressZero) {
              return userOp;
            }
            if (!userOp.callData) {
              throw new Error("Userop callData cannot be undefined");
            }
            const decodedDataSmartWallet = this.proxy.interface.parseTransaction({
              data: userOp.callData.toString()
            });
            if (!decodedDataSmartWallet) {
              throw new Error("Could not parse call data of smart wallet for userOp");
            }
            const smartWalletExecFunctionName = decodedDataSmartWallet.name;
            if (smartWalletExecFunctionName === "executeCall") {
              common_1.Logger.log("originally an executeCall for Biconomy Account");
              const methodArgsSmartWalletExecuteCall = decodedDataSmartWallet.args;
              const toOriginal = methodArgsSmartWalletExecuteCall[0];
              const valueOriginal = methodArgsSmartWalletExecuteCall[1];
              const dataOriginal = methodArgsSmartWalletExecuteCall[2];
              batchTo.push(toOriginal);
              batchValue.push(valueOriginal);
              batchData.push(dataOriginal);
            } else if (smartWalletExecFunctionName === "executeBatchCall") {
              common_1.Logger.log("originally an executeBatchCall for Biconomy Account");
              const methodArgsSmartWalletExecuteCall = decodedDataSmartWallet.args;
              batchTo = methodArgsSmartWalletExecuteCall[0];
              batchValue = methodArgsSmartWalletExecuteCall[1];
              batchData = methodArgsSmartWalletExecuteCall[2];
            }
            if (approvalRequest.to && approvalRequest.data && approvalRequest.value) {
              batchTo = [approvalRequest.to, ...batchTo];
              batchValue = [approvalRequest.value, ...batchValue];
              batchData = [approvalRequest.data, ...batchData];
              newCallData = this.getExecuteBatchCallData(batchTo, batchValue, batchData);
            }
            let finalUserOp = {
              ...userOp,
              callData: newCallData
            };
            finalUserOp = await this.estimateUserOpGas(finalUserOp);
            common_1.Logger.log("userOp after estimation ", finalUserOp);
            return finalUserOp;
          }
        } catch (error) {
          common_1.Logger.log("Failed to update userOp. sending back original op");
          common_1.Logger.error("Failed to update callData with error", error);
          return userOp;
        }
        return userOp;
      }
      async getAllTokenBalances(balancesDto) {
        return this.nodeClient.getAllTokenBalances(balancesDto);
      }
      async getTotalBalanceInUsd(balancesDto) {
        return this.nodeClient.getTotalBalanceInUsd(balancesDto);
      }
      async getSmartAccountsByOwner(smartAccountByOwnerDto) {
        return this.nodeClient.getSmartAccountsByOwner(smartAccountByOwnerDto);
      }
      async getTransactionsByAddress(chainId, address) {
        return this.nodeClient.getTransactionByAddress(chainId, address);
      }
      async getTransactionByHash(txHash) {
        return this.nodeClient.getTransactionByHash(txHash);
      }
      async getAllSupportedChains() {
        return this.nodeClient.getAllSupportedChains();
      }
    };
    exports.BiconomySmartAccount = BiconomySmartAccount;
  }
});

// node_modules/@biconomy/account/dist/src/index.js
var require_src5 = __commonJS({
  "node_modules/@biconomy/account/dist/src/index.js"(exports) {
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ISmartAccount(), exports);
    __exportStar(require_Types(), exports);
    __exportStar(require_SmartAccount(), exports);
    __exportStar(require_BiconomySmartAccount(), exports);
    __exportStar(require_Constants(), exports);
  }
});
export default require_src5();
//# sourceMappingURL=@biconomy_account.js.map
