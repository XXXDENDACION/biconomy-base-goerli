import {
  BaseProvider,
  BigNumber,
  CHAIN_NAMESPACES,
  JRPCEngine,
  WalletInitializationError,
  WalletLoginError,
  _assertThisInitialized,
  _asyncToGenerator,
  _classCallCheck,
  _createClass,
  _defineProperty,
  _get,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  _typeof,
  bignumber_default,
  createAsyncMiddleware,
  createFetchMiddleware,
  createScaffoldMiddleware,
  get,
  getChainConfig,
  init_assertThisInitialized,
  init_asyncToGenerator,
  init_baseControllers_esm,
  init_baseProvider_esm,
  init_base_esm,
  init_bignumber,
  init_classCallCheck,
  init_createClass,
  init_defineProperty,
  init_get,
  init_getPrototypeOf,
  init_httpHelpers_esm,
  init_inherits,
  init_openloginJrpc_esm,
  init_possibleConstructorReturn,
  init_typeof,
  isHexStrict,
  log,
  mergeMiddleware,
  providerFromEngine,
  require_dist,
  require_dist2,
  require_dist3,
  require_events,
  require_keccak,
  require_lib,
  require_regenerator,
  require_sha256,
  require_utils,
  signMessage
} from "./chunk-AGHNXXPG.js";
import {
  require_crypto
} from "./chunk-4V33XHYS.js";
import {
  init_lib20 as init_lib,
  lib_exports17 as lib_exports
} from "./chunk-VF42ZICC.js";
import {
  require_bn,
  require_buffer,
  require_inherits_browser
} from "./chunk-NNQCPY7Z.js";
import {
  Buffer,
  __commonJS,
  __esm,
  __require,
  __toCommonJS,
  __toESM,
  init_buffer,
  init_process,
  process
} from "./chunk-YS2TNBJ3.js";

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "node_modules/crc-32/crc32.js"(exports) {
    init_process();
    init_buffer();
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n)
          table[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256)
            v = table[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n)
          out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; )
          C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L)
          C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// node_modules/@ethereumjs/common/dist/chains/goerli.json
var require_goerli = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/goerli.json"(exports, module) {
    module.exports = {
      name: "goerli",
      chainId: 5,
      networkId: 5,
      defaultHardfork: "merge",
      consensus: {
        type: "poa",
        algorithm: "clique",
        clique: {
          period: 15,
          epoch: 3e4
        }
      },
      comment: "Cross-client PoA test network",
      url: "https://github.com/goerli/testnet",
      genesis: {
        timestamp: "0x5c51a607",
        gasLimit: 10485760,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "istanbul",
          block: 1561651,
          forkHash: "0xc25efa5c"
        },
        {
          name: "berlin",
          block: 4460644,
          forkHash: "0x757a1c47"
        },
        {
          name: "london",
          block: 5062605,
          forkHash: "0xb8c6299d"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
          name: "merge",
          ttd: "10790000",
          block: 7382819,
          forkHash: "0xb8c6299d"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          forkHash: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "51.141.78.53",
          port: 30303,
          id: "011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",
          location: "",
          comment: "Upstream bootnode 1"
        },
        {
          ip: "13.93.54.137",
          port: 30303,
          id: "176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",
          location: "",
          comment: "Upstream bootnode 2"
        },
        {
          ip: "94.237.54.114",
          port: 30313,
          id: "46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",
          location: "",
          comment: "Upstream bootnode 3"
        },
        {
          ip: "18.218.250.66",
          port: 30313,
          id: "b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",
          location: "",
          comment: "Upstream bootnode 4"
        },
        {
          ip: "3.11.147.67",
          port: 30303,
          id: "a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",
          location: "",
          comment: "Ethereum Foundation bootnode"
        },
        {
          ip: "51.15.116.226",
          port: 30303,
          id: "a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",
          location: "",
          comment: "Goerli Initiative bootnode"
        },
        {
          ip: "51.15.119.157",
          port: 30303,
          id: "807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",
          location: "",
          comment: "Goerli Initiative bootnode"
        },
        {
          ip: "51.15.119.157",
          port: 40303,
          id: "a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",
          location: "",
          comment: "Goerli Initiative bootnode"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/chains/mainnet.json
var require_mainnet = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/mainnet.json"(exports, module) {
    module.exports = {
      name: "mainnet",
      chainId: 1,
      networkId: 1,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "The Ethereum main chain",
      url: "https://ethstats.net/",
      genesis: {
        gasLimit: 5e3,
        difficulty: 17179869184,
        nonce: "0x0000000000000042",
        extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xfc64ec04"
        },
        {
          name: "homestead",
          block: 115e4,
          forkHash: "0x97c2c34c"
        },
        {
          name: "dao",
          block: 192e4,
          forkHash: "0x91d1f948"
        },
        {
          name: "tangerineWhistle",
          block: 2463e3,
          forkHash: "0x7a64da13"
        },
        {
          name: "spuriousDragon",
          block: 2675e3,
          forkHash: "0x3edd5b10"
        },
        {
          name: "byzantium",
          block: 437e4,
          forkHash: "0xa00bc324"
        },
        {
          name: "constantinople",
          block: 728e4,
          forkHash: "0x668db0af"
        },
        {
          name: "petersburg",
          block: 728e4,
          forkHash: "0x668db0af"
        },
        {
          name: "istanbul",
          block: 9069e3,
          forkHash: "0x879d6e30"
        },
        {
          name: "muirGlacier",
          block: 92e5,
          forkHash: "0xe029e991"
        },
        {
          name: "berlin",
          block: 12244e3,
          forkHash: "0x0eb440f6"
        },
        {
          name: "london",
          block: 12965e3,
          forkHash: "0xb715077d"
        },
        {
          name: "arrowGlacier",
          block: 13773e3,
          forkHash: "0x20c327fc"
        },
        {
          name: "grayGlacier",
          block: 1505e4,
          forkHash: "0xf0afd0e3"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
          name: "merge",
          ttd: "58750000000000000000000",
          block: 15537394,
          forkHash: "0xf0afd0e3"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          forkHash: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "18.138.108.67",
          port: 30303,
          id: "d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",
          location: "ap-southeast-1-001",
          comment: "bootnode-aws-ap-southeast-1-001"
        },
        {
          ip: "3.209.45.79",
          port: 30303,
          id: "22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",
          location: "us-east-1-001",
          comment: "bootnode-aws-us-east-1-001"
        },
        {
          ip: "34.255.23.113",
          port: 30303,
          id: "ca6de62fce278f96aea6ec5a2daadb877e51651247cb96ee310a318def462913b653963c155a0ef6c7d50048bba6e6cea881130857413d9f50a621546b590758",
          location: "eu-west-1-001",
          comment: "bootnode-aws-eu-west-1-001"
        },
        {
          ip: "35.158.244.151",
          port: 30303,
          id: "279944d8dcd428dffaa7436f25ca0ca43ae19e7bcf94a8fb7d1641651f92d121e972ac2e8f381414b80cc8e5555811c2ec6e1a99bb009b3f53c4c69923e11bd8",
          location: "eu-central-1-001",
          comment: "bootnode-aws-eu-central-1-001"
        },
        {
          ip: "52.187.207.27",
          port: 30303,
          id: "8499da03c47d637b20eee24eec3c356c9a2e6148d6fe25ca195c7949ab8ec2c03e3556126b0d7ed644675e78c4318b08691b7b57de10e5f0d40d05b09238fa0a",
          location: "australiaeast-001",
          comment: "bootnode-azure-australiaeast-001"
        },
        {
          ip: "191.234.162.198",
          port: 30303,
          id: "103858bdb88756c71f15e9b5e09b56dc1be52f0a5021d46301dbbfb7e130029cc9d0d6f73f693bc29b665770fff7da4d34f3c6379fe12721b5d7a0bcb5ca1fc1",
          location: "brazilsouth-001",
          comment: "bootnode-azure-brazilsouth-001"
        },
        {
          ip: "52.231.165.108",
          port: 30303,
          id: "715171f50508aba88aecd1250af392a45a330af91d7b90701c436b618c86aaa1589c9184561907bebbb56439b8f8787bc01f49a7c77276c58c1b09822d75e8e8",
          location: "koreasouth-001",
          comment: "bootnode-azure-koreasouth-001"
        },
        {
          ip: "104.42.217.25",
          port: 30303,
          id: "5d6d7cd20d6da4bb83a1d28cadb5d409b64edf314c0335df658c1a54e32c7c4a7ab7823d57c39b6a757556e68ff1df17c748b698544a55cb488b52479a92b60f",
          location: "westus-001",
          comment: "bootnode-azure-westus-001"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/chains/rinkeby.json
var require_rinkeby = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/rinkeby.json"(exports, module) {
    module.exports = {
      name: "rinkeby",
      chainId: 4,
      networkId: 4,
      defaultHardfork: "london",
      consensus: {
        type: "poa",
        algorithm: "clique",
        clique: {
          period: 15,
          epoch: 3e4
        }
      },
      comment: "PoA test network",
      url: "https://www.rinkeby.io",
      genesis: {
        timestamp: "0x58ee40ba",
        gasLimit: 47e5,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0x3b8e0691"
        },
        {
          name: "homestead",
          block: 1,
          forkHash: "0x60949295"
        },
        {
          name: "tangerineWhistle",
          block: 2,
          forkHash: "0x8bde40dd"
        },
        {
          name: "spuriousDragon",
          block: 3,
          forkHash: "0xcb3a64bb"
        },
        {
          name: "byzantium",
          block: 1035301,
          forkHash: "0x8d748b57"
        },
        {
          name: "constantinople",
          block: 3660663,
          forkHash: "0xe49cab14"
        },
        {
          name: "petersburg",
          block: 4321234,
          forkHash: "0xafec6b27"
        },
        {
          name: "istanbul",
          block: 5435345,
          forkHash: "0xcbdb8838"
        },
        {
          name: "berlin",
          block: 8290928,
          forkHash: "0x6910c8bd"
        },
        {
          name: "london",
          block: 8897988,
          forkHash: "0x8e29f2f3"
        },
        {
          name: "merge",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          forkHash: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "52.169.42.101",
          port: 30303,
          id: "a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",
          location: "",
          comment: "IE"
        },
        {
          ip: "52.3.158.184",
          port: 30303,
          id: "343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",
          location: "",
          comment: "INFURA"
        },
        {
          ip: "159.89.28.211",
          port: 30303,
          id: "b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",
          location: "",
          comment: "AKASHA"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/chains/ropsten.json
var require_ropsten = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/ropsten.json"(exports, module) {
    module.exports = {
      name: "ropsten",
      chainId: 3,
      networkId: 3,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "PoW test network",
      url: "https://github.com/ethereum/ropsten",
      genesis: {
        gasLimit: 16777216,
        difficulty: 1048576,
        nonce: "0x0000000000000042",
        extraData: "0x3535353535353535353535353535353535353535353535353535353535353535"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0x30c7ddbc"
        },
        {
          name: "spuriousDragon",
          block: 10,
          forkHash: "0x63760190"
        },
        {
          name: "byzantium",
          block: 17e5,
          forkHash: "0x3ea159c7"
        },
        {
          name: "constantinople",
          block: 423e4,
          forkHash: "0x97b544f3"
        },
        {
          name: "petersburg",
          block: 4939394,
          forkHash: "0xd6e2149b"
        },
        {
          name: "istanbul",
          block: 6485846,
          forkHash: "0x4bc66396"
        },
        {
          name: "muirGlacier",
          block: 7117117,
          forkHash: "0x6727ef90"
        },
        {
          name: "berlin",
          block: 9812189,
          forkHash: "0xa157d377"
        },
        {
          name: "london",
          block: 10499401,
          forkHash: "0x7119b6b3"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge",
          name: "merge",
          ttd: "50000000000000000",
          block: null,
          forkHash: "0x7119b6b3"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          forkHash: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "52.176.7.10",
          port: 30303,
          id: "30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",
          location: "",
          comment: "US-Azure geth"
        },
        {
          ip: "52.176.100.77",
          port: 30303,
          id: "865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",
          location: "",
          comment: "US-Azure parity"
        },
        {
          ip: "52.232.243.152",
          port: 30303,
          id: "6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",
          location: "",
          comment: "Parity"
        },
        {
          ip: "192.81.208.223",
          port: 30303,
          id: "94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",
          location: "",
          comment: "@gpip"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/chains/sepolia.json
var require_sepolia = __commonJS({
  "node_modules/@ethereumjs/common/dist/chains/sepolia.json"(exports, module) {
    module.exports = {
      name: "sepolia",
      chainId: 11155111,
      networkId: 11155111,
      defaultHardfork: "merge",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "PoW test network to replace Ropsten",
      url: "https://github.com/ethereum/go-ethereum/pull/23730",
      genesis: {
        timestamp: "0x6159af19",
        gasLimit: 3e7,
        difficulty: 131072,
        nonce: "0x0000000000000000",
        extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "istanbul",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "muirGlacier",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "berlin",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "london",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
          name: "merge",
          ttd: "17000000000000000",
          block: 1450409,
          forkHash: "0xfe3366e7"
        },
        {
          name: "mergeForkIdTransition",
          block: 1735371,
          forkHash: "0xb96cbd13"
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1677557088",
          forkHash: "0xf7f9bc08"
        }
      ],
      bootstrapNodes: [
        {
          ip: "18.168.182.86",
          port: 30303,
          id: "9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",
          location: "",
          comment: "geth"
        },
        {
          ip: "52.14.151.177",
          port: 30303,
          id: "ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",
          location: "",
          comment: "besu"
        },
        {
          ip: "165.22.196.173",
          port: 30303,
          id: "ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",
          location: "",
          comment: "EF"
        },
        {
          ip: "65.108.95.67",
          port: 30303,
          id: "075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",
          location: "",
          comment: "lodestar"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
      ]
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/1153.json
var require__ = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/1153.json"(exports, module) {
    module.exports = {
      name: "EIP-1153",
      number: 1153,
      comment: "Transient Storage",
      url: "https://eips.ethereum.org/EIPS/eip-1153",
      status: "Review",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        tstore: {
          v: 100,
          d: "Base fee of the TSTORE opcode"
        },
        tload: {
          v: 100,
          d: "Base fee of the TLOAD opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/1559.json
var require__2 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/1559.json"(exports, module) {
    module.exports = {
      name: "EIP-1559",
      number: 1559,
      comment: "Fee market change for ETH 1.0 chain",
      url: "https://eips.ethereum.org/EIPS/eip-1559",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [2930],
      gasConfig: {
        baseFeeMaxChangeDenominator: {
          v: 8,
          d: "Maximum base fee change denominator"
        },
        elasticityMultiplier: {
          v: 2,
          d: "Maximum block gas target elasticity"
        },
        initialBaseFee: {
          v: 1e9,
          d: "Initial base fee on first EIP1559 block"
        }
      },
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2315.json
var require__3 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2315.json"(exports, module) {
    module.exports = {
      name: "EIP-2315",
      number: 2315,
      comment: "Simple subroutines for the EVM",
      url: "https://eips.ethereum.org/EIPS/eip-2315",
      status: "Draft",
      minimumHardfork: "istanbul",
      gasConfig: {},
      gasPrices: {
        beginsub: {
          v: 2,
          d: "Base fee of the BEGINSUB opcode"
        },
        returnsub: {
          v: 5,
          d: "Base fee of the RETURNSUB opcode"
        },
        jumpsub: {
          v: 10,
          d: "Base fee of the JUMPSUB opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2537.json
var require__4 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2537.json"(exports, module) {
    module.exports = {
      name: "EIP-2537",
      number: 2537,
      comment: "BLS12-381 precompiles",
      url: "https://eips.ethereum.org/EIPS/eip-2537",
      status: "Draft",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {
        Bls12381G1AddGas: {
          v: 600,
          d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
        },
        Bls12381G1MulGas: {
          v: 12e3,
          d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
        },
        Bls12381G2AddGas: {
          v: 4500,
          d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
        },
        Bls12381G2MulGas: {
          v: 55e3,
          d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
        },
        Bls12381PairingBaseGas: {
          v: 115e3,
          d: "Base gas cost of BLS12-381 pairing check"
        },
        Bls12381PairingPerPairGas: {
          v: 23e3,
          d: "Per-pair gas cost of BLS12-381 pairing check"
        },
        Bls12381MapG1Gas: {
          v: 5500,
          d: "Gas cost of BLS12-381 map field element to G1"
        },
        Bls12381MapG2Gas: {
          v: 11e4,
          d: "Gas cost of BLS12-381 map field element to G2"
        },
        Bls12381MultiExpGasDiscount: {
          v: [
            [1, 1200],
            [2, 888],
            [3, 764],
            [4, 641],
            [5, 594],
            [6, 547],
            [7, 500],
            [8, 453],
            [9, 438],
            [10, 423],
            [11, 408],
            [12, 394],
            [13, 379],
            [14, 364],
            [15, 349],
            [16, 334],
            [17, 330],
            [18, 326],
            [19, 322],
            [20, 318],
            [21, 314],
            [22, 310],
            [23, 306],
            [24, 302],
            [25, 298],
            [26, 294],
            [27, 289],
            [28, 285],
            [29, 281],
            [30, 277],
            [31, 273],
            [32, 269],
            [33, 268],
            [34, 266],
            [35, 265],
            [36, 263],
            [37, 262],
            [38, 260],
            [39, 259],
            [40, 257],
            [41, 256],
            [42, 254],
            [43, 253],
            [44, 251],
            [45, 250],
            [46, 248],
            [47, 247],
            [48, 245],
            [49, 244],
            [50, 242],
            [51, 241],
            [52, 239],
            [53, 238],
            [54, 236],
            [55, 235],
            [56, 233],
            [57, 232],
            [58, 231],
            [59, 229],
            [60, 228],
            [61, 226],
            [62, 225],
            [63, 223],
            [64, 222],
            [65, 221],
            [66, 220],
            [67, 219],
            [68, 219],
            [69, 218],
            [70, 217],
            [71, 216],
            [72, 216],
            [73, 215],
            [74, 214],
            [75, 213],
            [76, 213],
            [77, 212],
            [78, 211],
            [79, 211],
            [80, 210],
            [81, 209],
            [82, 208],
            [83, 208],
            [84, 207],
            [85, 206],
            [86, 205],
            [87, 205],
            [88, 204],
            [89, 203],
            [90, 202],
            [91, 202],
            [92, 201],
            [93, 200],
            [94, 199],
            [95, 199],
            [96, 198],
            [97, 197],
            [98, 196],
            [99, 196],
            [100, 195],
            [101, 194],
            [102, 193],
            [103, 193],
            [104, 192],
            [105, 191],
            [106, 191],
            [107, 190],
            [108, 189],
            [109, 188],
            [110, 188],
            [111, 187],
            [112, 186],
            [113, 185],
            [114, 185],
            [115, 184],
            [116, 183],
            [117, 182],
            [118, 182],
            [119, 181],
            [120, 180],
            [121, 179],
            [122, 179],
            [123, 178],
            [124, 177],
            [125, 176],
            [126, 176],
            [127, 175],
            [128, 174]
          ],
          d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2565.json
var require__5 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2565.json"(exports, module) {
    module.exports = {
      name: "EIP-2565",
      number: 2565,
      comment: "ModExp gas cost",
      url: "https://eips.ethereum.org/EIPS/eip-2565",
      status: "Final",
      minimumHardfork: "byzantium",
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 3,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2718.json
var require__6 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2718.json"(exports, module) {
    module.exports = {
      name: "EIP-2718",
      comment: "Typed Transaction Envelope",
      url: "https://eips.ethereum.org/EIPS/eip-2718",
      status: "Final",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2929.json
var require__7 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2929.json"(exports, module) {
    module.exports = {
      name: "EIP-2929",
      comment: "Gas cost increases for state access opcodes",
      url: "https://eips.ethereum.org/EIPS/eip-2929",
      status: "Final",
      minimumHardfork: "chainstart",
      gasConfig: {},
      gasPrices: {
        coldsload: {
          v: 2100,
          d: "Gas cost of the first read of storage from a given location (per transaction)"
        },
        coldaccountaccess: {
          v: 2600,
          d: "Gas cost of the first read of a given address (per transaction)"
        },
        warmstorageread: {
          v: 100,
          d: "Gas cost of reading storage locations which have already loaded 'cold'"
        },
        sstoreCleanGasEIP2200: {
          v: 2900,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreNoopGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitRefundEIP2200: {
          v: 19900,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanRefundEIP2200: {
          v: 4900,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        call: {
          v: 0,
          d: "Base fee of the CALL opcode"
        },
        callcode: {
          v: 0,
          d: "Base fee of the CALLCODE opcode"
        },
        delegatecall: {
          v: 0,
          d: "Base fee of the DELEGATECALL opcode"
        },
        staticcall: {
          v: 0,
          d: "Base fee of the STATICCALL opcode"
        },
        balance: {
          v: 0,
          d: "Base fee of the BALANCE opcode"
        },
        extcodesize: {
          v: 0,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 0,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        extcodehash: {
          v: 0,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        sload: {
          v: 0,
          d: "Base fee of the SLOAD opcode"
        },
        sstore: {
          v: 0,
          d: "Base fee of the SSTORE opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/2930.json
var require__8 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/2930.json"(exports, module) {
    module.exports = {
      name: "EIP-2930",
      comment: "Optional access lists",
      url: "https://eips.ethereum.org/EIPS/eip-2930",
      status: "Final",
      minimumHardfork: "istanbul",
      requiredEIPs: [2718, 2929],
      gasConfig: {},
      gasPrices: {
        accessListStorageKeyCost: {
          v: 1900,
          d: "Gas cost per storage key in an Access List transaction"
        },
        accessListAddressCost: {
          v: 2400,
          d: "Gas cost per storage key in an Access List transaction"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3074.json
var require__9 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3074.json"(exports, module) {
    module.exports = {
      name: "EIP-3074",
      number: 3074,
      comment: "AUTH and AUTHCALL opcodes",
      url: "https://eips.ethereum.org/EIPS/eip-3074",
      status: "Review",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {
        auth: {
          v: 3100,
          d: "Gas cost of the AUTH opcode"
        },
        authcall: {
          v: 0,
          d: "Gas cost of the AUTHCALL opcode"
        },
        authcallValueTransfer: {
          v: 6700,
          d: "Paid for CALL when the value transfer is non-zero"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3198.json
var require__10 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3198.json"(exports, module) {
    module.exports = {
      name: "EIP-3198",
      number: 3198,
      comment: "BASEFEE opcode",
      url: "https://eips.ethereum.org/EIPS/eip-3198",
      status: "Final",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {
        basefee: {
          v: 2,
          d: "Gas cost of the BASEFEE opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3529.json
var require__11 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3529.json"(exports, module) {
    module.exports = {
      name: "EIP-3529",
      comment: "Reduction in refunds",
      url: "https://eips.ethereum.org/EIPS/eip-3529",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [2929],
      gasConfig: {
        maxRefundQuotient: {
          v: 5,
          d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
      },
      gasPrices: {
        selfdestructRefund: {
          v: 0,
          d: "Refunded following a selfdestruct operation"
        },
        sstoreClearRefundEIP2200: {
          v: 4800,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3540.json
var require__12 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3540.json"(exports, module) {
    module.exports = {
      name: "EIP-3540",
      number: 3540,
      comment: "EVM Object Format (EOF) v1",
      url: "https://eips.ethereum.org/EIPS/eip-3540",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [3541],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3541.json
var require__13 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3541.json"(exports, module) {
    module.exports = {
      name: "EIP-3541",
      comment: "Reject new contracts starting with the 0xEF byte",
      url: "https://eips.ethereum.org/EIPS/eip-3541",
      status: "Final",
      minimumHardfork: "berlin",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3554.json
var require__14 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3554.json"(exports, module) {
    module.exports = {
      name: "EIP-3554",
      comment: "Reduction in refunds",
      url: "Difficulty Bomb Delay to December 1st 2021",
      status: "Final",
      minimumHardfork: "muirGlacier",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 95e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3607.json
var require__15 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3607.json"(exports, module) {
    module.exports = {
      name: "EIP-3607",
      number: 3607,
      comment: "Reject transactions from senders with deployed code",
      url: "https://eips.ethereum.org/EIPS/eip-3607",
      status: "Final",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3651.json
var require__16 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3651.json"(exports, module) {
    module.exports = {
      name: "EIP-3651",
      number: 3198,
      comment: "Warm COINBASE",
      url: "https://eips.ethereum.org/EIPS/eip-3651",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [2929],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3670.json
var require__17 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3670.json"(exports, module) {
    module.exports = {
      name: "EIP-3670",
      number: 3670,
      comment: "EOF - Code Validation",
      url: "https://eips.ethereum.org/EIPS/eip-3670",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [3540],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3675.json
var require__18 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3675.json"(exports, module) {
    module.exports = {
      name: "EIP-3675",
      number: 3675,
      comment: "Upgrade consensus to Proof-of-Stake",
      url: "https://eips.ethereum.org/EIPS/eip-3675",
      status: "Final",
      minimumHardfork: "london",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3855.json
var require__19 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3855.json"(exports, module) {
    module.exports = {
      name: "EIP-3855",
      number: 3855,
      comment: "PUSH0 instruction",
      url: "https://eips.ethereum.org/EIPS/eip-3855",
      status: "Review",
      minimumHardfork: "chainstart",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        push0: {
          v: 2,
          d: "Base fee of the PUSH0 opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/3860.json
var require__20 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/3860.json"(exports, module) {
    module.exports = {
      name: "EIP-3860",
      number: 3860,
      comment: "Limit and meter initcode",
      url: "https://eips.ethereum.org/EIPS/eip-3860",
      status: "Review",
      minimumHardfork: "spuriousDragon",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        initCodeWordCost: {
          v: 2,
          d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
        }
      },
      vm: {
        maxInitCodeSize: {
          v: 49152,
          d: "Maximum length of initialization code when creating a contract"
        }
      },
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/4345.json
var require__21 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/4345.json"(exports, module) {
    module.exports = {
      name: "EIP-4345",
      number: 4345,
      comment: "Difficulty Bomb Delay to June 2022",
      url: "https://eips.ethereum.org/EIPS/eip-4345",
      status: "Final",
      minimumHardfork: "london",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 107e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/4399.json
var require__22 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/4399.json"(exports, module) {
    module.exports = {
      name: "EIP-4399",
      number: 4399,
      comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
      url: "https://eips.ethereum.org/EIPS/eip-4399",
      status: "Review",
      minimumHardfork: "london",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/4844.json
var require__23 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/4844.json"(exports, module) {
    module.exports = {
      name: "EIP-4844",
      number: 4844,
      comment: "Shard Blob Transactions",
      url: "https://eips.ethereum.org/EIPS/eip-4844",
      status: "Draft",
      minimumHardfork: "merge",
      requiredEIPs: [1559, 2718, 2930, 4895],
      gasConfig: {
        dataGasPerBlob: {
          v: 131072,
          d: "The base fee for data gas per blob"
        },
        targetDataGasPerBlock: {
          v: 262144,
          d: "The target data gas consumed per block"
        },
        maxDataGasPerBlock: {
          v: 524288,
          d: "The max data gas allowable per block"
        },
        dataGasPriceUpdateFraction: {
          v: 2225652,
          d: "The denominator used in the exponential when calculating a data gas price"
        }
      },
      gasPrices: {
        simpleGasPerBlob: {
          v: 12e3,
          d: "The basic gas fee for each blob"
        },
        minDataGasPrice: {
          v: 1,
          d: "The minimum fee per data gas"
        },
        kzgPointEvaluationGasPrecompilePrice: {
          v: 5e4,
          d: "The fee associated with the point evaluation precompile"
        },
        datahash: {
          v: 3,
          d: "Base fee of the DATAHASH opcode"
        }
      },
      sharding: {
        blobCommitmentVersionKzg: {
          v: 1,
          d: "The number indicated a versioned hash is a KZG commitment"
        },
        fieldElementsPerBlob: {
          v: 4096,
          d: "The number of field elements allowed per blob"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/4895.json
var require__24 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/4895.json"(exports, module) {
    module.exports = {
      name: "EIP-4895",
      number: 4895,
      comment: "Beacon chain push withdrawals as operations",
      url: "https://eips.ethereum.org/EIPS/eip-4895",
      status: "Review",
      minimumHardfork: "merge",
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/5133.json
var require__25 = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/5133.json"(exports, module) {
    module.exports = {
      name: "EIP-5133",
      number: 5133,
      comment: "Delaying Difficulty Bomb to mid-September 2022",
      url: "https://eips.ethereum.org/EIPS/eip-5133",
      status: "Draft",
      minimumHardfork: "grayGlacier",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 114e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/eips/index.js
var require_eips = __commonJS({
  "node_modules/@ethereumjs/common/dist/eips/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EIPs = void 0;
    exports.EIPs = {
      1153: require__(),
      1559: require__2(),
      2315: require__3(),
      2537: require__4(),
      2565: require__5(),
      2718: require__6(),
      2929: require__7(),
      2930: require__8(),
      3074: require__9(),
      3198: require__10(),
      3529: require__11(),
      3540: require__12(),
      3541: require__13(),
      3554: require__14(),
      3607: require__15(),
      3651: require__16(),
      3670: require__17(),
      3675: require__18(),
      3855: require__19(),
      3860: require__20(),
      4345: require__21(),
      4399: require__22(),
      4844: require__23(),
      4895: require__24(),
      5133: require__25()
    };
  }
});

// node_modules/@ethereumjs/common/dist/enums.js
var require_enums = __commonJS({
  "node_modules/@ethereumjs/common/dist/enums.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomChain = exports.ConsensusAlgorithm = exports.ConsensusType = exports.Hardfork = exports.Chain = void 0;
    var Chain;
    (function(Chain2) {
      Chain2[Chain2["Mainnet"] = 1] = "Mainnet";
      Chain2[Chain2["Ropsten"] = 3] = "Ropsten";
      Chain2[Chain2["Rinkeby"] = 4] = "Rinkeby";
      Chain2[Chain2["Goerli"] = 5] = "Goerli";
      Chain2[Chain2["Sepolia"] = 11155111] = "Sepolia";
    })(Chain = exports.Chain || (exports.Chain = {}));
    var Hardfork2;
    (function(Hardfork3) {
      Hardfork3["Chainstart"] = "chainstart";
      Hardfork3["Homestead"] = "homestead";
      Hardfork3["Dao"] = "dao";
      Hardfork3["TangerineWhistle"] = "tangerineWhistle";
      Hardfork3["SpuriousDragon"] = "spuriousDragon";
      Hardfork3["Byzantium"] = "byzantium";
      Hardfork3["Constantinople"] = "constantinople";
      Hardfork3["Petersburg"] = "petersburg";
      Hardfork3["Istanbul"] = "istanbul";
      Hardfork3["MuirGlacier"] = "muirGlacier";
      Hardfork3["Berlin"] = "berlin";
      Hardfork3["London"] = "london";
      Hardfork3["ArrowGlacier"] = "arrowGlacier";
      Hardfork3["GrayGlacier"] = "grayGlacier";
      Hardfork3["MergeForkIdTransition"] = "mergeForkIdTransition";
      Hardfork3["Merge"] = "merge";
      Hardfork3["Shanghai"] = "shanghai";
      Hardfork3["ShardingForkDev"] = "shardingFork";
    })(Hardfork2 = exports.Hardfork || (exports.Hardfork = {}));
    var ConsensusType;
    (function(ConsensusType2) {
      ConsensusType2["ProofOfStake"] = "pos";
      ConsensusType2["ProofOfWork"] = "pow";
      ConsensusType2["ProofOfAuthority"] = "poa";
    })(ConsensusType = exports.ConsensusType || (exports.ConsensusType = {}));
    var ConsensusAlgorithm;
    (function(ConsensusAlgorithm2) {
      ConsensusAlgorithm2["Ethash"] = "ethash";
      ConsensusAlgorithm2["Clique"] = "clique";
      ConsensusAlgorithm2["Casper"] = "casper";
    })(ConsensusAlgorithm = exports.ConsensusAlgorithm || (exports.ConsensusAlgorithm = {}));
    var CustomChain;
    (function(CustomChain2) {
      CustomChain2["PolygonMainnet"] = "polygon-mainnet";
      CustomChain2["PolygonMumbai"] = "polygon-mumbai";
      CustomChain2["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
      CustomChain2["ArbitrumOne"] = "arbitrum-one";
      CustomChain2["xDaiChain"] = "x-dai-chain";
      CustomChain2["OptimisticKovan"] = "optimistic-kovan";
      CustomChain2["OptimisticEthereum"] = "optimistic-ethereum";
    })(CustomChain = exports.CustomChain || (exports.CustomChain = {}));
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/chainstart.json
var require_chainstart = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/chainstart.json"(exports, module) {
    module.exports = {
      name: "chainstart",
      comment: "Start of the Ethereum main chain",
      url: "",
      status: "",
      gasConfig: {
        minGasLimit: {
          v: 5e3,
          d: "Minimum the gas limit may ever be"
        },
        gasLimitBoundDivisor: {
          v: 1024,
          d: "The bound divisor of the gas limit, used in update calculations"
        },
        maxRefundQuotient: {
          v: 2,
          d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
      },
      gasPrices: {
        base: {
          v: 2,
          d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
        },
        tierStep: {
          v: [0, 2, 3, 5, 8, 10, 20],
          d: "Once per operation, for a selection of them"
        },
        exp: {
          v: 10,
          d: "Base fee of the EXP opcode"
        },
        expByte: {
          v: 10,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        },
        sha3: {
          v: 30,
          d: "Base fee of the SHA3 opcode"
        },
        sha3Word: {
          v: 6,
          d: "Once per word of the SHA3 operation's data"
        },
        sload: {
          v: 50,
          d: "Base fee of the SLOAD opcode"
        },
        sstoreSet: {
          v: 2e4,
          d: "Once per SSTORE operation if the zeroness changes from zero"
        },
        sstoreReset: {
          v: 5e3,
          d: "Once per SSTORE operation if the zeroness does not change from zero"
        },
        sstoreRefund: {
          v: 15e3,
          d: "Once per SSTORE operation if the zeroness changes to zero"
        },
        jumpdest: {
          v: 1,
          d: "Base fee of the JUMPDEST opcode"
        },
        log: {
          v: 375,
          d: "Base fee of the LOG opcode"
        },
        logData: {
          v: 8,
          d: "Per byte in a LOG* operation's data"
        },
        logTopic: {
          v: 375,
          d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
        },
        create: {
          v: 32e3,
          d: "Base fee of the CREATE opcode"
        },
        call: {
          v: 40,
          d: "Base fee of the CALL opcode"
        },
        callStipend: {
          v: 2300,
          d: "Free gas given at beginning of call"
        },
        callValueTransfer: {
          v: 9e3,
          d: "Paid for CALL when the value transfor is non-zero"
        },
        callNewAccount: {
          v: 25e3,
          d: "Paid for CALL when the destination address didn't exist prior"
        },
        selfdestructRefund: {
          v: 24e3,
          d: "Refunded following a selfdestruct operation"
        },
        memory: {
          v: 3,
          d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
        },
        quadCoeffDiv: {
          v: 512,
          d: "Divisor for the quadratic particle of the memory cost equation"
        },
        createData: {
          v: 200,
          d: ""
        },
        tx: {
          v: 21e3,
          d: "Per transaction. NOTE: Not payable on data of calls between transactions"
        },
        txCreation: {
          v: 32e3,
          d: "The cost of creating a contract via tx"
        },
        txDataZero: {
          v: 4,
          d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
        },
        txDataNonZero: {
          v: 68,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        copy: {
          v: 3,
          d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
        },
        ecRecover: {
          v: 3e3,
          d: ""
        },
        sha256: {
          v: 60,
          d: ""
        },
        sha256Word: {
          v: 12,
          d: ""
        },
        ripemd160: {
          v: 600,
          d: ""
        },
        ripemd160Word: {
          v: 120,
          d: ""
        },
        identity: {
          v: 15,
          d: ""
        },
        identityWord: {
          v: 3,
          d: ""
        },
        stop: {
          v: 0,
          d: "Base fee of the STOP opcode"
        },
        add: {
          v: 3,
          d: "Base fee of the ADD opcode"
        },
        mul: {
          v: 5,
          d: "Base fee of the MUL opcode"
        },
        sub: {
          v: 3,
          d: "Base fee of the SUB opcode"
        },
        div: {
          v: 5,
          d: "Base fee of the DIV opcode"
        },
        sdiv: {
          v: 5,
          d: "Base fee of the SDIV opcode"
        },
        mod: {
          v: 5,
          d: "Base fee of the MOD opcode"
        },
        smod: {
          v: 5,
          d: "Base fee of the SMOD opcode"
        },
        addmod: {
          v: 8,
          d: "Base fee of the ADDMOD opcode"
        },
        mulmod: {
          v: 8,
          d: "Base fee of the MULMOD opcode"
        },
        signextend: {
          v: 5,
          d: "Base fee of the SIGNEXTEND opcode"
        },
        lt: {
          v: 3,
          d: "Base fee of the LT opcode"
        },
        gt: {
          v: 3,
          d: "Base fee of the GT opcode"
        },
        slt: {
          v: 3,
          d: "Base fee of the SLT opcode"
        },
        sgt: {
          v: 3,
          d: "Base fee of the SGT opcode"
        },
        eq: {
          v: 3,
          d: "Base fee of the EQ opcode"
        },
        iszero: {
          v: 3,
          d: "Base fee of the ISZERO opcode"
        },
        and: {
          v: 3,
          d: "Base fee of the AND opcode"
        },
        or: {
          v: 3,
          d: "Base fee of the OR opcode"
        },
        xor: {
          v: 3,
          d: "Base fee of the XOR opcode"
        },
        not: {
          v: 3,
          d: "Base fee of the NOT opcode"
        },
        byte: {
          v: 3,
          d: "Base fee of the BYTE opcode"
        },
        address: {
          v: 2,
          d: "Base fee of the ADDRESS opcode"
        },
        balance: {
          v: 20,
          d: "Base fee of the BALANCE opcode"
        },
        origin: {
          v: 2,
          d: "Base fee of the ORIGIN opcode"
        },
        caller: {
          v: 2,
          d: "Base fee of the CALLER opcode"
        },
        callvalue: {
          v: 2,
          d: "Base fee of the CALLVALUE opcode"
        },
        calldataload: {
          v: 3,
          d: "Base fee of the CALLDATALOAD opcode"
        },
        calldatasize: {
          v: 2,
          d: "Base fee of the CALLDATASIZE opcode"
        },
        calldatacopy: {
          v: 3,
          d: "Base fee of the CALLDATACOPY opcode"
        },
        codesize: {
          v: 2,
          d: "Base fee of the CODESIZE opcode"
        },
        codecopy: {
          v: 3,
          d: "Base fee of the CODECOPY opcode"
        },
        gasprice: {
          v: 2,
          d: "Base fee of the GASPRICE opcode"
        },
        extcodesize: {
          v: 20,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 20,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        blockhash: {
          v: 20,
          d: "Base fee of the BLOCKHASH opcode"
        },
        coinbase: {
          v: 2,
          d: "Base fee of the COINBASE opcode"
        },
        timestamp: {
          v: 2,
          d: "Base fee of the TIMESTAMP opcode"
        },
        number: {
          v: 2,
          d: "Base fee of the NUMBER opcode"
        },
        difficulty: {
          v: 2,
          d: "Base fee of the DIFFICULTY opcode"
        },
        gaslimit: {
          v: 2,
          d: "Base fee of the GASLIMIT opcode"
        },
        pop: {
          v: 2,
          d: "Base fee of the POP opcode"
        },
        mload: {
          v: 3,
          d: "Base fee of the MLOAD opcode"
        },
        mstore: {
          v: 3,
          d: "Base fee of the MSTORE opcode"
        },
        mstore8: {
          v: 3,
          d: "Base fee of the MSTORE8 opcode"
        },
        sstore: {
          v: 0,
          d: "Base fee of the SSTORE opcode"
        },
        jump: {
          v: 8,
          d: "Base fee of the JUMP opcode"
        },
        jumpi: {
          v: 10,
          d: "Base fee of the JUMPI opcode"
        },
        pc: {
          v: 2,
          d: "Base fee of the PC opcode"
        },
        msize: {
          v: 2,
          d: "Base fee of the MSIZE opcode"
        },
        gas: {
          v: 2,
          d: "Base fee of the GAS opcode"
        },
        push: {
          v: 3,
          d: "Base fee of the PUSH opcode"
        },
        dup: {
          v: 3,
          d: "Base fee of the DUP opcode"
        },
        swap: {
          v: 3,
          d: "Base fee of the SWAP opcode"
        },
        callcode: {
          v: 40,
          d: "Base fee of the CALLCODE opcode"
        },
        return: {
          v: 0,
          d: "Base fee of the RETURN opcode"
        },
        invalid: {
          v: 0,
          d: "Base fee of the INVALID opcode"
        },
        selfdestruct: {
          v: 0,
          d: "Base fee of the SELFDESTRUCT opcode"
        }
      },
      vm: {
        stackLimit: {
          v: 1024,
          d: "Maximum size of VM stack allowed"
        },
        callCreateDepth: {
          v: 1024,
          d: "Maximum depth of call/create stack"
        },
        maxExtraDataSize: {
          v: 32,
          d: "Maximum size extra data may be after Genesis"
        }
      },
      pow: {
        minimumDifficulty: {
          v: 131072,
          d: "The minimum that the difficulty may ever be"
        },
        difficultyBoundDivisor: {
          v: 2048,
          d: "The bound divisor of the difficulty, used in the update calculations"
        },
        durationLimit: {
          v: 13,
          d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
        },
        epochDuration: {
          v: 3e4,
          d: "Duration between proof-of-work epochs"
        },
        timebombPeriod: {
          v: 1e5,
          d: "Exponential difficulty timebomb period"
        },
        minerReward: {
          v: "5000000000000000000",
          d: "the amount a miner get rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 0,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/homestead.json
var require_homestead = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/homestead.json"(exports, module) {
    module.exports = {
      name: "homestead",
      comment: "Homestead hardfork with protocol and network changes",
      url: "https://eips.ethereum.org/EIPS/eip-606",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        delegatecall: {
          v: 40,
          d: "Base fee of the DELEGATECALL opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/dao.json
var require_dao = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/dao.json"(exports, module) {
    module.exports = {
      name: "dao",
      comment: "DAO rescue hardfork",
      url: "https://eips.ethereum.org/EIPS/eip-779",
      status: "Final",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/tangerineWhistle.json
var require_tangerineWhistle = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/tangerineWhistle.json"(exports, module) {
    module.exports = {
      name: "tangerineWhistle",
      comment: "Hardfork with gas cost changes for IO-heavy operations",
      url: "https://eips.ethereum.org/EIPS/eip-608",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        sload: {
          v: 200,
          d: "Once per SLOAD operation"
        },
        call: {
          v: 700,
          d: "Once per CALL operation & message call transaction"
        },
        extcodesize: {
          v: 700,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 700,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        balance: {
          v: 400,
          d: "Base fee of the BALANCE opcode"
        },
        delegatecall: {
          v: 700,
          d: "Base fee of the DELEGATECALL opcode"
        },
        callcode: {
          v: 700,
          d: "Base fee of the CALLCODE opcode"
        },
        selfdestruct: {
          v: 5e3,
          d: "Base fee of the SELFDESTRUCT opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/spuriousDragon.json
var require_spuriousDragon = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/spuriousDragon.json"(exports, module) {
    module.exports = {
      name: "spuriousDragon",
      comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
      url: "https://eips.ethereum.org/EIPS/eip-607",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        expByte: {
          v: 50,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        }
      },
      vm: {
        maxCodeSize: {
          v: 24576,
          d: "Maximum length of contract code"
        }
      },
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/byzantium.json
var require_byzantium = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/byzantium.json"(exports, module) {
    module.exports = {
      name: "byzantium",
      comment: "Hardfork with new precompiles, instructions and other protocol changes",
      url: "https://eips.ethereum.org/EIPS/eip-609",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 20,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        },
        ecAdd: {
          v: 500,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 4e4,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 1e5,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 8e4,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        revert: {
          v: 0,
          d: "Base fee of the REVERT opcode"
        },
        staticcall: {
          v: 700,
          d: "Base fee of the STATICCALL opcode"
        },
        returndatasize: {
          v: 2,
          d: "Base fee of the RETURNDATASIZE opcode"
        },
        returndatacopy: {
          v: 3,
          d: "Base fee of the RETURNDATACOPY opcode"
        }
      },
      vm: {},
      pow: {
        minerReward: {
          v: "3000000000000000000",
          d: "the amount a miner get rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 3e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/constantinople.json
var require_constantinople = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/constantinople.json"(exports, module) {
    module.exports = {
      name: "constantinople",
      comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
      url: "https://eips.ethereum.org/EIPS/eip-1013",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: 200,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        netSstoreInitGas: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero"
        },
        netSstoreCleanGas: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero"
        },
        netSstoreDirtyGas: {
          v: 200,
          d: "Once per SSTORE operation from dirty"
        },
        netSstoreClearRefund: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        netSstoreResetRefund: {
          v: 4800,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        netSstoreResetClearRefund: {
          v: 19800,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        shl: {
          v: 3,
          d: "Base fee of the SHL opcode"
        },
        shr: {
          v: 3,
          d: "Base fee of the SHR opcode"
        },
        sar: {
          v: 3,
          d: "Base fee of the SAR opcode"
        },
        extcodehash: {
          v: 400,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        create2: {
          v: 32e3,
          d: "Base fee of the CREATE2 opcode"
        }
      },
      vm: {},
      pow: {
        minerReward: {
          v: "2000000000000000000",
          d: "The amount a miner gets rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 5e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/petersburg.json
var require_petersburg = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/petersburg.json"(exports, module) {
    module.exports = {
      name: "petersburg",
      comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
      url: "https://eips.ethereum.org/EIPS/eip-1716",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreInitGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreCleanGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreDirtyGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/istanbul.json
var require_istanbul = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/istanbul.json"(exports, module) {
    module.exports = {
      name: "istanbul",
      comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
      url: "https://eips.ethereum.org/EIPS/eip-1679",
      status: "Final",
      gasConfig: {},
      gasPrices: {
        blake2Round: {
          v: 1,
          d: "Gas cost per round for the Blake2 F precompile"
        },
        ecAdd: {
          v: 150,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 6e3,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 45e3,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 34e3,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        txDataNonZero: {
          v: 16,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        sstoreSentryGasEIP2200: {
          v: 2300,
          d: "Minimum gas required to be present for an SSTORE call, not consumed"
        },
        sstoreNoopGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitGasEIP2200: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero to non-zero"
        },
        sstoreInitRefundEIP2200: {
          v: 19200,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanGasEIP2200: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreCleanRefundEIP2200: {
          v: 4200,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        sstoreClearRefundEIP2200: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        balance: {
          v: 700,
          d: "Base fee of the BALANCE opcode"
        },
        extcodehash: {
          v: 700,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        chainid: {
          v: 2,
          d: "Base fee of the CHAINID opcode"
        },
        selfbalance: {
          v: 5,
          d: "Base fee of the SELFBALANCE opcode"
        },
        sload: {
          v: 800,
          d: "Base fee of the SLOAD opcode"
        }
      },
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/muirGlacier.json
var require_muirGlacier = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/muirGlacier.json"(exports, module) {
    module.exports = {
      name: "muirGlacier",
      comment: "HF to delay the difficulty bomb",
      url: "https://eips.ethereum.org/EIPS/eip-2384",
      status: "Final",
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {
        difficultyBombDelay: {
          v: 9e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/berlin.json
var require_berlin = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/berlin.json"(exports, module) {
    module.exports = {
      name: "berlin",
      comment: "HF targeted for July 2020 following the Muir Glacier HF",
      url: "https://eips.ethereum.org/EIPS/eip-2070",
      status: "Final",
      eips: [2565, 2929, 2718, 2930]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/london.json
var require_london = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/london.json"(exports, module) {
    module.exports = {
      name: "london",
      comment: "HF targeted for July 2021 following the Berlin fork",
      url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
      status: "Final",
      eips: [1559, 3198, 3529, 3541]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/shanghai.json
var require_shanghai = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/shanghai.json"(exports, module) {
    module.exports = {
      name: "shanghai",
      comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
      status: "Final",
      eips: [3651, 3855, 3860, 4895]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/arrowGlacier.json
var require_arrowGlacier = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/arrowGlacier.json"(exports, module) {
    module.exports = {
      name: "arrowGlacier",
      comment: "HF to delay the difficulty bomb",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
      status: "Final",
      eips: [4345],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/grayGlacier.json
var require_grayGlacier = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/grayGlacier.json"(exports, module) {
    module.exports = {
      name: "grayGlacier",
      comment: "Delaying the difficulty bomb to Mid September 2022",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
      status: "Draft",
      eips: [5133],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/mergeForkIdTransition.json
var require_mergeForkIdTransition = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/mergeForkIdTransition.json"(exports, module) {
    module.exports = {
      name: "mergeForkIdTransition",
      comment: "Pre-merge hardfork to fork off non-upgraded clients",
      url: "https://eips.ethereum.org/EIPS/eip-3675",
      status: "Draft",
      eips: []
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/merge.json
var require_merge = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/merge.json"(exports, module) {
    module.exports = {
      name: "merge",
      comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
      status: "Final",
      consensus: {
        type: "pos",
        algorithm: "casper",
        casper: {}
      },
      eips: [3675, 4399]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/sharding.json
var require_sharding = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/sharding.json"(exports, module) {
    module.exports = {
      name: "shardingFork",
      comment: "Internal hardfork to test proto-danksharding (do not use in production)",
      url: "https://eips.ethereum.org/EIPS/eip-4844",
      status: "Experimental",
      eips: [4844]
    };
  }
});

// node_modules/@ethereumjs/common/dist/hardforks/index.js
var require_hardforks = __commonJS({
  "node_modules/@ethereumjs/common/dist/hardforks/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hardforks = void 0;
    exports.hardforks = {
      chainstart: require_chainstart(),
      homestead: require_homestead(),
      dao: require_dao(),
      tangerineWhistle: require_tangerineWhistle(),
      spuriousDragon: require_spuriousDragon(),
      byzantium: require_byzantium(),
      constantinople: require_constantinople(),
      petersburg: require_petersburg(),
      istanbul: require_istanbul(),
      muirGlacier: require_muirGlacier(),
      berlin: require_berlin(),
      london: require_london(),
      shanghai: require_shanghai(),
      arrowGlacier: require_arrowGlacier(),
      grayGlacier: require_grayGlacier(),
      mergeForkIdTransition: require_mergeForkIdTransition(),
      merge: require_merge(),
      shardingFork: require_sharding()
    };
  }
});

// node_modules/@ethereumjs/common/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/@ethereumjs/common/dist/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGethGenesis = void 0;
    var util_1 = require_dist3();
    var enums_1 = require_enums();
    function formatNonce(nonce) {
      if (!nonce || nonce === "0x0") {
        return "0x0000000000000000";
      }
      if ((0, util_1.isHexPrefixed)(nonce)) {
        return "0x" + (0, util_1.stripHexPrefix)(nonce).padStart(16, "0");
      }
      return "0x" + nonce.padStart(16, "0");
    }
    function parseGethParams(json, mergeForkIdPostMerge = true) {
      const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas } = json;
      let { extraData, timestamp, nonce } = json;
      const genesisTimestamp = Number(timestamp);
      const { chainId } = config;
      if (extraData === "") {
        extraData = "0x";
      }
      if (!(0, util_1.isHexPrefixed)(timestamp)) {
        timestamp = (0, util_1.intToHex)(parseInt(timestamp));
      }
      if (nonce.length !== 18) {
        nonce = formatNonce(nonce);
      }
      if (config.eip155Block !== config.eip158Block) {
        throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
      }
      const params = {
        name,
        chainId,
        networkId: chainId,
        genesis: {
          timestamp,
          gasLimit: parseInt(gasLimit),
          difficulty: parseInt(difficulty),
          nonce,
          extraData,
          mixHash,
          coinbase,
          baseFeePerGas
        },
        hardfork: void 0,
        hardforks: [],
        bootstrapNodes: [],
        consensus: config.clique !== void 0 ? {
          type: "poa",
          algorithm: "clique",
          clique: {
            // The recent geth genesis seems to be using blockperiodseconds
            // and epochlength for clique specification
            // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ
            period: config.clique.period ?? config.clique.blockperiodseconds,
            epoch: config.clique.epoch ?? config.clique.epochlength
          }
        } : {
          type: "pow",
          algorithm: "ethash",
          ethash: {}
        }
      };
      const forkMap = {
        [enums_1.Hardfork.Homestead]: { name: "homesteadBlock" },
        [enums_1.Hardfork.Dao]: { name: "daoForkBlock" },
        [enums_1.Hardfork.TangerineWhistle]: { name: "eip150Block" },
        [enums_1.Hardfork.SpuriousDragon]: { name: "eip155Block" },
        [enums_1.Hardfork.Byzantium]: { name: "byzantiumBlock" },
        [enums_1.Hardfork.Constantinople]: { name: "constantinopleBlock" },
        [enums_1.Hardfork.Petersburg]: { name: "petersburgBlock" },
        [enums_1.Hardfork.Istanbul]: { name: "istanbulBlock" },
        [enums_1.Hardfork.MuirGlacier]: { name: "muirGlacierBlock" },
        [enums_1.Hardfork.Berlin]: { name: "berlinBlock" },
        [enums_1.Hardfork.London]: { name: "londonBlock" },
        [enums_1.Hardfork.MergeForkIdTransition]: { name: "mergeForkBlock", postMerge: mergeForkIdPostMerge },
        [enums_1.Hardfork.Shanghai]: { name: "shanghaiTime", postMerge: true, isTimestamp: true },
        [enums_1.Hardfork.ShardingForkDev]: { name: "shardingForkTime", postMerge: true, isTimestamp: true }
      };
      const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
        acc[forkMap[elem].name] = elem;
        return acc;
      }, {});
      const configHardforkNames = Object.keys(config).filter((key) => forkMapRev[key] !== void 0 && config[key] !== void 0 && config[key] !== null);
      params.hardforks = configHardforkNames.map((nameBlock) => ({
        name: forkMapRev[nameBlock],
        block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== "number" ? null : config[nameBlock],
        timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === "number" ? config[nameBlock] : void 0
      })).filter((fork) => fork.block !== null || fork.timestamp !== void 0);
      params.hardforks.sort(function(a, b) {
        return (a.block ?? Infinity) - (b.block ?? Infinity);
      });
      params.hardforks.sort(function(a, b) {
        return (a.timestamp ?? genesisTimestamp) - (b.timestamp ?? genesisTimestamp);
      });
      if (config.terminalTotalDifficulty !== void 0) {
        const mergeConfig = {
          name: enums_1.Hardfork.Merge,
          ttd: config.terminalTotalDifficulty,
          block: null
        };
        const postMergeIndex = params.hardforks.findIndex((hf) => {
          var _a;
          return ((_a = forkMap[hf.name]) == null ? void 0 : _a.postMerge) === true;
        });
        if (postMergeIndex !== -1) {
          params.hardforks.splice(postMergeIndex, 0, mergeConfig);
        } else {
          params.hardforks.push(mergeConfig);
        }
      }
      const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : void 0;
      params.hardfork = latestHardfork == null ? void 0 : latestHardfork.name;
      params.hardforks.unshift({ name: enums_1.Hardfork.Chainstart, block: 0 });
      return params;
    }
    function parseGethGenesis(json, name, mergeForkIdPostMerge) {
      try {
        if (["config", "difficulty", "gasLimit", "alloc"].some((field) => !(field in json))) {
          throw new Error("Invalid format, expected geth genesis fields missing");
        }
        if (name !== void 0) {
          json.name = name;
        }
        return parseGethParams(json, mergeForkIdPostMerge);
      } catch (e) {
        throw new Error(`Error parsing parameters file: ${e.message}`);
      }
    }
    exports.parseGethGenesis = parseGethGenesis;
  }
});

// node_modules/@ethereumjs/common/dist/common.js
var require_common = __commonJS({
  "node_modules/@ethereumjs/common/dist/common.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Common = void 0;
    var util_1 = require_dist3();
    var crc_32_1 = require_crc32();
    var events_1 = require_events();
    var goerli = require_goerli();
    var mainnet = require_mainnet();
    var rinkeby = require_rinkeby();
    var ropsten = require_ropsten();
    var sepolia = require_sepolia();
    var eips_1 = require_eips();
    var enums_1 = require_enums();
    var hardforks_1 = require_hardforks();
    var utils_1 = require_utils2();
    var Common2 = class extends events_1.EventEmitter {
      constructor(opts) {
        super();
        this._eips = [];
        this._customChains = opts.customChains ?? [];
        this._chainParams = this.setChain(opts.chain);
        this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? enums_1.Hardfork.Merge;
        this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
          hf.name,
          hardforks_1.hardforks[hf.name]
        ]);
        this._hardfork = this.DEFAULT_HARDFORK;
        if (opts.hardfork !== void 0) {
          this.setHardfork(opts.hardfork);
        }
        if (opts.eips) {
          this.setEIPs(opts.eips);
        }
      }
      /**
       * Creates a {@link Common} object for a custom chain, based on a standard one.
       *
       * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden
       * in a provided {@link chainParamsOrName} dictionary. Some usage example:
       *
       * ```javascript
       * Common.custom({chainId: 123})
       * ```
       *
       * There are also selected supported custom chains which can be initialized by using one of the
       * {@link CustomChains} for {@link chainParamsOrName}, e.g.:
       *
       * ```javascript
       * Common.custom(CustomChains.MaticMumbai)
       * ```
       *
       * Note that these supported custom chains only provide some base parameters (usually the chain and
       * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with
       * the `@ethereumjs/tx` library to a Layer-2 chain).
       *
       * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain
       * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others
       */
      static custom(chainParamsOrName, opts = {}) {
        const baseChain = opts.baseChain ?? "mainnet";
        const standardChainParams = { ...Common2._getChainParams(baseChain) };
        standardChainParams["name"] = "custom-chain";
        if (typeof chainParamsOrName !== "string") {
          return new Common2({
            chain: {
              ...standardChainParams,
              ...chainParamsOrName
            },
            ...opts
          });
        } else {
          if (chainParamsOrName === enums_1.CustomChain.PolygonMainnet) {
            return Common2.custom({
              name: enums_1.CustomChain.PolygonMainnet,
              chainId: 137,
              networkId: 137
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.PolygonMumbai) {
            return Common2.custom({
              name: enums_1.CustomChain.PolygonMumbai,
              chainId: 80001,
              networkId: 80001
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.ArbitrumRinkebyTestnet) {
            return Common2.custom({
              name: enums_1.CustomChain.ArbitrumRinkebyTestnet,
              chainId: 421611,
              networkId: 421611
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.ArbitrumOne) {
            return Common2.custom({
              name: enums_1.CustomChain.ArbitrumOne,
              chainId: 42161,
              networkId: 42161
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.xDaiChain) {
            return Common2.custom({
              name: enums_1.CustomChain.xDaiChain,
              chainId: 100,
              networkId: 100
            }, opts);
          }
          if (chainParamsOrName === enums_1.CustomChain.OptimisticKovan) {
            return Common2.custom(
              {
                name: enums_1.CustomChain.OptimisticKovan,
                chainId: 69,
                networkId: 69
              },
              // Optimism has not implemented the London hardfork yet (targeting Q1.22)
              { hardfork: enums_1.Hardfork.Berlin, ...opts }
            );
          }
          if (chainParamsOrName === enums_1.CustomChain.OptimisticEthereum) {
            return Common2.custom(
              {
                name: enums_1.CustomChain.OptimisticEthereum,
                chainId: 10,
                networkId: 10
              },
              // Optimism has not implemented the London hardfork yet (targeting Q1.22)
              { hardfork: enums_1.Hardfork.Berlin, ...opts }
            );
          }
          throw new Error(`Custom chain ${chainParamsOrName} not supported`);
        }
      }
      /**
       * Static method to load and set common from a geth genesis json
       * @param genesisJson json of geth configuration
       * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance
       * @returns Common
       */
      static fromGethGenesis(genesisJson, { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge }) {
        const genesisParams = (0, utils_1.parseGethGenesis)(genesisJson, chain, mergeForkIdPostMerge);
        const common = new Common2({
          chain: genesisParams.name ?? "custom",
          customChains: [genesisParams],
          eips,
          hardfork: hardfork ?? genesisParams.hardfork
        });
        if (genesisHash !== void 0) {
          common.setForkHashes(genesisHash);
        }
        return common;
      }
      /**
       * Static method to determine if a {@link chainId} is supported as a standard chain
       * @param chainId bigint id (`1`) of a standard chain
       * @returns boolean
       */
      static isSupportedChainId(chainId) {
        const initializedChains = this._getInitializedChains();
        return Boolean(initializedChains["names"][chainId.toString()]);
      }
      static _getChainParams(chain, customChains) {
        const initializedChains = this._getInitializedChains(customChains);
        if (typeof chain === "number" || typeof chain === "bigint") {
          chain = chain.toString();
          if (initializedChains["names"][chain]) {
            const name = initializedChains["names"][chain];
            return initializedChains[name];
          }
          throw new Error(`Chain with ID ${chain} not supported`);
        }
        if (initializedChains[chain] !== void 0) {
          return initializedChains[chain];
        }
        throw new Error(`Chain with name ${chain} not supported`);
      }
      /**
       * Sets the chain
       * @param chain String ('mainnet') or Number (1) chain representation.
       *              Or, a Dictionary of chain parameters for a private network.
       * @returns The dictionary with parameters set as chain
       */
      setChain(chain) {
        if (typeof chain === "number" || typeof chain === "bigint" || typeof chain === "string") {
          this._chainParams = Common2._getChainParams(chain, this._customChains);
        } else if (typeof chain === "object") {
          if (this._customChains.length > 0) {
            throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
          }
          const required = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
          for (const param of required) {
            if (!(param in chain)) {
              throw new Error(`Missing required chain parameter: ${param}`);
            }
          }
          this._chainParams = chain;
        } else {
          throw new Error("Wrong input format");
        }
        for (const hf of this.hardforks()) {
          if (hf.block === void 0) {
            throw new Error(`Hardfork cannot have undefined block number`);
          }
        }
        return this._chainParams;
      }
      /**
       * Sets the hardfork to get params for
       * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum
       */
      setHardfork(hardfork) {
        let existing = false;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if (hfChanges[0] === hardfork) {
            if (this._hardfork !== hardfork) {
              this._hardfork = hardfork;
              this.emit("hardforkChanged", hardfork);
            }
            existing = true;
          }
        }
        if (!existing) {
          throw new Error(`Hardfork with name ${hardfork} not supported`);
        }
      }
      /**
       * Returns the hardfork based on the block number or an optional
       * total difficulty (Merge HF) provided.
       *
       * An optional TD takes precedence in case the corresponding HF block
       * is set to `null` or otherwise needs to match (if not an error
       * will be thrown).
       *
       * @param blockNumber
       * @param td : total difficulty of the parent block (for block hf) OR of the chain latest (for chain hf)
       * @param timestamp: timestamp in seconds at which block was/is to be minted
       * @returns The name of the HF
       */
      getHardforkByBlockNumber(blockNumber, td, timestamp) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        td = (0, util_1.toType)(td, util_1.TypeOutput.BigInt);
        timestamp = (0, util_1.toType)(timestamp, util_1.TypeOutput.Number);
        const hfs = this.hardforks().filter((hf) => hf.block !== null || hf.ttd !== null && hf.ttd !== void 0 || hf.timestamp !== void 0);
        const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
        const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
        if (doubleTTDHF >= 0) {
          throw Error(`More than one merge hardforks found with ttd specified`);
        }
        let hfIndex = hfs.findIndex((hf) => hf.block !== null && hf.block > blockNumber || timestamp !== void 0 && Number(hf.timestamp) > timestamp);
        if (hfIndex === -1) {
          hfIndex = hfs.length;
        } else if (hfIndex === 0) {
          throw Error("Must have at least one hardfork at block 0");
        }
        if (timestamp === void 0) {
          const stepBack = hfs.slice(0, hfIndex).reverse().findIndex((hf) => hf.block !== null || hf.ttd !== void 0);
          hfIndex = hfIndex - stepBack;
        }
        hfIndex = hfIndex - 1;
        if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === void 0) {
          if (td === void 0 || td === null || BigInt(hfs[hfIndex].ttd) > td) {
            hfIndex -= 1;
          }
        } else {
          if (mergeIndex >= 0 && td !== void 0 && td !== null) {
            if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
              throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
            } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {
              throw Error("HF determined by block number is lower than the minimum total difficulty HF");
            }
          }
        }
        const hfStartIndex = hfIndex;
        for (; hfIndex < hfs.length - 1; hfIndex++) {
          if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
            break;
          }
        }
        if (timestamp) {
          const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => Math.max(Number(hf.timestamp ?? "0"), acc), 0);
          if (minTimeStamp > timestamp) {
            throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
          }
          const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), timestamp);
          if (maxTimeStamp < timestamp) {
            throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
          }
        }
        const hardfork = hfs[hfIndex];
        return hardfork.name;
      }
      /**
       * Sets a new hardfork based on the block number or an optional
       * total difficulty (Merge HF) provided.
       *
       * An optional TD takes precedence in case the corresponding HF block
       * is set to `null` or otherwise needs to match (if not an error
       * will be thrown).
       *
       * @param blockNumber
       * @param td
       * @param timestamp
       * @returns The name of the HF set
       */
      setHardforkByBlockNumber(blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        this.setHardfork(hardfork);
        return hardfork;
      }
      /**
       * Internal helper function, returns the params for the given hardfork for the chain set
       * @param hardfork Hardfork name
       * @returns Dictionary with hardfork params or null if hardfork not on chain
       */
      _getHardfork(hardfork) {
        const hfs = this.hardforks();
        for (const hf of hfs) {
          if (hf["name"] === hardfork)
            return hf;
        }
        return null;
      }
      /**
       * Sets the active EIPs
       * @param eips
       */
      setEIPs(eips = []) {
        for (const eip of eips) {
          if (!(eip in eips_1.EIPs)) {
            throw new Error(`${eip} not supported`);
          }
          const minHF = this.gteHardfork(eips_1.EIPs[eip]["minimumHardfork"]);
          if (!minHF) {
            throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
          }
          if (eips_1.EIPs[eip].requiredEIPs !== void 0) {
            for (const elem of eips_1.EIPs[eip].requiredEIPs) {
              if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {
                throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
              }
            }
          }
        }
        this._eips = eips;
      }
      /**
       * Returns a parameter for the current chain setup
       *
       * If the parameter is present in an EIP, the EIP always takes precedence.
       * Otherwise the parameter if taken from the latest applied HF with
       * a change on the respective parameter.
       *
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @returns The value requested or `BigInt(0)` if not found
       */
      param(topic, name) {
        let value;
        for (const eip of this._eips) {
          value = this.paramByEIP(topic, name, eip);
          if (value !== void 0)
            return value;
        }
        return this.paramByHardfork(topic, name, this._hardfork);
      }
      /**
       * Returns the parameter corresponding to a hardfork
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @param hardfork Hardfork name
       * @returns The value requested or `BigInt(0)` if not found
       */
      paramByHardfork(topic, name, hardfork) {
        let value = null;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("eips" in hfChanges[1]) {
            const hfEIPs = hfChanges[1]["eips"];
            for (const eip of hfEIPs) {
              const valueEIP = this.paramByEIP(topic, name, eip);
              value = typeof valueEIP === "bigint" ? valueEIP : value;
            }
          } else {
            if (hfChanges[1][topic] === void 0) {
              throw new Error(`Topic ${topic} not defined`);
            }
            if (hfChanges[1][topic][name] !== void 0) {
              value = hfChanges[1][topic][name].v;
            }
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return BigInt(value ?? 0);
      }
      /**
       * Returns a parameter corresponding to an EIP
       * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
       * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
       * @param eip Number of the EIP
       * @returns The value requested or `undefined` if not found
       */
      paramByEIP(topic, name, eip) {
        if (!(eip in eips_1.EIPs)) {
          throw new Error(`${eip} not supported`);
        }
        const eipParams = eips_1.EIPs[eip];
        if (!(topic in eipParams)) {
          throw new Error(`Topic ${topic} not defined`);
        }
        if (eipParams[topic][name] === void 0) {
          return void 0;
        }
        const value = eipParams[topic][name].v;
        return BigInt(value);
      }
      /**
       * Returns a parameter for the hardfork active on block number or
       * optional provided total difficulty (Merge HF)
       * @param topic Parameter topic
       * @param name Parameter name
       * @param blockNumber Block number
       * @param td Total difficulty
       *    * @returns The value requested or `BigInt(0)` if not found
       */
      paramByBlock(topic, name, blockNumber, td, timestamp) {
        const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
        return this.paramByHardfork(topic, name, hardfork);
      }
      /**
       * Checks if an EIP is activated by either being included in the EIPs
       * manually passed in with the {@link CommonOpts.eips} or in a
       * hardfork currently being active
       *
       * Note: this method only works for EIPs being supported
       * by the {@link CommonOpts.eips} constructor option
       * @param eip
       */
      isActivatedEIP(eip) {
        if (this.eips().includes(eip)) {
          return true;
        }
        for (const hfChanges of this.HARDFORK_CHANGES) {
          const hf = hfChanges[1];
          if (this.gteHardfork(hf["name"]) && "eips" in hf) {
            if (hf["eips"].includes(eip)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Checks if set or provided hardfork is active on block number
       * @param hardfork Hardfork name or null (for HF set)
       * @param blockNumber
       * @returns True if HF is active on block number
       */
      hardforkIsActiveOnBlock(hardfork, blockNumber) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const hfBlock = this.hardforkBlock(hardfork);
        if (typeof hfBlock === "bigint" && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {
          return true;
        }
        return false;
      }
      /**
       * Alias to hardforkIsActiveOnBlock when hardfork is set
       * @param blockNumber
       * @returns True if HF is active on block number
       */
      activeOnBlock(blockNumber) {
        return this.hardforkIsActiveOnBlock(null, blockNumber);
      }
      /**
       * Sequence based check if given or set HF1 is greater than or equal HF2
       * @param hardfork1 Hardfork name or null (if set)
       * @param hardfork2 Hardfork name
       * @param opts Hardfork options
       * @returns True if HF1 gte HF2
       */
      hardforkGteHardfork(hardfork1, hardfork2) {
        hardfork1 = hardfork1 ?? this._hardfork;
        const hardforks = this.hardforks();
        let posHf1 = -1, posHf2 = -1;
        let index = 0;
        for (const hf of hardforks) {
          if (hf["name"] === hardfork1)
            posHf1 = index;
          if (hf["name"] === hardfork2)
            posHf2 = index;
          index += 1;
        }
        return posHf1 >= posHf2 && posHf2 !== -1;
      }
      /**
       * Alias to hardforkGteHardfork when hardfork is set
       * @param hardfork Hardfork name
       * @returns True if hardfork set is greater than hardfork provided
       */
      gteHardfork(hardfork) {
        return this.hardforkGteHardfork(null, hardfork);
      }
      /**
       * Returns the hardfork change block for hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Block number or null if unscheduled
       */
      hardforkBlock(hardfork) {
        var _a;
        hardfork = hardfork ?? this._hardfork;
        const block = (_a = this._getHardfork(hardfork)) == null ? void 0 : _a["block"];
        if (block === void 0 || block === null) {
          return null;
        }
        return BigInt(block);
      }
      hardforkTimestamp(hardfork) {
        var _a;
        hardfork = hardfork ?? this._hardfork;
        const timestamp = (_a = this._getHardfork(hardfork)) == null ? void 0 : _a["timestamp"];
        if (timestamp === void 0 || timestamp === null) {
          return null;
        }
        return BigInt(timestamp);
      }
      /**
       * Returns the hardfork change block for eip
       * @param eip EIP number
       * @returns Block number or null if unscheduled
       */
      eipBlock(eip) {
        for (const hfChanges of this.HARDFORK_CHANGES) {
          const hf = hfChanges[1];
          if ("eips" in hf) {
            if (hf["eips"].includes(eip)) {
              return this.hardforkBlock(hfChanges[0]);
            }
          }
        }
        return null;
      }
      /**
       * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Total difficulty or null if no set
       */
      hardforkTTD(hardfork) {
        var _a;
        hardfork = hardfork ?? this._hardfork;
        const ttd = (_a = this._getHardfork(hardfork)) == null ? void 0 : _a["ttd"];
        if (ttd === void 0 || ttd === null) {
          return null;
        }
        return BigInt(ttd);
      }
      /**
       * True if block number provided is the hardfork (given or set) change block
       * @param blockNumber Number of the block to check
       * @param hardfork Hardfork name, optional if HF set
       * @returns True if blockNumber is HF block
       * @deprecated
       */
      isHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const block = this.hardforkBlock(hardfork);
        return typeof block === "bigint" && block !== BigInt(0) ? block === blockNumber : false;
      }
      /**
       * Returns the change block for the next hardfork after the hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Block timestamp, number or null if not available
       */
      nextHardforkBlockOrTimestamp(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        const hfs = this.hardforks();
        let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
        if (hardfork === enums_1.Hardfork.Merge) {
          hfIndex -= 1;
        }
        if (hfIndex < 0) {
          return null;
        }
        let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;
        currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== void 0 ? Number(currHfTimeOrBlock) : null;
        const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
          let hfTimeOrBlock = hf.timestamp ?? hf.block;
          hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 ? Number(hfTimeOrBlock) : null;
          return hf.name !== enums_1.Hardfork.Merge && hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 && hfTimeOrBlock !== currHfTimeOrBlock;
        });
        if (nextHf === void 0) {
          return null;
        }
        const nextHfBlock = nextHf.timestamp ?? nextHf.block;
        if (nextHfBlock === null || nextHfBlock === void 0) {
          return null;
        }
        return BigInt(nextHfBlock);
      }
      /**
       * Returns the change block for the next hardfork after the hardfork provided or set
       * @param hardfork Hardfork name, optional if HF set
       * @returns Block number or null if not available
       * @deprecated
       */
      nextHardforkBlock(hardfork) {
        hardfork = hardfork ?? this._hardfork;
        let hfBlock = this.hardforkBlock(hardfork);
        if (hfBlock === null && hardfork === enums_1.Hardfork.Merge) {
          const hfs = this.hardforks();
          const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
          if (mergeIndex < 0) {
            throw Error(`Merge hardfork should have been found`);
          }
          hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);
        }
        if (hfBlock === null) {
          return null;
        }
        const nextHfBlock = this.hardforks().reduce((acc, hf) => {
          const block = BigInt(hf.block === null || hf.ttd !== void 0 && hf.ttd !== null ? 0 : hf.block);
          return block > hfBlock && acc === null ? block : acc;
        }, null);
        return nextHfBlock;
      }
      /**
       * True if block number provided is the hardfork change block following the hardfork given or set
       * @param blockNumber Number of the block to check
       * @param hardfork Hardfork name, optional if HF set
       * @returns True if blockNumber is HF block
       * @deprecated
       */
      isNextHardforkBlock(blockNumber, hardfork) {
        blockNumber = (0, util_1.toType)(blockNumber, util_1.TypeOutput.BigInt);
        hardfork = hardfork ?? this._hardfork;
        const nextHardforkBlock = this.nextHardforkBlock(hardfork);
        return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
      }
      /**
       * Internal helper function to calculate a fork hash
       * @param hardfork Hardfork name
       * @param genesisHash Genesis block hash of the chain
       * @returns Fork hash as hex string
       */
      _calcForkHash(hardfork, genesisHash) {
        let hfBuffer = Buffer.alloc(0);
        let prevBlockOrTime = 0;
        for (const hf of this.hardforks()) {
          const { block, timestamp, name } = hf;
          let blockOrTime = timestamp ?? block;
          blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
          if (typeof blockOrTime === "number" && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== enums_1.Hardfork.Merge) {
            const hfBlockBuffer = Buffer.from(blockOrTime.toString(16).padStart(16, "0"), "hex");
            hfBuffer = Buffer.concat([hfBuffer, hfBlockBuffer]);
            prevBlockOrTime = blockOrTime;
          }
          if (hf.name === hardfork)
            break;
        }
        const inputBuffer = Buffer.concat([genesisHash, hfBuffer]);
        const forkhash = (0, util_1.intToBuffer)((0, crc_32_1.buf)(inputBuffer) >>> 0).toString("hex");
        return `0x${forkhash}`;
      }
      /**
       * Returns an eth/64 compliant fork hash (EIP-2124)
       * @param hardfork Hardfork name, optional if HF set
       * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated
       */
      forkHash(hardfork, genesisHash) {
        hardfork = hardfork ?? this._hardfork;
        const data = this._getHardfork(hardfork);
        if (data === null || (data == null ? void 0 : data.block) === null && (data == null ? void 0 : data.timestamp) === void 0 && (data == null ? void 0 : data.ttd) === void 0) {
          const msg = "No fork hash calculation possible for future hardfork";
          throw new Error(msg);
        }
        if ((data == null ? void 0 : data.forkHash) !== null && (data == null ? void 0 : data.forkHash) !== void 0) {
          return data.forkHash;
        }
        if (!genesisHash)
          throw new Error("genesisHash required for forkHash calculation");
        return this._calcForkHash(hardfork, genesisHash);
      }
      /**
       *
       * @param forkHash Fork hash as a hex string
       * @returns Array with hardfork data (name, block, forkHash)
       */
      hardforkForForkHash(forkHash) {
        const resArray = this.hardforks().filter((hf) => {
          return hf.forkHash === forkHash;
        });
        return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
      }
      /**
       * Sets any missing forkHashes on the passed-in {@link Common} instance
       * @param common The {@link Common} to set the forkHashes for
       * @param genesisHash The genesis block hash
       */
      setForkHashes(genesisHash) {
        for (const hf of this.hardforks()) {
          const blockOrTime = hf.timestamp ?? hf.block;
          if ((hf.forkHash === null || hf.forkHash === void 0) && (blockOrTime !== null && blockOrTime !== void 0 || typeof hf.ttd !== "undefined")) {
            hf.forkHash = this.forkHash(hf.name, genesisHash);
          }
        }
      }
      /**
       * Returns the Genesis parameters of the current chain
       * @returns Genesis dictionary
       */
      genesis() {
        return this._chainParams.genesis;
      }
      /**
       * Returns the hardforks for current chain
       * @returns {Array} Array with arrays of hardforks
       */
      hardforks() {
        return this._chainParams.hardforks;
      }
      /**
       * Returns bootstrap nodes for the current chain
       * @returns {Dictionary} Dict with bootstrap nodes
       */
      bootstrapNodes() {
        return this._chainParams.bootstrapNodes;
      }
      /**
       * Returns DNS networks for the current chain
       * @returns {String[]} Array of DNS ENR urls
       */
      dnsNetworks() {
        return this._chainParams.dnsNetworks;
      }
      /**
       * Returns the hardfork set
       * @returns Hardfork name
       */
      hardfork() {
        return this._hardfork;
      }
      /**
       * Returns the Id of current chain
       * @returns chain Id
       */
      chainId() {
        return BigInt(this._chainParams.chainId);
      }
      /**
       * Returns the name of current chain
       * @returns chain name (lower case)
       */
      chainName() {
        return this._chainParams.name;
      }
      /**
       * Returns the Id of current network
       * @returns network Id
       */
      networkId() {
        return BigInt(this._chainParams.networkId);
      }
      /**
       * Returns the active EIPs
       * @returns List of EIPs
       */
      eips() {
        return this._eips;
      }
      /**
       * Returns the consensus type of the network
       * Possible values: "pow"|"poa"|"pos"
       *
       * Note: This value can update along a Hardfork.
       */
      consensusType() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"]["type"];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"]["type"];
      }
      /**
       * Returns the concrete consensus implementation
       * algorithm or protocol for the network
       * e.g. "ethash" for "pow" consensus type,
       * "clique" for "poa" consensus type or
       * "casper" for "pos" consensus type.
       *
       * Note: This value can update along a Hardfork.
       */
      consensusAlgorithm() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"]["algorithm"];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"]["algorithm"];
      }
      /**
       * Returns a dictionary with consensus configuration
       * parameters based on the consensus algorithm
       *
       * Expected returns (parameters must be present in
       * the respective chain json files):
       *
       * ethash: empty object
       * clique: period, epoch
       * casper: empty object
       *
       * Note: This value can update along a Hardfork.
       */
      consensusConfig() {
        const hardfork = this.hardfork();
        let value;
        for (const hfChanges of this.HARDFORK_CHANGES) {
          if ("consensus" in hfChanges[1]) {
            value = hfChanges[1]["consensus"][hfChanges[1]["consensus"]["algorithm"]];
          }
          if (hfChanges[0] === hardfork)
            break;
        }
        return value ?? this._chainParams["consensus"][this.consensusAlgorithm()] ?? {};
      }
      /**
       * Returns a deep copy of this {@link Common} instance.
       */
      copy() {
        const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        copy.removeAllListeners();
        return copy;
      }
      static _getInitializedChains(customChains) {
        const names = {};
        for (const [name, id] of Object.entries(enums_1.Chain)) {
          names[id] = name.toLowerCase();
        }
        const chains = { mainnet, ropsten, rinkeby, goerli, sepolia };
        if (customChains) {
          for (const chain of customChains) {
            const { name } = chain;
            names[chain.chainId.toString()] = name;
            chains[name] = chain;
          }
        }
        chains.names = names;
        return chains;
      }
    };
    exports.Common = Common2;
  }
});

// node_modules/@ethereumjs/common/dist/types.js
var require_types = __commonJS({
  "node_modules/@ethereumjs/common/dist/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ethereumjs/common/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@ethereumjs/common/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_common(), exports);
    __exportStar(require_enums(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_utils2(), exports);
  }
});

// node_modules/@ethereumjs/tx/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@ethereumjs/tx/dist/constants.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BYTES_PER_FIELD_ELEMENT = exports.FIELD_ELEMENTS_PER_BLOB = exports.MAX_TX_WRAP_KZG_COMMITMENTS = exports.LIMIT_BLOBS_PER_TX = exports.MAX_VERSIONED_HASHES_LIST_SIZE = exports.MAX_ACCESS_LIST_SIZE = exports.MAX_CALLDATA_SIZE = void 0;
    exports.MAX_CALLDATA_SIZE = 16777216;
    exports.MAX_ACCESS_LIST_SIZE = 16777216;
    exports.MAX_VERSIONED_HASHES_LIST_SIZE = 16777216;
    exports.LIMIT_BLOBS_PER_TX = 16777216;
    exports.MAX_TX_WRAP_KZG_COMMITMENTS = 16777216;
    exports.FIELD_ELEMENTS_PER_BLOB = 4096;
    exports.BYTES_PER_FIELD_ELEMENT = 32;
  }
});

// node_modules/@ethereumjs/tx/dist/types.js
var require_types2 = __commonJS({
  "node_modules/@ethereumjs/tx/dist/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobNetworkTransactionWrapper = exports.KZGProofType = exports.KZGCommitmentType = exports.SignedBlobTransactionType = exports.ECDSASignatureType = exports.BlobTransactionType = exports.AccessTupleType = exports.AddressType = exports.isAccessList = exports.isAccessListBuffer = exports.Capability = void 0;
    var ssz_1 = require_lib();
    var constants_1 = require_constants();
    var Bytes20 = new ssz_1.ByteVectorType(20);
    var Bytes32 = new ssz_1.ByteVectorType(32);
    var Bytes48 = new ssz_1.ByteVectorType(48);
    var Uint64 = new ssz_1.UintBigintType(8);
    var Uint256 = new ssz_1.UintBigintType(32);
    var Capability;
    (function(Capability2) {
      Capability2[Capability2["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
      Capability2[Capability2["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
      Capability2[Capability2["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
      Capability2[Capability2["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
    })(Capability = exports.Capability || (exports.Capability = {}));
    function isAccessListBuffer(input) {
      if (input.length === 0) {
        return true;
      }
      const firstItem = input[0];
      if (Array.isArray(firstItem)) {
        return true;
      }
      return false;
    }
    exports.isAccessListBuffer = isAccessListBuffer;
    function isAccessList(input) {
      return !isAccessListBuffer(input);
    }
    exports.isAccessList = isAccessList;
    exports.AddressType = Bytes20;
    exports.AccessTupleType = new ssz_1.ContainerType({
      address: exports.AddressType,
      storageKeys: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE)
    });
    exports.BlobTransactionType = new ssz_1.ContainerType({
      chainId: Uint256,
      nonce: Uint64,
      maxPriorityFeePerGas: Uint256,
      maxFeePerGas: Uint256,
      gas: Uint64,
      to: new ssz_1.UnionType([new ssz_1.NoneType(), exports.AddressType]),
      value: Uint256,
      data: new ssz_1.ByteListType(constants_1.MAX_CALLDATA_SIZE),
      accessList: new ssz_1.ListCompositeType(exports.AccessTupleType, constants_1.MAX_ACCESS_LIST_SIZE),
      maxFeePerDataGas: Uint256,
      blobVersionedHashes: new ssz_1.ListCompositeType(Bytes32, constants_1.MAX_VERSIONED_HASHES_LIST_SIZE)
    });
    exports.ECDSASignatureType = new ssz_1.ContainerType({
      yParity: new ssz_1.BooleanType(),
      r: Uint256,
      s: Uint256
    });
    exports.SignedBlobTransactionType = new ssz_1.ContainerType({
      message: exports.BlobTransactionType,
      signature: exports.ECDSASignatureType
    });
    exports.KZGCommitmentType = Bytes48;
    exports.KZGProofType = exports.KZGCommitmentType;
    exports.BlobNetworkTransactionWrapper = new ssz_1.ContainerType({
      tx: exports.SignedBlobTransactionType,
      blobKzgs: new ssz_1.ListCompositeType(exports.KZGCommitmentType, constants_1.MAX_TX_WRAP_KZG_COMMITMENTS),
      blobs: new ssz_1.ListCompositeType(new ssz_1.ByteVectorType(constants_1.FIELD_ELEMENTS_PER_BLOB * constants_1.BYTES_PER_FIELD_ELEMENT), constants_1.LIMIT_BLOBS_PER_TX),
      kzgAggregatedProof: exports.KZGProofType
    });
  }
});

// node_modules/@ethereumjs/tx/dist/baseTransaction.js
var require_baseTransaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/baseTransaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseTransaction = void 0;
    var common_1 = require_dist4();
    var util_1 = require_dist3();
    var types_1 = require_types2();
    var BaseTransaction = class {
      constructor(txData, opts) {
        this.cache = {
          hash: void 0,
          dataFee: void 0
        };
        this.activeCapabilities = [];
        this.DEFAULT_CHAIN = common_1.Chain.Mainnet;
        this.DEFAULT_HARDFORK = common_1.Hardfork.Merge;
        const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
        this._type = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(type)));
        this.txOptions = opts;
        const toB = (0, util_1.toBuffer)(to === "" ? "0x" : to);
        const vB = (0, util_1.toBuffer)(v === "" ? "0x" : v);
        const rB = (0, util_1.toBuffer)(r === "" ? "0x" : r);
        const sB = (0, util_1.toBuffer)(s === "" ? "0x" : s);
        this.nonce = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(nonce === "" ? "0x" : nonce));
        this.gasLimit = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasLimit === "" ? "0x" : gasLimit));
        this.to = toB.length > 0 ? new util_1.Address(toB) : void 0;
        this.value = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(value === "" ? "0x" : value));
        this.data = (0, util_1.toBuffer)(data === "" ? "0x" : data);
        this.v = vB.length > 0 ? (0, util_1.bufferToBigInt)(vB) : void 0;
        this.r = rB.length > 0 ? (0, util_1.bufferToBigInt)(rB) : void 0;
        this.s = sB.length > 0 ? (0, util_1.bufferToBigInt)(sB) : void 0;
        this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
        this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
        this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
      }
      /**
       * Returns the transaction type.
       *
       * Note: legacy txs will return tx type `0`.
       */
      get type() {
        return this._type;
      }
      /**
       * Checks if a tx type defining capability is active
       * on a tx, for example the EIP-1559 fee market mechanism
       * or the EIP-2930 access list feature.
       *
       * Note that this is different from the tx type itself,
       * so EIP-2930 access lists can very well be active
       * on an EIP-1559 tx for example.
       *
       * This method can be useful for feature checks if the
       * tx type is unknown (e.g. when instantiated with
       * the tx factory).
       *
       * See `Capabilites` in the `types` module for a reference
       * on all supported capabilities.
       */
      supports(capability) {
        return this.activeCapabilities.includes(capability);
      }
      validate(stringError = false) {
        const errors = [];
        if (this.getBaseFee() > this.gasLimit) {
          errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
        }
        if (this.isSigned() && !this.verifySignature()) {
          errors.push("Invalid Signature");
        }
        return stringError ? errors : errors.length === 0;
      }
      _validateYParity() {
        const { v } = this;
        if (v !== void 0 && v !== BigInt(0) && v !== BigInt(1)) {
          const msg = this._errorMsg("The y-parity of the transaction should either be 0 or 1");
          throw new Error(msg);
        }
      }
      /**
       * EIP-2: All transaction signatures whose s-value is greater than secp256k1n/2are considered invalid.
       * Reasoning: https://ethereum.stackexchange.com/a/55728
       */
      _validateHighS() {
        const { s } = this;
        if (this.common.gteHardfork("homestead") && s !== void 0 && s > util_1.SECP256K1_ORDER_DIV_2) {
          const msg = this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
          throw new Error(msg);
        }
      }
      /**
       * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)
       */
      getBaseFee() {
        const txFee = this.common.param("gasPrices", "tx");
        let fee = this.getDataFee();
        if (txFee)
          fee += txFee;
        if (this.common.gteHardfork("homestead") && this.toCreationAddress()) {
          const txCreationFee = this.common.param("gasPrices", "txCreation");
          if (txCreationFee)
            fee += txCreationFee;
        }
        return fee;
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
        const txDataZero = this.common.param("gasPrices", "txDataZero");
        const txDataNonZero = this.common.param("gasPrices", "txDataNonZero");
        let cost = BigInt(0);
        for (let i = 0; i < this.data.length; i++) {
          this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;
        }
        if ((this.to === void 0 || this.to === null) && this.common.isActivatedEIP(3860)) {
          const dataLength = BigInt(Math.ceil(this.data.length / 32));
          const initCodeCost = this.common.param("gasPrices", "initCodeWordCost") * dataLength;
          cost += initCodeCost;
        }
        return cost;
      }
      /**
       * If the tx's `to` is to the creation address
       */
      toCreationAddress() {
        return this.to === void 0 || this.to.buf.length === 0;
      }
      isSigned() {
        const { v, r, s } = this;
        if (v === void 0 || r === void 0 || s === void 0) {
          return false;
        } else {
          return true;
        }
      }
      /**
       * Determines if the signature is valid
       */
      verifySignature() {
        try {
          const publicKey = this.getSenderPublicKey();
          return (0, util_1.unpadBuffer)(publicKey).length !== 0;
        } catch (e) {
          return false;
        }
      }
      /**
       * Returns the sender's address
       */
      getSenderAddress() {
        return new util_1.Address((0, util_1.publicToAddress)(this.getSenderPublicKey()));
      }
      /**
       * Signs a transaction.
       *
       * Note that the signed tx is returned as a new object,
       * use as follows:
       * ```javascript
       * const signedTx = tx.sign(privateKey)
       * ```
       */
      sign(privateKey) {
        if (privateKey.length !== 32) {
          const msg = this._errorMsg("Private key must be 32 bytes in length.");
          throw new Error(msg);
        }
        let hackApplied = false;
        if (this.type === 0 && this.common.gteHardfork("spuriousDragon") && !this.supports(types_1.Capability.EIP155ReplayProtection)) {
          this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
          hackApplied = true;
        }
        const msgHash = this.getMessageToSign(true);
        const { v, r, s } = (0, util_1.ecsign)(msgHash, privateKey);
        const tx = this._processSignature(v, r, s);
        if (hackApplied) {
          const index = this.activeCapabilities.indexOf(types_1.Capability.EIP155ReplayProtection);
          if (index > -1) {
            this.activeCapabilities.splice(index, 1);
          }
        }
        return tx;
      }
      /**
       * Does chain ID checks on common and returns a common
       * to be used on instantiation
       * @hidden
       *
       * @param common - {@link Common} instance from tx options
       * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)
       */
      _getCommon(common, chainId) {
        if (chainId !== void 0) {
          const chainIdBigInt = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(chainId));
          if (common) {
            if (common.chainId() !== chainIdBigInt) {
              const msg = this._errorMsg("The chain ID does not match the chain ID of Common");
              throw new Error(msg);
            }
            return common.copy();
          } else {
            if (common_1.Common.isSupportedChainId(chainIdBigInt)) {
              return new common_1.Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK });
            } else {
              return common_1.Common.custom({
                name: "custom-chain",
                networkId: chainIdBigInt,
                chainId: chainIdBigInt
              }, { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
            }
          }
        } else {
          return (common == null ? void 0 : common.copy()) ?? new common_1.Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
        }
      }
      /**
       * Validates that an object with BigInt values cannot exceed the specified bit limit.
       * @param values Object containing string keys and BigInt values
       * @param bits Number of bits to check (64 or 256)
       * @param cannotEqual Pass true if the number also cannot equal one less the maximum value
       */
      _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
        for (const [key, value] of Object.entries(values)) {
          switch (bits) {
            case 64:
              if (cannotEqual) {
                if (value !== void 0 && value >= util_1.MAX_UINT64) {
                  const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
                  throw new Error(msg);
                }
              } else {
                if (value !== void 0 && value > util_1.MAX_UINT64) {
                  const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
                  throw new Error(msg);
                }
              }
              break;
            case 256:
              if (cannotEqual) {
                if (value !== void 0 && value >= util_1.MAX_INTEGER) {
                  const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
                  throw new Error(msg);
                }
              } else {
                if (value !== void 0 && value > util_1.MAX_INTEGER) {
                  const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
                  throw new Error(msg);
                }
              }
              break;
            default: {
              const msg = this._errorMsg("unimplemented bits value");
              throw new Error(msg);
            }
          }
        }
      }
      static _validateNotArray(values) {
        const txDataKeys = [
          "nonce",
          "gasPrice",
          "gasLimit",
          "to",
          "value",
          "data",
          "v",
          "r",
          "s",
          "type",
          "baseFee",
          "maxFeePerGas",
          "chainId"
        ];
        for (const [key, value] of Object.entries(values)) {
          if (txDataKeys.includes(key)) {
            if (Array.isArray(value)) {
              throw new Error(`${key} cannot be an array`);
            }
          }
        }
      }
      /**
       * Returns the shared error postfix part for _error() method
       * tx type implementations.
       */
      _getSharedErrorPostfix() {
        let hash = "";
        try {
          hash = this.isSigned() ? (0, util_1.bufferToHex)(this.hash()) : "not available (unsigned)";
        } catch (e) {
          hash = "error";
        }
        let isSigned = "";
        try {
          isSigned = this.isSigned().toString();
        } catch (e) {
          hash = "error";
        }
        let hf = "";
        try {
          hf = this.common.hardfork();
        } catch (e) {
          hf = "error";
        }
        let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `;
        postfix += `signed=${isSigned} hf=${hf}`;
        return postfix;
      }
    };
    exports.BaseTransaction = BaseTransaction;
  }
});

// node_modules/@ethereumjs/tx/dist/util.js
var require_util = __commonJS({
  "node_modules/@ethereumjs/tx/dist/util.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.blobTxToNetworkWrapperDataFormat = exports.AccessLists = exports.checkMaxInitCodeSize = void 0;
    var util_1 = require_dist3();
    var types_1 = require_types2();
    function checkMaxInitCodeSize(common, length) {
      const maxInitCodeSize = common.param("vm", "maxInitCodeSize");
      if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
        throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param("vm", "maxInitCodeSize")}`);
      }
    }
    exports.checkMaxInitCodeSize = checkMaxInitCodeSize;
    var AccessLists = class {
      static getAccessListData(accessList) {
        let AccessListJSON;
        let bufferAccessList;
        if ((0, types_1.isAccessList)(accessList)) {
          AccessListJSON = accessList;
          const newAccessList = [];
          for (let i = 0; i < accessList.length; i++) {
            const item = accessList[i];
            const addressBuffer = (0, util_1.toBuffer)(item.address);
            const storageItems = [];
            for (let index = 0; index < item.storageKeys.length; index++) {
              storageItems.push((0, util_1.toBuffer)(item.storageKeys[index]));
            }
            newAccessList.push([addressBuffer, storageItems]);
          }
          bufferAccessList = newAccessList;
        } else {
          bufferAccessList = accessList ?? [];
          const json = [];
          for (let i = 0; i < bufferAccessList.length; i++) {
            const data = bufferAccessList[i];
            const address = (0, util_1.bufferToHex)(data[0]);
            const storageKeys = [];
            for (let item = 0; item < data[1].length; item++) {
              storageKeys.push((0, util_1.bufferToHex)(data[1][item]));
            }
            const jsonItem = {
              address,
              storageKeys
            };
            json.push(jsonItem);
          }
          AccessListJSON = json;
        }
        return {
          AccessListJSON,
          accessList: bufferAccessList
        };
      }
      static verifyAccessList(accessList) {
        for (let key = 0; key < accessList.length; key++) {
          const accessListItem = accessList[key];
          const address = accessListItem[0];
          const storageSlots = accessListItem[1];
          if (accessListItem[2] !== void 0) {
            throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
          }
          if (address.length !== 20) {
            throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
          }
          for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {
            if (storageSlots[storageSlot].length !== 32) {
              throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes");
            }
          }
        }
      }
      static getAccessListJSON(accessList) {
        const accessListJSON = [];
        for (let index = 0; index < accessList.length; index++) {
          const item = accessList[index];
          const JSONItem = {
            address: "0x" + (0, util_1.setLengthLeft)(item[0], 20).toString("hex"),
            storageKeys: []
          };
          const storageSlots = item[1];
          for (let slot = 0; slot < storageSlots.length; slot++) {
            const storageSlot = storageSlots[slot];
            JSONItem.storageKeys.push("0x" + (0, util_1.setLengthLeft)(storageSlot, 32).toString("hex"));
          }
          accessListJSON.push(JSONItem);
        }
        return accessListJSON;
      }
      static getDataFeeEIP2930(accessList, common) {
        const accessListStorageKeyCost = common.param("gasPrices", "accessListStorageKeyCost");
        const accessListAddressCost = common.param("gasPrices", "accessListAddressCost");
        let slots = 0;
        for (let index = 0; index < accessList.length; index++) {
          const item = accessList[index];
          const storageSlots = item[1];
          slots += storageSlots.length;
        }
        const addresses = accessList.length;
        return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
      }
    };
    exports.AccessLists = AccessLists;
    var blobTxToNetworkWrapperDataFormat = (tx) => {
      var _a;
      const to = {
        selector: tx.to !== void 0 ? 1 : 0,
        value: ((_a = tx.to) == null ? void 0 : _a.toBuffer()) ?? null
      };
      return {
        message: {
          chainId: tx.common.chainId(),
          nonce: tx.nonce,
          maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
          maxFeePerGas: tx.maxFeePerGas,
          gas: tx.gasLimit,
          to,
          value: tx.value,
          data: tx.data,
          accessList: tx.accessList.map((listItem) => {
            return { address: listItem[0], storageKeys: listItem[1] };
          }),
          blobVersionedHashes: tx.versionedHashes,
          maxFeePerDataGas: tx.maxFeePerDataGas
        },
        // If transaction is unsigned, signature fields will be initialized to zeroes
        signature: {
          r: tx.r ?? BigInt(0),
          s: tx.s ?? BigInt(0),
          yParity: tx.v === BigInt(1) ? true : false
        }
      };
    };
    exports.blobTxToNetworkWrapperDataFormat = blobTxToNetworkWrapperDataFormat;
  }
});

// node_modules/@ethereumjs/tx/dist/eip1559Transaction.js
var require_eip1559Transaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/eip1559Transaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FeeMarketEIP1559Transaction = void 0;
    var rlp_1 = require_dist2();
    var util_1 = require_dist3();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var util_2 = require_util();
    var TRANSACTION_TYPE = 2;
    var TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, "0"), "hex");
    var FeeMarketEIP1559Transaction = class extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.DEFAULT_HARDFORK = "london";
        const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (this.common.isActivatedEIP(1559) === false) {
          throw new Error("EIP-1559 not enabled on Common");
        }
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === "" ? "0x" : maxFeePerGas));
        this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === "" ? "0x" : maxPriorityFeePerGas));
        this._validateCannotExceedMaxInteger({
          maxFeePerGas: this.maxFeePerGas,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
          throw new Error(msg);
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
          const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
          throw new Error(msg);
        }
        this._validateYParity();
        this._validateHighS();
        if (this.common.isActivatedEIP(3860)) {
          (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);
        }
        const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, v, r, s }
       *
       * Notes:
       * - `chainId` will be set automatically if not provided
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
        return new FeeMarketEIP1559Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS])`
       */
      static fromSerializedTx(serialized, opts = {}) {
        if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
          throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized.slice(0, 1).toString("hex")}`);
        }
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(serialized.slice(1)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input: must be array");
        }
        return FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS]`
       */
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 9 && values.length !== 12) {
          throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
        }
        const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s] = values;
        this._validateNotArray({ chainId, v });
        (0, util_1.validateNoLeadingZeroes)({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s });
        return new FeeMarketEIP1559Transaction({
          chainId: (0, util_1.bufferToBigInt)(chainId),
          nonce,
          maxPriorityFeePerGas,
          maxFeePerGas,
          gasLimit,
          to,
          value,
          data,
          accessList: accessList ?? [],
          v: v !== void 0 ? (0, util_1.bufferToBigInt)(v) : void 0,
          r,
          s
        }, opts);
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        let cost = super.getDataFee();
        cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: cost,
            hardfork: this.common.hardfork()
          };
        }
        return cost;
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       * @param baseFee The base fee of the block (will be set to 0 if not provided)
       */
      getUpfrontCost(baseFee = BigInt(0)) {
        const prio = this.maxPriorityFeePerGas;
        const maxBase = this.maxFeePerGas - baseFee;
        const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
        const gasPrice = inclusionFeePerGas + baseFee;
        return this.gasLimit * gasPrice + this.value;
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the EIP-1559 transaction, in order.
       *
       * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS]`
       *
       * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block
       * with {@link Block.fromValuesArray}.
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.
       */
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.chainId),
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),
          (0, util_1.bigIntToUnpaddedBuffer)(this.maxFeePerGas),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.accessList,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      /**
       * Returns the serialized encoding of the EIP-1559 transaction.
       *
       * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
       * accessList, signatureYParity, signatureR, signatureS])`
       *
       * Note that in contrast to the legacy tx serialization format this is not
       * valid RLP any more due to the raw tx type preceding and concatenated to
       * the RLP encoding of the values.
       */
      serialize() {
        const base = this.raw();
        return Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
      }
      /**
       * Returns the serialized unsigned tx (hashed or raw), which can be used
       * to sign the transaction (e.g. for sending to a hardware wallet).
       *
       * Note: in contrast to the legacy tx the raw message format is already
       * serialized and doesn't need to be RLP encoded any more.
       *
       * ```javascript
       * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input
       * ```
       *
       * @param hashMessage - Return hashed message if set to true (default: true)
       */
      getMessageToSign(hashMessage = true) {
        const base = this.raw().slice(0, 9);
        const message = Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(message));
        } else {
          return message;
        }
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
        return this.getMessageToSign();
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call this method if transaction is not signed");
          throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(
            msgHash,
            v + BigInt(27),
            // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r),
            (0, util_1.bigIntToUnpaddedBuffer)(s)
          );
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return FeeMarketEIP1559Transaction.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas,
          maxFeePerGas: this.maxFeePerGas,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: v - BigInt(27),
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction
       */
      toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
          chainId: (0, util_1.bigIntToHex)(this.chainId),
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),
          maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          accessList: accessListJSON,
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
        return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.FeeMarketEIP1559Transaction = FeeMarketEIP1559Transaction;
  }
});

// node_modules/@ethereumjs/tx/dist/eip2930Transaction.js
var require_eip2930Transaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/eip2930Transaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccessListEIP2930Transaction = void 0;
    var rlp_1 = require_dist2();
    var util_1 = require_dist3();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var util_2 = require_util();
    var TRANSACTION_TYPE = 1;
    var TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, "0"), "hex");
    var AccessListEIP2930Transaction = class extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.DEFAULT_HARDFORK = "berlin";
        const { chainId, accessList, gasPrice } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (!this.common.isActivatedEIP(2930)) {
          throw new Error("EIP-2930 not enabled on Common");
        }
        this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(gasPrice === "" ? "0x" : gasPrice));
        this._validateCannotExceedMaxInteger({
          gasPrice: this.gasPrice
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
          throw new Error(msg);
        }
        this._validateYParity();
        this._validateHighS();
        if (this.common.isActivatedEIP(3860)) {
          (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);
        }
        const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * v, r, s }
       *
       * Notes:
       * - `chainId` will be set automatically if not provided
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
        return new AccessListEIP2930Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)])`
       */
      static fromSerializedTx(serialized, opts = {}) {
        if (!serialized.slice(0, 1).equals(TRANSACTION_TYPE_BUFFER)) {
          throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${serialized.slice(0, 1).toString("hex")}`);
        }
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized.slice(1))));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input: must be array");
        }
        return AccessListEIP2930Transaction.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)]`
       */
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 8 && values.length !== 11) {
          throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
        }
        const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
        this._validateNotArray({ chainId, v });
        (0, util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        const emptyAccessList = [];
        return new AccessListEIP2930Transaction({
          chainId: (0, util_1.bufferToBigInt)(chainId),
          nonce,
          gasPrice,
          gasLimit,
          to,
          value,
          data,
          accessList: accessList ?? emptyAccessList,
          v: v !== void 0 ? (0, util_1.bufferToBigInt)(v) : void 0,
          r,
          s
        }, opts);
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        let cost = super.getDataFee();
        cost += BigInt(util_2.AccessLists.getDataFeeEIP2930(this.accessList, this.common));
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: cost,
            hardfork: this.common.hardfork()
          };
        }
        return cost;
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       */
      getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value;
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the EIP-2930 transaction, in order.
       *
       * Format: `[chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)]`
       *
       * Use {@link AccessListEIP2930Transaction.serialize} to add a transaction to a block
       * with {@link Block.fromValuesArray}.
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link AccessListEIP2930Transaction.getMessageToSign}.
       */
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.chainId),
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.accessList,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      /**
       * Returns the serialized encoding of the EIP-2930 transaction.
       *
       * Format: `0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList,
       * signatureYParity (v), signatureR (r), signatureS (s)])`
       *
       * Note that in contrast to the legacy tx serialization format this is not
       * valid RLP any more due to the raw tx type preceding and concatenated to
       * the RLP encoding of the values.
       */
      serialize() {
        const base = this.raw();
        return Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
      }
      /**
       * Returns the serialized unsigned tx (hashed or raw), which can be used
       * to sign the transaction (e.g. for sending to a hardware wallet).
       *
       * Note: in contrast to the legacy tx the raw message format is already
       * serialized and doesn't need to be RLP encoded any more.
       *
       * ```javascript
       * const serializedMessage = tx.getMessageToSign(false) // use this for the HW wallet input
       * ```
       *
       * @param hashMessage - Return hashed message if set to true (default: true)
       */
      getMessageToSign(hashMessage = true) {
        const base = this.raw().slice(0, 8);
        const message = Buffer.concat([
          TRANSACTION_TYPE_BUFFER,
          Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(base)))
        ]);
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(message));
        } else {
          return message;
        }
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link AccessListEIP2930Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(this.serialize()));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
        return this.getMessageToSign();
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call this method if transaction is not signed");
          throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(
            msgHash,
            v + BigInt(27),
            // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r),
            (0, util_1.bigIntToUnpaddedBuffer)(s)
          );
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return AccessListEIP2930Transaction.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: v - BigInt(27),
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction
       */
      toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
          chainId: (0, util_1.bigIntToHex)(this.chainId),
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          accessList: accessListJSON,
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
        var _a;
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` gasPrice=${this.gasPrice} accessListCount=${((_a = this.accessList) == null ? void 0 : _a.length) ?? 0}`;
        return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.AccessListEIP2930Transaction = AccessListEIP2930Transaction;
  }
});

// node_modules/@ethereumjs/tx/dist/kzg/kzg.js
var require_kzg = __commonJS({
  "node_modules/@ethereumjs/tx/dist/kzg/kzg.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initKZG = exports.kzg = void 0;
    function kzgNotLoaded() {
      throw Error("kzg library not loaded");
    }
    exports.kzg = {
      freeTrustedSetup: kzgNotLoaded,
      loadTrustedSetup: kzgNotLoaded,
      blobToKzgCommitment: kzgNotLoaded,
      computeAggregateKzgProof: kzgNotLoaded,
      verifyKzgProof: kzgNotLoaded,
      verifyAggregateKzgProof: kzgNotLoaded
    };
    function initKZG(kzgLib, trustedSetupPath) {
      exports.kzg = kzgLib;
      exports.kzg.loadTrustedSetup(trustedSetupPath);
    }
    exports.initKZG = initKZG;
  }
});

// node_modules/ethereum-cryptography/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/ethereum-cryptography/sha256.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils();
    exports.sha256 = (0, utils_1.wrapHash)(sha256_1.sha256);
  }
});

// node_modules/@ethereumjs/tx/dist/utils/blobHelpers.js
var require_blobHelpers = __commonJS({
  "node_modules/@ethereumjs/tx/dist/utils/blobHelpers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.commitmentsToVersionedHashes = exports.computeVersionedHash = exports.blobsToCommitments = exports.getBlobs = void 0;
    var sha256_1 = require_sha2562();
    var kzg_1 = require_kzg();
    var BYTES_PER_FIELD_ELEMENT = 32;
    var FIELD_ELEMENTS_PER_BLOB = 4096;
    var USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;
    var MAX_BLOBS_PER_TX = 2;
    var MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;
    var BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;
    function get_padded(data, blobs_len) {
      const pdata = Buffer.alloc(blobs_len * USEFUL_BYTES_PER_BLOB);
      const datalen = Buffer.byteLength(data);
      pdata.fill(data, 0, datalen);
      pdata[datalen] = 128;
      return pdata;
    }
    function get_blob(data) {
      const blob = Buffer.alloc(BLOB_SIZE, "binary");
      for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {
        const chunk = Buffer.alloc(32, "binary");
        chunk.fill(data.subarray(i * 31, (i + 1) * 31), 0, 31);
        blob.fill(chunk, i * 32, (i + 1) * 32);
      }
      return blob;
    }
    var getBlobs = (input) => {
      const data = Buffer.from(input, "binary");
      const len = Buffer.byteLength(data);
      if (len === 0) {
        throw Error("invalid blob data");
      }
      if (len > MAX_USEFUL_BYTES_PER_TX) {
        throw Error("blob data is too large");
      }
      const blobs_len = Math.ceil(len / USEFUL_BYTES_PER_BLOB);
      const pdata = get_padded(data, blobs_len);
      const blobs = [];
      for (let i = 0; i < blobs_len; i++) {
        const chunk = pdata.subarray(i * USEFUL_BYTES_PER_BLOB, (i + 1) * USEFUL_BYTES_PER_BLOB);
        const blob = get_blob(chunk);
        blobs.push(blob);
      }
      return blobs;
    };
    exports.getBlobs = getBlobs;
    var blobsToCommitments = (blobs) => {
      const commitments = [];
      for (const blob of blobs) {
        commitments.push(Buffer.from(kzg_1.kzg.blobToKzgCommitment(blob)));
      }
      return commitments;
    };
    exports.blobsToCommitments = blobsToCommitments;
    var computeVersionedHash = (commitment, blobCommitmentVersion) => {
      const computedVersionedHash = new Uint8Array(32);
      computedVersionedHash.set([blobCommitmentVersion], 0);
      computedVersionedHash.set((0, sha256_1.sha256)(commitment).slice(1), 1);
      return computedVersionedHash;
    };
    exports.computeVersionedHash = computeVersionedHash;
    var commitmentsToVersionedHashes = (commitments) => {
      const hashes = [];
      for (const commitment of commitments) {
        hashes.push(Buffer.from((0, exports.computeVersionedHash)(commitment, 1)));
      }
      return hashes;
    };
    exports.commitmentsToVersionedHashes = commitmentsToVersionedHashes;
  }
});

// node_modules/@ethereumjs/tx/dist/eip4844Transaction.js
var require_eip4844Transaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/eip4844Transaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlobEIP4844Transaction = void 0;
    var ssz_1 = require_lib();
    var util_1 = require_dist3();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var constants_1 = require_constants();
    var kzg_1 = require_kzg();
    var types_1 = require_types2();
    var util_2 = require_util();
    var blobHelpers_1 = require_blobHelpers();
    var TRANSACTION_TYPE = 5;
    var TRANSACTION_TYPE_BUFFER = Buffer.from(TRANSACTION_TYPE.toString(16).padStart(2, "0"), "hex");
    var validateBlobTransactionNetworkWrapper = (versionedHashes, blobs, commitments, kzgProof, version) => {
      if (!(versionedHashes.length === blobs.length && blobs.length === commitments.length)) {
        throw new Error("Number of versionedHashes, blobs, and commitments not all equal");
      }
      try {
        kzg_1.kzg.verifyAggregateKzgProof(blobs, commitments, kzgProof);
      } catch (e) {
        throw new Error("KZG proof cannot be verified from blobs/commitments");
      }
      for (let x = 0; x < versionedHashes.length; x++) {
        const computedVersionedHash = (0, blobHelpers_1.computeVersionedHash)(commitments[x], version);
        if (!(0, ssz_1.byteArrayEquals)(computedVersionedHash, versionedHashes[x])) {
          throw new Error(`commitment for blob at index ${x} does not match versionedHash`);
        }
      }
    };
    var BlobEIP4844Transaction = class extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static constructors or factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
        var _a, _b;
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas, maxFeePerDataGas } = txData;
        this.common = this._getCommon(opts.common, chainId);
        this.chainId = this.common.chainId();
        if (this.common.isActivatedEIP(1559) === false) {
          throw new Error("EIP-1559 not enabled on Common");
        }
        if (this.common.isActivatedEIP(4844) === false) {
          throw new Error("EIP-4844 not enabled on Common");
        }
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        const accessListData = util_2.AccessLists.getAccessListData(accessList ?? []);
        this.accessList = accessListData.accessList;
        this.AccessListJSON = accessListData.AccessListJSON;
        util_2.AccessLists.verifyAccessList(this.accessList);
        this.maxFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxFeePerGas === "" ? "0x" : maxFeePerGas));
        this.maxPriorityFeePerGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(maxPriorityFeePerGas === "" ? "0x" : maxPriorityFeePerGas));
        this._validateCannotExceedMaxInteger({
          maxFeePerGas: this.maxFeePerGas,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas
        });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.gasLimit * this.maxFeePerGas > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
          throw new Error(msg);
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
          const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
          throw new Error(msg);
        }
        this.maxFeePerDataGas = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)((maxFeePerDataGas ?? "") === "" ? "0x" : maxFeePerDataGas));
        this.versionedHashes = (txData.versionedHashes ?? []).map((vh) => (0, util_1.toBuffer)(vh));
        this._validateYParity();
        this._validateHighS();
        if (this.common.isActivatedEIP(3860)) {
          (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);
        }
        for (const hash of this.versionedHashes) {
          if (hash.length !== 32) {
            const msg = this._errorMsg("versioned hash is invalid length");
            throw new Error(msg);
          }
          if (BigInt(hash[0]) !== this.common.paramByEIP("sharding", "blobCommitmentVersionKzg", 4844)) {
            const msg = this._errorMsg("versioned hash does not start with KZG commitment version");
            throw new Error(msg);
          }
        }
        if (this.versionedHashes.length > constants_1.LIMIT_BLOBS_PER_TX) {
          const msg = this._errorMsg(`tx can contain at most ${constants_1.LIMIT_BLOBS_PER_TX} blobs`);
          throw new Error(msg);
        }
        this.blobs = (_a = txData.blobs) == null ? void 0 : _a.map((blob) => (0, util_1.toBuffer)(blob));
        this.kzgCommitments = (_b = txData.kzgCommitments) == null ? void 0 : _b.map((commitment) => (0, util_1.toBuffer)(commitment));
        this.aggregateKzgProof = (0, util_1.toBuffer)(txData.kzgProof);
        const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      static fromTxData(txData, opts) {
        return new BlobEIP4844Transaction(txData, opts);
      }
      /**
       * Creates the minimal representation of a blob transaction from the network wrapper version.
       * The minimal representation is used when adding transactions to an execution payload/block
       * @param txData a {@link BlobEIP4844Transaction} containing optional blobs/kzg commitments
       * @param opts - dictionary of {@link TxOptions}
       * @returns the "minimal" representation of a BlobEIP4844Transaction (i.e. transaction object minus blobs and kzg commitments)
       */
      static minimalFromNetworkWrapper(txData, opts) {
        const tx = BlobEIP4844Transaction.fromTxData({
          ...txData,
          ...{ blobs: void 0, kzgCommitments: void 0, kzgProof: void 0 }
        }, opts);
        return tx;
      }
      /**
       * Creates a transaction from the network encoding of a blob transaction (with blobs/commitments/proof)
       * @param serialized a buffer representing a serialized BlobTransactionNetworkWrapper
       * @param opts any TxOptions defined
       * @returns a BlobEIP4844Transaction
       * @throws if no KZG library is loaded -- using the `initKzg` helper method -- or if `opts.common` not provided
       */
      static fromSerializedBlobTxNetworkWrapper(serialized, opts) {
        if (!opts || !opts.common) {
          throw new Error("common instance required to validate versioned hashes");
        }
        const wrapper = types_1.BlobNetworkTransactionWrapper.deserialize(serialized.slice(1));
        const decodedTx = wrapper.tx.message;
        const version = Number(opts.common.paramByEIP("sharding", "blobCommitmentVersionKzg", 4844));
        validateBlobTransactionNetworkWrapper(decodedTx.blobVersionedHashes, wrapper.blobs, wrapper.blobKzgs, wrapper.kzgAggregatedProof, version);
        const accessList = [];
        for (const listItem of decodedTx.accessList) {
          const address = Buffer.from(listItem.address);
          const storageKeys = listItem.storageKeys.map((key) => Buffer.from(key));
          const accessListItem = [address, storageKeys];
          accessList.push(accessListItem);
        }
        const to = decodedTx.to.value === null ? void 0 : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(decodedTx.to.value)));
        const versionedHashes = decodedTx.blobVersionedHashes.map((el) => Buffer.from(el));
        const commitments = wrapper.blobKzgs.map((el) => Buffer.from(el));
        const blobs = wrapper.blobs.map((el) => Buffer.from(el));
        const txData = {
          ...decodedTx,
          ...{
            versionedHashes,
            accessList,
            to,
            blobs,
            kzgCommitments: commitments,
            kzgProof: Buffer.from(wrapper.kzgAggregatedProof),
            r: wrapper.tx.signature.r,
            s: wrapper.tx.signature.s,
            v: BigInt(wrapper.tx.signature.yParity),
            gasLimit: decodedTx.gas,
            maxFeePerGas: decodedTx.maxFeePerGas,
            maxPriorityFeePerGas: decodedTx.maxPriorityFeePerGas
          }
        };
        return new BlobEIP4844Transaction(txData, opts);
      }
      /**
       * Creates a transaction from the "minimal" encoding of a blob transaction (without blobs/commitments/kzg proof)
       * @param serialized a buffer representing a serialized signed blob transaction
       * @param opts any TxOptions defined
       * @returns a BlobEIP4844Transaction
       */
      static fromSerializedTx(serialized, opts) {
        const decoded = types_1.SignedBlobTransactionType.deserialize(serialized.slice(1));
        const tx = decoded.message;
        const accessList = [];
        for (const listItem of tx.accessList) {
          const address = Buffer.from(listItem.address);
          const storageKeys = listItem.storageKeys.map((key) => Buffer.from(key));
          const accessListItem = [address, storageKeys];
          accessList.push(accessListItem);
        }
        const to = tx.to.value === null ? void 0 : util_1.Address.fromString((0, util_1.bufferToHex)(Buffer.from(tx.to.value)));
        const versionedHashes = tx.blobVersionedHashes.map((el) => Buffer.from(el));
        const txData = {
          ...tx,
          ...{
            versionedHashes,
            to,
            accessList,
            r: decoded.signature.r,
            s: decoded.signature.s,
            v: BigInt(decoded.signature.yParity),
            gasLimit: decoded.message.gas
          }
        };
        return new BlobEIP4844Transaction(txData, opts);
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       * @param baseFee The base fee of the block (will be set to 0 if not provided)
       */
      getUpfrontCost(baseFee = BigInt(0)) {
        const prio = this.maxPriorityFeePerGas;
        const maxBase = this.maxFeePerGas - baseFee;
        const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
        const gasPrice = inclusionFeePerGas + baseFee;
        return this.gasLimit * gasPrice + this.value;
      }
      /**
       * This method is not implemented for blob transactions as the `raw` method is used exclusively with
       * rlp encoding and these transactions use SSZ for serialization.
       */
      raw() {
        throw new Error("Method not implemented.");
      }
      toValue() {
        var _a;
        const to = {
          selector: this.to !== void 0 ? 1 : 0,
          value: ((_a = this.to) == null ? void 0 : _a.toBuffer()) ?? null
        };
        return {
          message: {
            chainId: this.common.chainId(),
            nonce: this.nonce,
            maxPriorityFeePerGas: this.maxPriorityFeePerGas,
            maxFeePerGas: this.maxFeePerGas,
            gas: this.gasLimit,
            to,
            value: this.value,
            data: this.data,
            accessList: this.accessList.map((listItem) => {
              return { address: listItem[0], storageKeys: listItem[1] };
            }),
            blobVersionedHashes: this.versionedHashes,
            maxFeePerDataGas: this.maxFeePerDataGas
          },
          // TODO: Decide how to serialize an unsigned transaction
          signature: {
            r: this.r ?? BigInt(0),
            s: this.s ?? BigInt(0),
            yParity: this.v === BigInt(1) ? true : false
          }
        };
      }
      /**
       * Serialize a blob transaction to the execution payload variant
       * @returns the minimum (execution payload) serialization of a signed transaction
       */
      serialize() {
        const sszEncodedTx = types_1.SignedBlobTransactionType.serialize(this.toValue());
        return Buffer.concat([TRANSACTION_TYPE_BUFFER, sszEncodedTx]);
      }
      /**
       * @returns the serialized form of a blob transaction in the network wrapper format (used for gossipping mempool transactions over devp2p)
       */
      serializeNetworkWrapper() {
        var _a, _b, _c;
        if (this.blobs === void 0 || this.kzgCommitments === void 0 || this.aggregateKzgProof === void 0) {
          throw new Error("cannot serialize network wrapper without blobs, KZG commitments and aggregate KZG proof provided");
        }
        const to = {
          selector: this.to !== void 0 ? 1 : 0,
          value: ((_a = this.to) == null ? void 0 : _a.toBuffer()) ?? null
        };
        const blobArrays = ((_b = this.blobs) == null ? void 0 : _b.map((blob) => Uint8Array.from(blob))) ?? [];
        const serializedTxWrapper = types_1.BlobNetworkTransactionWrapper.serialize({
          blobs: blobArrays,
          blobKzgs: ((_c = this.kzgCommitments) == null ? void 0 : _c.map((commitment) => Uint8Array.from(commitment))) ?? [],
          tx: { ...(0, util_2.blobTxToNetworkWrapperDataFormat)(this), ...to },
          kzgAggregatedProof: Uint8Array.from(this.aggregateKzgProof ?? [])
        });
        return Buffer.concat([Buffer.from([5]), serializedTxWrapper]);
      }
      getMessageToSign(_hashMessage) {
        return this.unsignedHash();
      }
      /**
       * Returns the hash of a blob transaction
       */
      unsignedHash() {
        const serializedTx = types_1.BlobTransactionType.serialize(this.toValue().message);
        return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([TRANSACTION_TYPE_BUFFER, serializedTx])));
      }
      hash() {
        return Buffer.from((0, keccak_1.keccak256)(this.serialize()));
      }
      getMessageToVerifySignature() {
        return this.getMessageToSign();
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call this method if transaction is not signed");
          throw new Error(msg);
        }
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(
            msgHash,
            v + BigInt(27),
            // Recover the 27 which was stripped from ecsign
            (0, util_1.bigIntToUnpaddedBuffer)(r),
            (0, util_1.bigIntToUnpaddedBuffer)(s)
          );
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      toJSON() {
        const accessListJSON = util_2.AccessLists.getAccessListJSON(this.accessList);
        return {
          chainId: (0, util_1.bigIntToHex)(this.chainId),
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          maxPriorityFeePerGas: (0, util_1.bigIntToHex)(this.maxPriorityFeePerGas),
          maxFeePerGas: (0, util_1.bigIntToHex)(this.maxFeePerGas),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          accessList: accessListJSON,
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0,
          maxFeePerDataGas: (0, util_1.bigIntToHex)(this.maxFeePerDataGas),
          versionedHashes: this.versionedHashes.map((hash) => (0, util_1.bufferToHex)(hash))
        };
      }
      _processSignature(v, r, s) {
        const opts = { ...this.txOptions, common: this.common };
        return BlobEIP4844Transaction.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas,
          maxFeePerGas: this.maxFeePerGas,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: v - BigInt(27),
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s),
          maxFeePerDataGas: this.maxFeePerDataGas,
          versionedHashes: this.versionedHashes,
          blobs: this.blobs,
          kzgCommitments: this.kzgCommitments,
          kzgProof: this.aggregateKzgProof
        }, opts);
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
        return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
      /**
       * @returns the number of blobs included with this transaction
       */
      numBlobs() {
        return this.versionedHashes.length;
      }
    };
    exports.BlobEIP4844Transaction = BlobEIP4844Transaction;
  }
});

// node_modules/@ethereumjs/tx/dist/legacyTransaction.js
var require_legacyTransaction = __commonJS({
  "node_modules/@ethereumjs/tx/dist/legacyTransaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = void 0;
    var rlp_1 = require_dist2();
    var util_1 = require_dist3();
    var keccak_1 = require_keccak();
    var baseTransaction_1 = require_baseTransaction();
    var types_1 = require_types2();
    var util_2 = require_util();
    var TRANSACTION_TYPE = 0;
    function meetsEIP155(_v, chainId) {
      const v = Number(_v);
      const chainIdDoubled = Number(chainId) * 2;
      return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
    }
    var Transaction = class extends baseTransaction_1.BaseTransaction {
      /**
       * This constructor takes the values, validates them, assigns them and freezes the object.
       *
       * It is not recommended to use this constructor directly. Instead use
       * the static factory methods to assist in creating a Transaction object from
       * varying data types.
       */
      constructor(txData, opts = {}) {
        super({ ...txData, type: TRANSACTION_TYPE }, opts);
        this.common = this._validateTxV(this.v, opts.common);
        this.gasPrice = (0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.gasPrice === "" ? "0x" : txData.gasPrice));
        if (this.gasPrice * this.gasLimit > util_1.MAX_INTEGER) {
          const msg = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
          throw new Error(msg);
        }
        this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
        baseTransaction_1.BaseTransaction._validateNotArray(txData);
        if (this.common.gteHardfork("spuriousDragon")) {
          if (!this.isSigned()) {
            this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
          } else {
            if (meetsEIP155(this.v, this.common.chainId())) {
              this.activeCapabilities.push(types_1.Capability.EIP155ReplayProtection);
            }
          }
        }
        if (this.common.isActivatedEIP(3860)) {
          (0, util_2.checkMaxInitCodeSize)(this.common, this.data.length);
        }
        const freeze = (opts == null ? void 0 : opts.freeze) ?? true;
        if (freeze) {
          Object.freeze(this);
        }
      }
      /**
       * Instantiate a transaction from a data dictionary.
       *
       * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }
       *
       * Notes:
       * - All parameters are optional and have some basic default values
       */
      static fromTxData(txData, opts = {}) {
        return new Transaction(txData, opts);
      }
      /**
       * Instantiate a transaction from the serialized tx.
       *
       * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
       */
      static fromSerializedTx(serialized, opts = {}) {
        const values = (0, util_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));
        if (!Array.isArray(values)) {
          throw new Error("Invalid serialized tx input. Must be array");
        }
        return this.fromValuesArray(values, opts);
      }
      /**
       * Create a transaction from a values array.
       *
       * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
       */
      static fromValuesArray(values, opts = {}) {
        if (values.length !== 6 && values.length !== 9) {
          throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
        }
        const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
        (0, util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        return new Transaction({
          nonce,
          gasPrice,
          gasLimit,
          to,
          value,
          data,
          v,
          r,
          s
        }, opts);
      }
      /**
       * Returns a Buffer Array of the raw Buffers of the legacy transaction, in order.
       *
       * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
       *
       * For legacy txs this is also the correct format to add transactions
       * to a block with {@link Block.fromValuesArray} (use the `serialize()` method
       * for typed txs).
       *
       * For an unsigned tx this method returns the empty Buffer values
       * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant
       * representation have a look at {@link Transaction.getMessageToSign}.
       */
      raw() {
        return [
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data,
          this.v !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.v) : Buffer.from([]),
          this.r !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.r) : Buffer.from([]),
          this.s !== void 0 ? (0, util_1.bigIntToUnpaddedBuffer)(this.s) : Buffer.from([])
        ];
      }
      /**
       * Returns the serialized encoding of the legacy transaction.
       *
       * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
       *
       * For an unsigned tx this method uses the empty Buffer values for the
       * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
       * representation for external signing use {@link Transaction.getMessageToSign}.
       */
      serialize() {
        return Buffer.from(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw())));
      }
      _getMessageToSign() {
        const values = [
          (0, util_1.bigIntToUnpaddedBuffer)(this.nonce),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasPrice),
          (0, util_1.bigIntToUnpaddedBuffer)(this.gasLimit),
          this.to !== void 0 ? this.to.buf : Buffer.from([]),
          (0, util_1.bigIntToUnpaddedBuffer)(this.value),
          this.data
        ];
        if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
          values.push((0, util_1.toBuffer)(this.common.chainId()));
          values.push((0, util_1.unpadBuffer)((0, util_1.toBuffer)(0)));
          values.push((0, util_1.unpadBuffer)((0, util_1.toBuffer)(0)));
        }
        return values;
      }
      getMessageToSign(hashMessage = true) {
        const message = this._getMessageToSign();
        if (hashMessage) {
          return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(message))));
        } else {
          return message;
        }
      }
      /**
       * The amount of gas paid for the data in this tx
       */
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
          return this.cache.dataFee.value;
        }
        if (Object.isFrozen(this)) {
          this.cache.dataFee = {
            value: super.getDataFee(),
            hardfork: this.common.hardfork()
          };
        }
        return super.getDataFee();
      }
      /**
       * The up front amount that an account must have for this transaction to be valid
       */
      getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value;
      }
      /**
       * Computes a sha3-256 hash of the serialized tx.
       *
       * This method can only be used for signed txs (it throws otherwise).
       * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
       */
      hash() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
          throw new Error(msg);
        }
        if (Object.isFrozen(this)) {
          if (!this.cache.hash) {
            this.cache.hash = Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw()))));
          }
          return this.cache.hash;
        }
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(this.raw()))));
      }
      /**
       * Computes a sha3-256 hash which can be used to verify the signature
       */
      getMessageToVerifySignature() {
        if (!this.isSigned()) {
          const msg = this._errorMsg("This transaction is not signed");
          throw new Error(msg);
        }
        const message = this._getMessageToSign();
        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, util_1.bufArrToArr)(message))));
      }
      /**
       * Returns the public key of the sender
       */
      getSenderPublicKey() {
        const msgHash = this.getMessageToVerifySignature();
        const { v, r, s } = this;
        this._validateHighS();
        try {
          return (0, util_1.ecrecover)(msgHash, v, (0, util_1.bigIntToUnpaddedBuffer)(r), (0, util_1.bigIntToUnpaddedBuffer)(s), this.supports(types_1.Capability.EIP155ReplayProtection) ? this.common.chainId() : void 0);
        } catch (e) {
          const msg = this._errorMsg("Invalid Signature");
          throw new Error(msg);
        }
      }
      /**
       * Process the v, r, s values from the `sign` method of the base transaction.
       */
      _processSignature(v, r, s) {
        if (this.supports(types_1.Capability.EIP155ReplayProtection)) {
          v += this.common.chainId() * BigInt(2) + BigInt(8);
        }
        const opts = { ...this.txOptions, common: this.common };
        return Transaction.fromTxData({
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          v,
          r: (0, util_1.bufferToBigInt)(r),
          s: (0, util_1.bufferToBigInt)(s)
        }, opts);
      }
      /**
       * Returns an object with the JSON representation of the transaction.
       */
      toJSON() {
        return {
          nonce: (0, util_1.bigIntToHex)(this.nonce),
          gasPrice: (0, util_1.bigIntToHex)(this.gasPrice),
          gasLimit: (0, util_1.bigIntToHex)(this.gasLimit),
          to: this.to !== void 0 ? this.to.toString() : void 0,
          value: (0, util_1.bigIntToHex)(this.value),
          data: "0x" + this.data.toString("hex"),
          v: this.v !== void 0 ? (0, util_1.bigIntToHex)(this.v) : void 0,
          r: this.r !== void 0 ? (0, util_1.bigIntToHex)(this.r) : void 0,
          s: this.s !== void 0 ? (0, util_1.bigIntToHex)(this.s) : void 0
        };
      }
      /**
       * Validates tx's `v` value
       */
      _validateTxV(_v, common) {
        let chainIdBigInt;
        const v = _v !== void 0 ? Number(_v) : void 0;
        if (v !== void 0) {
          if (v < 37 && v !== 27 && v !== 28) {
            throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
          }
        }
        if (v !== void 0 && v !== 0 && (!common || common.gteHardfork("spuriousDragon")) && v !== 27 && v !== 28) {
          if (common) {
            if (!meetsEIP155(BigInt(v), common.chainId())) {
              throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
            }
          } else {
            let numSub;
            if ((v - 35) % 2 === 0) {
              numSub = 35;
            } else {
              numSub = 36;
            }
            chainIdBigInt = BigInt(v - numSub) / BigInt(2);
          }
        }
        return this._getCommon(common, chainIdBigInt);
      }
      /**
       * Return a compact error string representation of the object
       */
      errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` gasPrice=${this.gasPrice}`;
        return errorStr;
      }
      /**
       * Internal helper function to create an annotated error message
       *
       * @param msg Base error message
       * @hidden
       */
      _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
      }
    };
    exports.Transaction = Transaction;
  }
});

// node_modules/@ethereumjs/tx/dist/fromRpc.js
var require_fromRpc = __commonJS({
  "node_modules/@ethereumjs/tx/dist/fromRpc.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeTxParams = void 0;
    var util_1 = require_dist3();
    var normalizeTxParams = (_txParams) => {
      const txParams = Object.assign({}, _txParams);
      txParams.gasLimit = (0, util_1.toType)(txParams.gasLimit ?? txParams.gas, util_1.TypeOutput.BigInt);
      txParams.data = txParams.data === void 0 ? txParams.input : txParams.data;
      txParams.gasPrice = txParams.gasPrice !== void 0 ? BigInt(txParams.gasPrice) : void 0;
      txParams.value = txParams.value !== void 0 ? BigInt(txParams.value) : void 0;
      txParams.to = txParams.to !== null && txParams.to !== void 0 ? (0, util_1.setLengthLeft)((0, util_1.toBuffer)(txParams.to), 20) : null;
      txParams.v = (0, util_1.toType)(txParams.v, util_1.TypeOutput.BigInt);
      return txParams;
    };
    exports.normalizeTxParams = normalizeTxParams;
  }
});

// node_modules/@ethereumjs/tx/dist/transactionFactory.js
var require_transactionFactory = __commonJS({
  "node_modules/@ethereumjs/tx/dist/transactionFactory.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionFactory = void 0;
    var util_1 = require_dist3();
    var providers_1 = (init_lib(), __toCommonJS(lib_exports));
    var eip1559Transaction_1 = require_eip1559Transaction();
    var eip2930Transaction_1 = require_eip2930Transaction();
    var eip4844Transaction_1 = require_eip4844Transaction();
    var fromRpc_1 = require_fromRpc();
    var legacyTransaction_1 = require_legacyTransaction();
    var TransactionFactory2 = class {
      // It is not possible to instantiate a TransactionFactory object.
      constructor() {
      }
      /**
       * Create a transaction from a `txData` object
       *
       * @param txData - The transaction data. The `type` field will determine which transaction type is returned (if undefined, creates a legacy transaction)
       * @param txOptions - Options to pass on to the constructor of the transaction
       */
      static fromTxData(txData, txOptions = {}) {
        if (!("type" in txData) || txData.type === void 0) {
          return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
        } else {
          const txType = Number((0, util_1.bufferToBigInt)((0, util_1.toBuffer)(txData.type)));
          if (txType === 0) {
            return legacyTransaction_1.Transaction.fromTxData(txData, txOptions);
          } else if (txType === 1) {
            return eip2930Transaction_1.AccessListEIP2930Transaction.fromTxData(txData, txOptions);
          } else if (txType === 2) {
            return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);
          } else if (txType === 5) {
            return eip4844Transaction_1.BlobEIP4844Transaction.fromTxData(txData, txOptions);
          } else {
            throw new Error(`Tx instantiation with type ${txType} not supported`);
          }
        }
      }
      /**
       * This method tries to decode serialized data.
       *
       * @param data - The data Buffer
       * @param txOptions - The transaction options
       */
      static fromSerializedData(data, txOptions = {}) {
        if (data[0] <= 127) {
          switch (data[0]) {
            case 1:
              return eip2930Transaction_1.AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
            case 2:
              return eip1559Transaction_1.FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
            case 5:
              return eip4844Transaction_1.BlobEIP4844Transaction.fromSerializedTx(data, txOptions);
            default:
              throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
          }
        } else {
          return legacyTransaction_1.Transaction.fromSerializedTx(data, txOptions);
        }
      }
      /**
       * When decoding a BlockBody, in the transactions field, a field is either:
       * A Buffer (a TypedTransaction - encoded as TransactionType || rlp(TransactionPayload))
       * A Buffer[] (Legacy Transaction)
       * This method returns the right transaction.
       *
       * @param data - A Buffer or Buffer[]
       * @param txOptions - The transaction options
       */
      static fromBlockBodyData(data, txOptions = {}) {
        if (Buffer.isBuffer(data)) {
          return this.fromSerializedData(data, txOptions);
        } else if (Array.isArray(data)) {
          return legacyTransaction_1.Transaction.fromValuesArray(data, txOptions);
        } else {
          throw new Error("Cannot decode transaction: unknown type input");
        }
      }
      /**
       *  Method to retrieve a transaction from the provider
       * @param provider - An Ethers JsonRPCProvider
       * @param txHash - Transaction hash
       * @param txOptions - The transaction options
       * @returns the transaction specified by `txHash`
       */
      static async fromEthersProvider(provider, txHash, txOptions) {
        const prov = typeof provider === "string" ? new providers_1.JsonRpcProvider(provider) : provider;
        const txData = await prov.send("eth_getTransactionByHash", [txHash]);
        const normedTx = (0, fromRpc_1.normalizeTxParams)(txData);
        return TransactionFactory2.fromTxData(normedTx, txOptions);
      }
    };
    exports.TransactionFactory = TransactionFactory2;
  }
});

// node_modules/@ethereumjs/tx/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@ethereumjs/tx/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeVersionedHash = exports.TransactionFactory = exports.Transaction = exports.kzg = exports.initKZG = exports.BlobEIP4844Transaction = exports.AccessListEIP2930Transaction = exports.FeeMarketEIP1559Transaction = void 0;
    var eip1559Transaction_1 = require_eip1559Transaction();
    Object.defineProperty(exports, "FeeMarketEIP1559Transaction", { enumerable: true, get: function() {
      return eip1559Transaction_1.FeeMarketEIP1559Transaction;
    } });
    var eip2930Transaction_1 = require_eip2930Transaction();
    Object.defineProperty(exports, "AccessListEIP2930Transaction", { enumerable: true, get: function() {
      return eip2930Transaction_1.AccessListEIP2930Transaction;
    } });
    var eip4844Transaction_1 = require_eip4844Transaction();
    Object.defineProperty(exports, "BlobEIP4844Transaction", { enumerable: true, get: function() {
      return eip4844Transaction_1.BlobEIP4844Transaction;
    } });
    var kzg_1 = require_kzg();
    Object.defineProperty(exports, "initKZG", { enumerable: true, get: function() {
      return kzg_1.initKZG;
    } });
    Object.defineProperty(exports, "kzg", { enumerable: true, get: function() {
      return kzg_1.kzg;
    } });
    var legacyTransaction_1 = require_legacyTransaction();
    Object.defineProperty(exports, "Transaction", { enumerable: true, get: function() {
      return legacyTransaction_1.Transaction;
    } });
    var transactionFactory_1 = require_transactionFactory();
    Object.defineProperty(exports, "TransactionFactory", { enumerable: true, get: function() {
      return transactionFactory_1.TransactionFactory;
    } });
    __exportStar(require_types2(), exports);
    var blobHelpers_1 = require_blobHelpers();
    Object.defineProperty(exports, "computeVersionedHash", { enumerable: true, get: function() {
      return blobHelpers_1.computeVersionedHash;
    } });
  }
});

// node_modules/is-hex-prefixed/src/index.js
var require_src = __commonJS({
  "node_modules/is-hex-prefixed/src/index.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function isHexPrefixed(str) {
      if (typeof str !== "string") {
        throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
      }
      return str.slice(0, 2) === "0x";
    };
  }
});

// node_modules/strip-hex-prefix/src/index.js
var require_src2 = __commonJS({
  "node_modules/strip-hex-prefix/src/index.js"(exports, module) {
    init_process();
    init_buffer();
    var isHexPrefixed = require_src();
    module.exports = function stripHexPrefix2(str) {
      if (typeof str !== "string") {
        return str;
      }
      return isHexPrefixed(str) ? str.slice(2) : str;
    };
  }
});

// node_modules/ethjs-util/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ethjs-util/lib/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var isHexPrefixed = require_src();
    var stripHexPrefix2 = require_src2();
    function padToEven(value) {
      var a = value;
      if (typeof a !== "string") {
        throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a + ", while padToEven.");
      }
      if (a.length % 2) {
        a = "0" + a;
      }
      return a;
    }
    function intToHex(i) {
      var hex3 = i.toString(16);
      return "0x" + hex3;
    }
    function intToBuffer(i) {
      var hex3 = intToHex(i);
      return new Buffer(padToEven(hex3.slice(2)), "hex");
    }
    function getBinarySize(str) {
      if (typeof str !== "string") {
        throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof str + "'.");
      }
      return Buffer.byteLength(str, "utf8");
    }
    function arrayContainsArray(superset, subset, some) {
      if (Array.isArray(superset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof superset + "'");
      }
      if (Array.isArray(subset) !== true) {
        throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof subset + "'");
      }
      return subset[Boolean(some) && "some" || "every"](function(value) {
        return superset.indexOf(value) >= 0;
      });
    }
    function toUtf8(hex3) {
      var bufferValue = new Buffer(padToEven(stripHexPrefix2(hex3).replace(/^0+|0+$/g, "")), "hex");
      return bufferValue.toString("utf8");
    }
    function toAscii(hex3) {
      var str = "";
      var i = 0, l = hex3.length;
      if (hex3.substring(0, 2) === "0x") {
        i = 2;
      }
      for (; i < l; i += 2) {
        var code = parseInt(hex3.substr(i, 2), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }
    function fromUtf8(stringValue) {
      var str = new Buffer(stringValue, "utf8");
      return "0x" + padToEven(str.toString("hex")).replace(/^0+|0+$/g, "");
    }
    function fromAscii(stringValue) {
      var hex3 = "";
      for (var i = 0; i < stringValue.length; i++) {
        var code = stringValue.charCodeAt(i);
        var n = code.toString(16);
        hex3 += n.length < 2 ? "0" + n : n;
      }
      return "0x" + hex3;
    }
    function getKeys(params, key, allowEmpty) {
      if (!Array.isArray(params)) {
        throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof params + "'");
      }
      if (typeof key !== "string") {
        throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof key + "'.");
      }
      var result = [];
      for (var i = 0; i < params.length; i++) {
        var value = params[i][key];
        if (allowEmpty && !value) {
          value = "";
        } else if (typeof value !== "string") {
          throw new Error("invalid abi");
        }
        result.push(value);
      }
      return result;
    }
    function isHexString(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && value.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    module.exports = {
      arrayContainsArray,
      intToBuffer,
      getBinarySize,
      isHexPrefixed,
      stripHexPrefix: stripHexPrefix2,
      padToEven,
      intToHex,
      fromAscii,
      fromUtf8,
      toAscii,
      toUtf8,
      getKeys,
      isHexString
    };
  }
});

// node_modules/@metamask/eth-sig-util/dist/utils.js
var require_utils3 = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numberToBuffer = exports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;
    var util_1 = require_dist3();
    var ethjs_util_1 = require_lib2();
    function padWithZeroes(hexString, targetLength) {
      if (hexString !== "" && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
      }
      if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
      }
      return String.prototype.padStart.call(hexString, targetLength, "0");
    }
    exports.padWithZeroes = padWithZeroes;
    function isNullish(value) {
      return value === null || value === void 0;
    }
    exports.isNullish = isNullish;
    function legacyToBuffer(value) {
      return typeof value === "string" && !(0, ethjs_util_1.isHexString)(value) ? Buffer.from(value) : (0, util_1.toBuffer)(value);
    }
    exports.legacyToBuffer = legacyToBuffer;
    function concatSig(v, r, s) {
      const rSig = (0, util_1.fromSigned)(r);
      const sSig = (0, util_1.fromSigned)(s);
      const vSig = (0, util_1.bufferToInt)(v);
      const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString("hex"), 64);
      const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString("hex"), 64);
      const vStr = (0, ethjs_util_1.stripHexPrefix)((0, ethjs_util_1.intToHex)(vSig));
      return (0, util_1.addHexPrefix)(rStr.concat(sStr, vStr));
    }
    exports.concatSig = concatSig;
    function recoverPublicKey(messageHash, signature) {
      const sigParams = (0, util_1.fromRpcSig)(signature);
      return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function normalize(input) {
      if (!input) {
        return void 0;
      }
      if (typeof input === "number") {
        if (input < 0) {
          return "0x";
        }
        const buffer = (0, util_1.toBuffer)(input);
        input = (0, util_1.bufferToHex)(buffer);
      }
      if (typeof input !== "string") {
        let msg = "eth-sig-util.normalize() requires hex string or integer input.";
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
      }
      return (0, util_1.addHexPrefix)(input.toLowerCase());
    }
    exports.normalize = normalize;
    function numberToBuffer(num) {
      const hexVal = num.toString(16);
      const prepend = hexVal.length % 2 ? "0" : "";
      return Buffer.from(prepend + hexVal, "hex");
    }
    exports.numberToBuffer = numberToBuffer;
  }
});

// node_modules/@metamask/eth-sig-util/dist/personal-sign.js
var require_personal_sign = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/personal-sign.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;
    var util_1 = require_dist3();
    var utils_1 = require_utils3();
    function personalSign2({ privateKey, data }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      const message = (0, utils_1.legacyToBuffer)(data);
      const msgHash = (0, util_1.hashPersonalMessage)(message);
      const sig = (0, util_1.ecsign)(msgHash, privateKey);
      const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
      return serialized;
    }
    exports.personalSign = personalSign2;
    function recoverPersonalSignature({ data, signature }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const publicKey = getPublicKeyFor(data, signature);
      const sender = (0, util_1.publicToAddress)(publicKey);
      const senderHex = (0, util_1.bufferToHex)(sender);
      return senderHex;
    }
    exports.recoverPersonalSignature = recoverPersonalSignature;
    function extractPublicKey({ data, signature }) {
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const publicKey = getPublicKeyFor(data, signature);
      return `0x${publicKey.toString("hex")}`;
    }
    exports.extractPublicKey = extractPublicKey;
    function getPublicKeyFor(message, signature) {
      const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));
      return (0, utils_1.recoverPublicKey)(messageHash, signature);
    }
  }
});

// node_modules/@metamask/eth-sig-util/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@metamask/eth-sig-util/node_modules/bn.js/lib/bn.js"(exports, module) {
    init_process();
    init_buffer();
    (function(module2, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN2(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN2(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c, new BN2(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@metamask/eth-sig-util/dist/ethereumjs-abi-utils.js
var require_ethereumjs_abi_utils = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/ethereumjs-abi-utils.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEncode = exports.parseNumber = exports.solidityPack = void 0;
    var util_1 = require_dist3();
    var ethjs_util_1 = require_lib2();
    var bn_js_1 = __importDefault(require_bn2());
    var utils_1 = require_utils3();
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      const ret = [];
      for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        ret.push(solidityHexValue(type, value, null));
      }
      return Buffer.concat(ret);
    }
    exports.solidityPack = solidityPack;
    function isArray(type) {
      return type.lastIndexOf("]") === type.length - 1;
    }
    function parseTypeArray(type) {
      const tmp = type.match(/(.*)\[(.*?)\]$/u);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseTypeN(type) {
      return parseInt(/^\D+(\d+)$/u.exec(type)[1], 10);
    }
    function parseNumber(arg) {
      const type = typeof arg;
      if (type === "string") {
        if ((0, util_1.isHexPrefixed)(arg)) {
          return new bn_js_1.default((0, ethjs_util_1.stripHexPrefix)(arg), 16);
        }
        return new bn_js_1.default(arg, 10);
      } else if (type === "number") {
        return new bn_js_1.default(arg);
      } else if (arg.toArray) {
        return arg;
      }
      throw new Error("Argument is not a number");
    }
    exports.parseNumber = parseNumber;
    function solidityHexValue(type, value, bitsize) {
      let size, num;
      if (isArray(type)) {
        const subType = type.replace(/\[.*?\]/u, "");
        if (!isArray(subType)) {
          const arraySize = parseTypeArray(type);
          if (arraySize !== "dynamic" && arraySize !== 0 && value.length > arraySize) {
            throw new Error(`Elements exceed array size: ${arraySize}`);
          }
        }
        const arrayValues = value.map(function(v) {
          return solidityHexValue(subType, v, 256);
        });
        return Buffer.concat(arrayValues);
      } else if (type === "bytes") {
        return value;
      } else if (type === "string") {
        return Buffer.from(value, "utf8");
      } else if (type === "bool") {
        bitsize = bitsize || 8;
        const padding = Array(bitsize / 4).join("0");
        return Buffer.from(value ? `${padding}1` : `${padding}0`, "hex");
      } else if (type === "address") {
        let bytesize = 20;
        if (bitsize) {
          bytesize = bitsize / 8;
        }
        return (0, util_1.setLengthLeft)((0, util_1.toBuffer)(value), bytesize);
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        if (typeof value === "number") {
          value = (0, utils_1.normalize)(value);
        }
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(value), size);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid uint<N> width: ${size}`);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer, "be", bitsize / 8);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid int<N> width: ${size}`);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
          throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer, "be", bitsize / 8);
      }
      throw new Error(`Unsupported or invalid type: ${type}`);
    }
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return `int256${name.slice(3)}`;
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return `uint256${name.slice(4)}`;
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return `fixed128x128${name.slice(5)}`;
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return `ufixed128x128${name.slice(6)}`;
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function rawEncode(types, values) {
      const output = [];
      const data = [];
      let headLength = 0;
      types.forEach(function(type) {
        if (isArray(type)) {
          const size = parseTypeArray(type);
          if (size !== "dynamic") {
            headLength += 32 * size;
          } else {
            headLength += 32;
          }
        } else {
          headLength += 32;
        }
      });
      for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        const cur = encodeSingle(type, value);
        if (isDynamic(type)) {
          output.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data));
    }
    exports.rawEncode = rawEncode;
    function encodeSingle(type, arg) {
      let size, num, ret, i;
      if (type === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type === "string") {
        return encodeSingle("bytes", Buffer.from(arg, "utf8"));
      } else if (isArray(type)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size = parseTypeArray(type);
        if (size !== "dynamic" && size !== 0 && arg.length > size) {
          throw new Error(`Elements exceed array size: ${size}`);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i in arg) {
          if (Object.prototype.hasOwnProperty.call(arg, i)) {
            ret.push(encodeSingle(type, arg[i]));
          }
        }
        if (size === "dynamic") {
          const length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type === "bytes") {
        arg = Buffer.from(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, (0, util_1.zeros)(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type.startsWith("bytes")) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        if (typeof arg === "number") {
          arg = (0, utils_1.normalize)(arg);
        }
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(arg), 32);
      } else if (type.startsWith("uint")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid uint<N> width: ${size}`);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("int")) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
          throw new Error(`Invalid int<N> width: ${size}`);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type.startsWith("ufixed")) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
      } else if (type.startsWith("fixed")) {
        size = parseTypeNxM(type);
        return encodeSingle("int256", parseNumber(arg).mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
      }
      throw new Error(`Unsupported or invalid type: ${type}`);
    }
    function isDynamic(type) {
      return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
    }
    function parseTypeNxM(type) {
      const tmp = /^\D+(\d+)x(\d+)$/u.exec(type);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
  }
});

// node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js
var require_sign_typed_data = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;
    var ethjs_util_1 = require_lib2();
    var util_1 = require_dist3();
    var keccak_1 = require_keccak();
    var ethereumjs_abi_utils_1 = require_ethereumjs_abi_utils();
    var utils_1 = require_utils3();
    var SignTypedDataVersion2;
    (function(SignTypedDataVersion3) {
      SignTypedDataVersion3["V1"] = "V1";
      SignTypedDataVersion3["V3"] = "V3";
      SignTypedDataVersion3["V4"] = "V4";
    })(SignTypedDataVersion2 = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
    exports.TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    function validateVersion(version, allowedVersions) {
      if (!Object.keys(SignTypedDataVersion2).includes(version)) {
        throw new Error(`Invalid version: '${version}'`);
      } else if (allowedVersions && !allowedVersions.includes(version)) {
        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(", ")}`);
      }
    }
    function encodeField(types, name, type, value, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      if (types[type] !== void 0) {
        return [
          "bytes32",
          version === SignTypedDataVersion2.V4 && value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version)))
        ];
      }
      if (value === void 0) {
        throw new Error(`missing value for field ${name} of type ${type}`);
      }
      if (type === "bytes") {
        if (typeof value === "number") {
          value = (0, utils_1.numberToBuffer)(value);
        } else if ((0, ethjs_util_1.isHexString)(value)) {
          const prepend = value.length % 2 ? "0" : "";
          value = Buffer.from(prepend + value.slice(2), "hex");
        } else {
          value = Buffer.from(value, "utf8");
        }
        return ["bytes32", (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
      }
      if (type === "string") {
        if (typeof value === "number") {
          value = (0, utils_1.numberToBuffer)(value);
        } else {
          value = Buffer.from(value !== null && value !== void 0 ? value : "", "utf8");
        }
        return ["bytes32", (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
      }
      if (type.lastIndexOf("]") === type.length - 1) {
        if (version === SignTypedDataVersion2.V3) {
          throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
        }
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));
        return [
          "bytes32",
          (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.rawEncode)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))))
        ];
      }
      return [type, value];
    }
    function encodeData(primaryType, data, types, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      const encodedTypes = ["bytes32"];
      const encodedValues = [hashType(primaryType, types)];
      for (const field of types[primaryType]) {
        if (version === SignTypedDataVersion2.V3 && data[field.name] === void 0) {
          continue;
        }
        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return (0, ethereumjs_abi_utils_1.rawEncode)(encodedTypes, encodedValues);
    }
    function encodeType(primaryType, types) {
      let result = "";
      const unsortedDeps = findTypeDependencies(primaryType, types);
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        const children = types[type];
        if (!children) {
          throw new Error(`No type definition specified: ${type}`);
        }
        result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies(primaryType, types, results = /* @__PURE__ */ new Set()) {
      [primaryType] = primaryType.match(/^\w*/u);
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies(field.type, types, results);
      }
      return results;
    }
    function hashStruct(primaryType, data, types, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(primaryType, data, types, version)));
    }
    function hashType(primaryType, types) {
      const encodedHashType = Buffer.from(encodeType(primaryType, types), "utf-8");
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));
    }
    function sanitizeData(data) {
      const sanitizedData = {};
      for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {
        if (data[key]) {
          sanitizedData[key] = data[key];
        }
      }
      if ("types" in sanitizedData) {
        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
      }
      return sanitizedData;
    }
    function eip712Hash(typedData, version) {
      validateVersion(version, [SignTypedDataVersion2.V3, SignTypedDataVersion2.V4]);
      const sanitizedData = sanitizeData(typedData);
      const parts = [Buffer.from("1901", "hex")];
      parts.push(hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, version));
      if (sanitizedData.primaryType !== "EIP712Domain") {
        parts.push(hashStruct(
          // TODO: Validate that this is a string, so this type cast can be removed.
          sanitizedData.primaryType,
          sanitizedData.message,
          sanitizedData.types,
          version
        ));
      }
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(Buffer.concat(parts)));
    }
    exports.TypedDataUtils = {
      encodeData,
      encodeType,
      findTypeDependencies,
      hashStruct,
      hashType,
      sanitizeData,
      eip712Hash
    };
    function typedSignatureHash2(typedData) {
      const hashBuffer = _typedSignatureHash(typedData);
      return (0, util_1.bufferToHex)(hashBuffer);
    }
    exports.typedSignatureHash = typedSignatureHash2;
    function _typedSignatureHash(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !("length" in typedData) || !typedData.length) {
        throw error;
      }
      const data = typedData.map(function(e) {
        if (e.type !== "bytes") {
          return e.value;
        }
        return (0, utils_1.legacyToBuffer)(e.value);
      });
      const types = typedData.map(function(e) {
        return e.type;
      });
      const schema = typedData.map(function(e) {
        if (!e.name) {
          throw error;
        }
        return `${e.type} ${e.name}`;
      });
      return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(["bytes32", "bytes32"], [
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(new Array(typedData.length).fill("string"), schema)),
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(types, data))
      ])));
    }
    function signTypedData2({ privateKey, data, version }) {
      validateVersion(version);
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing private key parameter");
      }
      const messageHash = version === SignTypedDataVersion2.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);
      const sig = (0, util_1.ecsign)(messageHash, privateKey);
      return (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
    }
    exports.signTypedData = signTypedData2;
    function recoverTypedSignature({ data, signature, version }) {
      validateVersion(version);
      if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(signature)) {
        throw new Error("Missing signature parameter");
      }
      const messageHash = version === SignTypedDataVersion2.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);
      const publicKey = (0, utils_1.recoverPublicKey)(messageHash, signature);
      const sender = (0, util_1.publicToAddress)(publicKey);
      return (0, util_1.bufferToHex)(sender);
    }
    exports.recoverTypedSignature = recoverTypedSignature;
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    init_process();
    init_buffer();
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init)
          for (i = 0; i < init.length; i++)
            r[i] = init[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L,
        pack25519,
        unpack25519,
        M,
        A,
        S,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i = 0; i < arguments.length; i++) {
          if (!(arguments[i] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto = require_crypto();
          if (crypto && crypto.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/tweetnacl-util/nacl-util.js
var require_nacl_util = __commonJS({
  "node_modules/tweetnacl-util/nacl-util.js"(exports, module) {
    init_process();
    init_buffer();
    (function(root, f) {
      "use strict";
      if (typeof module !== "undefined" && module.exports)
        module.exports = f();
      else if (root.nacl)
        root.nacl.util = f();
      else {
        root.nacl = {};
        root.nacl.util = f();
      }
    })(exports, function() {
      "use strict";
      var util = {};
      function validateBase64(s) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s)) {
          throw new TypeError("invalid encoding");
        }
      }
      util.decodeUTF8 = function(s) {
        if (typeof s !== "string")
          throw new TypeError("expected string");
        var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
        for (i = 0; i < d.length; i++)
          b[i] = d.charCodeAt(i);
        return b;
      };
      util.encodeUTF8 = function(arr) {
        var i, s = [];
        for (i = 0; i < arr.length; i++)
          s.push(String.fromCharCode(arr[i]));
        return decodeURIComponent(escape(s.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util.decodeBase64 = function(s) {
            validateBase64(s);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, "base64"), 0));
          };
        } else {
          util.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util.decodeBase64 = function(s) {
            validateBase64(s);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s, "base64"), 0));
          };
        }
      } else {
        util.encodeBase64 = function(arr) {
          var i, s = [], len = arr.length;
          for (i = 0; i < len; i++)
            s.push(String.fromCharCode(arr[i]));
          return btoa(s.join(""));
        };
        util.decodeBase64 = function(s) {
          validateBase64(s);
          var i, d = atob(s), b = new Uint8Array(d.length);
          for (i = 0; i < d.length; i++)
            b[i] = d.charCodeAt(i);
          return b;
        };
      }
      return util;
    });
  }
});

// node_modules/@metamask/eth-sig-util/dist/encryption.js
var require_encryption = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/encryption.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;
    var nacl = __importStar(require_nacl_fast());
    var naclUtil = __importStar(require_nacl_util());
    var utils_1 = require_utils3();
    function encrypt({ publicKey, data, version }) {
      if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error("Missing publicKey parameter");
      } else if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(version)) {
        throw new Error("Missing version parameter");
      }
      switch (version) {
        case "x25519-xsalsa20-poly1305": {
          if (typeof data !== "string") {
            throw new Error("Message data must be given as a string");
          }
          const ephemeralKeyPair = nacl.box.keyPair();
          let pubKeyUInt8Array;
          try {
            pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);
          } catch (err) {
            throw new Error("Bad public key");
          }
          const msgParamsUInt8Array = naclUtil.decodeUTF8(data);
          const nonce = nacl.randomBytes(nacl.box.nonceLength);
          const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
          const output = {
            version: "x25519-xsalsa20-poly1305",
            nonce: naclUtil.encodeBase64(nonce),
            ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
            ciphertext: naclUtil.encodeBase64(encryptedMessage)
          };
          return output;
        }
        default:
          throw new Error("Encryption type/version not supported");
      }
    }
    exports.encrypt = encrypt;
    function encryptSafely({ publicKey, data, version }) {
      if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error("Missing publicKey parameter");
      } else if ((0, utils_1.isNullish)(data)) {
        throw new Error("Missing data parameter");
      } else if ((0, utils_1.isNullish)(version)) {
        throw new Error("Missing version parameter");
      }
      const DEFAULT_PADDING_LENGTH = 2 ** 11;
      const NACL_EXTRA_BYTES = 16;
      if (typeof data === "object" && "toJSON" in data) {
        throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
      }
      const dataWithPadding = {
        data,
        padding: ""
      };
      const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), "utf-8");
      const modVal = dataLength % DEFAULT_PADDING_LENGTH;
      let padLength = 0;
      if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES;
      }
      dataWithPadding.padding = "0".repeat(padLength);
      const paddedMessage = JSON.stringify(dataWithPadding);
      return encrypt({ publicKey, data: paddedMessage, version });
    }
    exports.encryptSafely = encryptSafely;
    function decrypt2({ encryptedData, privateKey }) {
      if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error("Missing encryptedData parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      switch (encryptedData.version) {
        case "x25519-xsalsa20-poly1305": {
          const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);
          const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;
          const nonce = naclUtil.decodeBase64(encryptedData.nonce);
          const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
          const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
          const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);
          let output;
          try {
            output = naclUtil.encodeUTF8(decryptedMessage);
          } catch (err) {
            throw new Error("Decryption failed.");
          }
          if (output) {
            return output;
          }
          throw new Error("Decryption failed.");
        }
        default:
          throw new Error("Encryption type/version not supported.");
      }
    }
    exports.decrypt = decrypt2;
    function decryptSafely({ encryptedData, privateKey }) {
      if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error("Missing encryptedData parameter");
      } else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error("Missing privateKey parameter");
      }
      const dataWithPadding = JSON.parse(decrypt2({ encryptedData, privateKey }));
      return dataWithPadding.data;
    }
    exports.decryptSafely = decryptSafely;
    function getEncryptionPublicKey2(privateKey) {
      const privateKeyUint8Array = nacl_decodeHex(privateKey);
      const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
      return naclUtil.encodeBase64(encryptionPublicKey);
    }
    exports.getEncryptionPublicKey = getEncryptionPublicKey2;
    function nacl_decodeHex(msgHex) {
      const msgBase64 = Buffer.from(msgHex, "hex").toString("base64");
      return naclUtil.decodeBase64(msgBase64);
    }
  }
});

// node_modules/@metamask/eth-sig-util/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@metamask/eth-sig-util/dist/index.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalize = exports.concatSig = void 0;
    __exportStar(require_personal_sign(), exports);
    __exportStar(require_sign_typed_data(), exports);
    __exportStar(require_encryption(), exports);
    var utils_1 = require_utils3();
    Object.defineProperty(exports, "concatSig", { enumerable: true, get: function() {
      return utils_1.concatSig;
    } });
    Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
      return utils_1.normalize;
    } });
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var test = {
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src3 = __commonJS({
  "node_modules/has/src/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src3();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach;
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf = Object.getPrototypeOf;
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        cache["$" + typedArray] = callBind(arr.slice);
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(cache, function(getter, typedArray) {
        if (!found) {
          try {
            if ("$" + getter(value) === typedArray) {
              found = $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      });
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(cache, function(getter, name) {
        if (!found) {
          try {
            getter(value);
            found = $slice(name, 1);
          } catch (e) {
          }
        }
      });
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var gOPD = require_gopd();
    var g = typeof globalThis === "undefined" ? globalThis : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e) {
          }
        }
      });
      return anyTrue;
    };
    module.exports = function isTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types3 = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/util/util.js
var require_util2 = __commonJS({
  "node_modules/util/util.js"(exports) {
    init_process();
    init_buffer();
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types3();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/assert/build/internal/errors.js
var require_errors = __commonJS({
  "node_modules/assert/build/internal/errors.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function _typeof2(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn2(self2, call) {
      if (call && (_typeof2(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized2(self2);
    }
    function _assertThisInitialized2(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _getPrototypeOf2(o) {
      _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf2(o);
    }
    function _inherits2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var codes = {};
    var assert2;
    var util;
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inherits2(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          var _this;
          _classCallCheck2(this, NodeError2);
          _this = _possibleConstructorReturn2(this, _getPrototypeOf2(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
          _this.code = code;
          return _this;
        }
        return NodeError2;
      }(Base);
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      if (assert2 === void 0)
        assert2 = require_assert();
      assert2(typeof name === "string", "'name' must be a string");
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(_typeof2(actual));
      return msg;
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
      var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
      if (util === void 0)
        util = require_util2();
      var inspected = util.inspect(value);
      if (inspected.length > 128) {
        inspected = "".concat(inspected.slice(0, 128), "...");
      }
      return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
    }, TypeError, RangeError);
    createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
      var type;
      if (value && value.constructor && value.constructor.name) {
        type = "instance of ".concat(value.constructor.name);
      } else {
        type = "type ".concat(_typeof2(value));
      }
      return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
    }, TypeError);
    createErrorType("ERR_MISSING_ARGS", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (assert2 === void 0)
        assert2 = require_assert();
      assert2(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a) {
        return '"'.concat(a, '"');
      });
      switch (len) {
        case 1:
          msg += "".concat(args[0], " argument");
          break;
        case 2:
          msg += "".concat(args[0], " and ").concat(args[1], " arguments");
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and ".concat(args[len - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }, TypeError);
    module.exports.codes = codes;
  }
});

// node_modules/assert/build/internal/assert/assertion_error.js
var require_assertion_error = __commonJS({
  "node_modules/assert/build/internal/assert/assertion_error.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        });
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn2(self2, call) {
      if (call && (_typeof2(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized2(self2);
    }
    function _assertThisInitialized2(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _inherits2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf2(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf2(o) {
      _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf2(o);
    }
    function _typeof2(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    var _require = require_util2();
    var inspect = _require.inspect;
    var _require2 = require_errors();
    var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function repeat(str, count) {
      count = Math.floor(count);
      if (str.length == 0 || count == 0)
        return "";
      var maxCount = str.length * count;
      count = Math.floor(Math.log(count) / Math.log(2));
      while (count) {
        str += str;
        count--;
      }
      str += str.substring(0, maxCount - str.length);
      return str;
    }
    var blue = "";
    var green = "";
    var red = "";
    var white = "";
    var kReadableOperator = {
      deepStrictEqual: "Expected values to be strictly deep-equal:",
      strictEqual: "Expected values to be strictly equal:",
      strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
      deepEqual: "Expected values to be loosely deep-equal:",
      equal: "Expected values to be loosely equal:",
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notEqual: 'Expected "actual" to be loosely unequal to:',
      notIdentical: "Values identical but not reference-equal:"
    };
    var kMaxShortLength = 10;
    function copyError(source) {
      var keys = Object.keys(source);
      var target = Object.create(Object.getPrototypeOf(source));
      keys.forEach(function(key) {
        target[key] = source[key];
      });
      Object.defineProperty(target, "message", {
        value: source.message
      });
      return target;
    }
    function inspectValue(val) {
      return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1e3,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
      });
    }
    function createErrDiff(actual, expected, operator) {
      var other = "";
      var res = "";
      var lastPos = 0;
      var end = "";
      var skipped = false;
      var actualInspected = inspectValue(actual);
      var actualLines = actualInspected.split("\n");
      var expectedLines = inspectValue(expected).split("\n");
      var i = 0;
      var indicator = "";
      if (operator === "strictEqual" && _typeof2(actual) === "object" && _typeof2(expected) === "object" && actual !== null && expected !== null) {
        operator = "strictEqualObject";
      }
      if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length;
        if (inputLength <= kMaxShortLength) {
          if ((_typeof2(actual) !== "object" || actual === null) && (_typeof2(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
          }
        } else if (operator !== "strictEqualObject") {
          var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
          if (inputLength < maxLength) {
            while (actualLines[0][i] === expectedLines[0][i]) {
              i++;
            }
            if (i > 2) {
              indicator = "\n  ".concat(repeat(" ", i), "^");
              i = 0;
            }
          }
        }
      }
      var a = actualLines[actualLines.length - 1];
      var b = expectedLines[expectedLines.length - 1];
      while (a === b) {
        if (i++ < 2) {
          end = "\n  ".concat(a).concat(end);
        } else {
          other = a;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0)
          break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
      }
      var maxLines = Math.max(actualLines.length, expectedLines.length);
      if (maxLines === 0) {
        var _actualLines = actualInspected.split("\n");
        if (_actualLines.length > 30) {
          _actualLines[26] = "".concat(blue, "...").concat(white);
          while (_actualLines.length > 27) {
            _actualLines.pop();
          }
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
      }
      if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
      }
      if (other !== "") {
        end = "\n  ".concat(other).concat(end);
        other = "";
      }
      var printedLines = 0;
      var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
      var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
      for (i = 0; i < maxLines; i++) {
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(expectedLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(expectedLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
          printedLines++;
        } else if (expectedLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
          printedLines++;
        } else {
          var expectedLine = expectedLines[i];
          var actualLine = actualLines[i];
          var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
          if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
            divergingLines = false;
            actualLine += ",";
          }
          if (divergingLines) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
            printedLines += 2;
          } else {
            res += other;
            other = "";
            if (cur === 1 || i === 0) {
              res += "\n  ".concat(actualLine);
              printedLines++;
            }
          }
        }
        if (printedLines > 20 && i < maxLines - 2) {
          return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
        }
      }
      return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
    }
    var AssertionError = function(_Error) {
      _inherits2(AssertionError2, _Error);
      function AssertionError2(options) {
        var _this;
        _classCallCheck2(this, AssertionError2);
        if (_typeof2(options) !== "object" || options === null) {
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) {
          _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError2).call(this, String(message)));
        } else {
          if (process.stderr && process.stderr.isTTY) {
            if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
              blue = "\x1B[34m";
              green = "\x1B[32m";
              white = "\x1B[39m";
              red = "\x1B[31m";
            } else {
              blue = "";
              green = "";
              white = "";
              red = "";
            }
          }
          if (_typeof2(actual) === "object" && actual !== null && _typeof2(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
            actual = copyError(actual);
            expected = copyError(expected);
          }
          if (operator === "deepStrictEqual" || operator === "strictEqual") {
            _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError2).call(this, createErrDiff(actual, expected, operator)));
          } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
            var base = kReadableOperator[operator];
            var res = inspectValue(actual).split("\n");
            if (operator === "notStrictEqual" && _typeof2(actual) === "object" && actual !== null) {
              base = kReadableOperator.notStrictEqualObject;
            }
            if (res.length > 30) {
              res[26] = "".concat(blue, "...").concat(white);
              while (res.length > 27) {
                res.pop();
              }
            }
            if (res.length === 1) {
              _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError2).call(this, "".concat(base, " ").concat(res[0])));
            } else {
              _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError2).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
            }
          } else {
            var _res = inspectValue(actual);
            var other = "";
            var knownOperators = kReadableOperator[operator];
            if (operator === "notDeepEqual" || operator === "notEqual") {
              _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
              if (_res.length > 1024) {
                _res = "".concat(_res.slice(0, 1021), "...");
              }
            } else {
              other = "".concat(inspectValue(expected));
              if (_res.length > 512) {
                _res = "".concat(_res.slice(0, 509), "...");
              }
              if (other.length > 512) {
                other = "".concat(other.slice(0, 509), "...");
              }
              if (operator === "deepEqual" || operator === "equal") {
                _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
              } else {
                other = " ".concat(operator, " ").concat(other);
              }
            }
            _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError2).call(this, "".concat(_res).concat(other)));
          }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized2(_this), "name", {
          value: "AssertionError [ERR_ASSERTION]",
          enumerable: false,
          writable: true,
          configurable: true
        });
        _this.code = "ERR_ASSERTION";
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized2(_this), stackStartFn);
        }
        _this.stack;
        _this.name = "AssertionError";
        return _possibleConstructorReturn2(_this);
      }
      _createClass2(AssertionError2, [{
        key: "toString",
        value: function toString() {
          return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
        }
      }, {
        key: inspect.custom,
        value: function value(recurseTimes, ctx) {
          return inspect(this, _objectSpread2({}, ctx, {
            customInspect: false,
            depth: 0
          }));
        }
      }]);
      return AssertionError2;
    }(_wrapNativeSuper(Error));
    module.exports = AssertionError;
  }
});

// node_modules/es6-object-assign/index.js
var require_es6_object_assign = __commonJS({
  "node_modules/es6-object-assign/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function assign(target, firstSource) {
      if (target === void 0 || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === void 0 || nextSource === null) {
          continue;
        }
        var keysArray = Object.keys(Object(nextSource));
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
    function polyfill() {
      if (!Object.assign) {
        Object.defineProperty(Object, "assign", {
          enumerable: false,
          configurable: true,
          writable: true,
          value: assign
        });
      }
    }
    module.exports = {
      assign,
      polyfill
    };
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/object-is/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/object-is/implementation.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module.exports = function is(a, b) {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      }
      if (a === b) {
        return true;
      }
      if (numberIsNaN(a) && numberIsNaN(b)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/object-is/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/object-is/polyfill.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// node_modules/object-is/shim.js
var require_shim = __commonJS({
  "node_modules/object-is/shim.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var getPolyfill = require_polyfill();
    var define2 = require_define_properties();
    module.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object-is/index.js
var require_object_is = __commonJS({
  "node_modules/object-is/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// node_modules/is-nan/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/is-nan/implementation.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = function isNaN2(value) {
      return value !== value;
    };
  }
});

// node_modules/is-nan/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/is-nan/polyfill.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var implementation = require_implementation4();
    module.exports = function getPolyfill() {
      if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
        return Number.isNaN;
      }
      return implementation;
    };
  }
});

// node_modules/is-nan/shim.js
var require_shim2 = __commonJS({
  "node_modules/is-nan/shim.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill2();
    module.exports = function shimNumberIsNaN() {
      var polyfill = getPolyfill();
      define2(Number, { isNaN: polyfill }, {
        isNaN: function testIsNaN() {
          return Number.isNaN !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/is-nan/index.js
var require_is_nan = __commonJS({
  "node_modules/is-nan/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var callBind = require_call_bind();
    var define2 = require_define_properties();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var polyfill = callBind(getPolyfill(), Number);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// node_modules/assert/build/internal/util/comparisons.js
var require_comparisons = __commonJS({
  "node_modules/assert/build/internal/util/comparisons.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _typeof2(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    var regexFlagsSupported = /a/g.flags !== void 0;
    var arrayFromSet = function arrayFromSet2(set) {
      var array = [];
      set.forEach(function(value) {
        return array.push(value);
      });
      return array;
    };
    var arrayFromMap = function arrayFromMap2(map) {
      var array = [];
      map.forEach(function(value, key) {
        return array.push([key, value]);
      });
      return array;
    };
    var objectIs = Object.is ? Object.is : require_object_is();
    var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
    var objectToString = uncurryThis(Object.prototype.toString);
    var _require$types = require_util2().types;
    var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
    var isArrayBufferView = _require$types.isArrayBufferView;
    var isDate = _require$types.isDate;
    var isMap = _require$types.isMap;
    var isRegExp = _require$types.isRegExp;
    var isSet = _require$types.isSet;
    var isNativeError = _require$types.isNativeError;
    var isBoxedPrimitive = _require$types.isBoxedPrimitive;
    var isNumberObject = _require$types.isNumberObject;
    var isStringObject = _require$types.isStringObject;
    var isBooleanObject = _require$types.isBooleanObject;
    var isBigIntObject = _require$types.isBigIntObject;
    var isSymbolObject = _require$types.isSymbolObject;
    var isFloat32Array = _require$types.isFloat32Array;
    var isFloat64Array = _require$types.isFloat64Array;
    function isNonIndex(key) {
      if (key.length === 0 || key.length > 10)
        return true;
      for (var i = 0; i < key.length; i++) {
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57)
          return true;
      }
      return key.length === 10 && key >= Math.pow(2, 32);
    }
    function getOwnNonIndexProperties(value) {
      return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
    }
    function compare(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    var ONLY_ENUMERABLE = void 0;
    var kStrict = true;
    var kLoose = false;
    var kNoIterator = 0;
    var kIsArray = 1;
    var kIsSet = 2;
    var kIsMap = 3;
    function areSimilarRegExps(a, b) {
      return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
    }
    function areSimilarFloatArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (var offset = 0; offset < a.byteLength; offset++) {
        if (a[offset] !== b[offset]) {
          return false;
        }
      }
      return true;
    }
    function areSimilarTypedArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
    }
    function areEqualArrayBuffers(buf1, buf2) {
      return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
    }
    function isEqualBoxedPrimitive(val1, val2) {
      if (isNumberObject(val1)) {
        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
      }
      if (isStringObject(val1)) {
        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
      }
      if (isBooleanObject(val1)) {
        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
      }
      if (isBigIntObject(val1)) {
        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
      }
      return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
    }
    function innerDeepEqual(val1, val2, strict, memos) {
      if (val1 === val2) {
        if (val1 !== 0)
          return true;
        return strict ? objectIs(val1, val2) : true;
      }
      if (strict) {
        if (_typeof2(val1) !== "object") {
          return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
        }
        if (_typeof2(val2) !== "object" || val1 === null || val2 === null) {
          return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
          return false;
        }
      } else {
        if (val1 === null || _typeof2(val1) !== "object") {
          if (val2 === null || _typeof2(val2) !== "object") {
            return val1 == val2;
          }
          return false;
        }
        if (val2 === null || _typeof2(val2) !== "object") {
          return false;
        }
      }
      var val1Tag = objectToString(val1);
      var val2Tag = objectToString(val2);
      if (val1Tag !== val2Tag) {
        return false;
      }
      if (Array.isArray(val1)) {
        if (val1.length !== val2.length) {
          return false;
        }
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
      }
      if (val1Tag === "[object Object]") {
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
          return false;
        }
      }
      if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
          return false;
        }
      } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
          return false;
        }
      } else if (isNativeError(val1) || val1 instanceof Error) {
        if (val1.message !== val2.message || val1.name !== val2.name) {
          return false;
        }
      } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
          if (!areSimilarFloatArrays(val1, val2)) {
            return false;
          }
        } else if (!areSimilarTypedArrays(val1, val2)) {
          return false;
        }
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
      } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsSet);
      } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsMap);
      } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) {
          return false;
        }
      } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator);
    }
    function getEnumerables(val, keys) {
      return keys.filter(function(k) {
        return propertyIsEnumerable(val, k);
      });
    }
    function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
      if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
      }
      var i = 0;
      for (; i < aKeys.length; i++) {
        if (!hasOwnProperty(val2, aKeys[i])) {
          return false;
        }
      }
      if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
          var count = 0;
          for (i = 0; i < symbolKeysA.length; i++) {
            var key = symbolKeysA[i];
            if (propertyIsEnumerable(val1, key)) {
              if (!propertyIsEnumerable(val2, key)) {
                return false;
              }
              aKeys.push(key);
              count++;
            } else if (propertyIsEnumerable(val2, key)) {
              return false;
            }
          }
          var symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
            return false;
          }
        } else {
          var _symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
            return false;
          }
        }
      }
      if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
        return true;
      }
      if (memos === void 0) {
        memos = {
          val1: /* @__PURE__ */ new Map(),
          val2: /* @__PURE__ */ new Map(),
          position: 0
        };
      } else {
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== void 0) {
          var val2MemoB = memos.val2.get(val2);
          if (val2MemoB !== void 0) {
            return val2MemoA === val2MemoB;
          }
        }
        memos.position++;
      }
      memos.val1.set(val1, memos.position);
      memos.val2.set(val2, memos.position);
      var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
      memos.val1.delete(val1);
      memos.val2.delete(val2);
      return areEq;
    }
    function setHasEqualElement(set, val1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo)) {
          set.delete(val2);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      switch (_typeof2(prim)) {
        case "undefined":
          return null;
        case "object":
          return void 0;
        case "symbol":
          return false;
        case "string":
          prim = +prim;
        case "number":
          if (numberIsNaN(prim)) {
            return false;
          }
      }
      return true;
    }
    function setMightHaveLoosePrim(a, b, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null)
        return altValue;
      return b.has(altValue) && !a.has(altValue);
    }
    function mapMightHaveLoosePrim(a, b, prim, item, memo) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = b.get(altValue);
      if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
      }
      return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
    }
    function setEquiv(a, b, strict, memo) {
      var set = null;
      var aValues = arrayFromSet(a);
      for (var i = 0; i < aValues.length; i++) {
        var val = aValues[i];
        if (_typeof2(val) === "object" && val !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        } else if (!b.has(val)) {
          if (strict)
            return false;
          if (!setMightHaveLoosePrim(a, b, val)) {
            return false;
          }
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        }
      }
      if (set !== null) {
        var bValues = arrayFromSet(b);
        for (var _i = 0; _i < bValues.length; _i++) {
          var _val = bValues[_i];
          if (_typeof2(_val) === "object" && _val !== null) {
            if (!setHasEqualElement(set, _val, strict, memo))
              return false;
          } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
          set.delete(key2);
          return true;
        }
      }
      return false;
    }
    function mapEquiv(a, b, strict, memo) {
      var set = null;
      var aEntries = arrayFromMap(a);
      for (var i = 0; i < aEntries.length; i++) {
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof2(key) === "object" && key !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key);
        } else {
          var item2 = b.get(key);
          if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
            if (strict)
              return false;
            if (!mapMightHaveLoosePrim(a, b, key, item1, memo))
              return false;
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          }
        }
      }
      if (set !== null) {
        var bEntries = arrayFromMap(b);
        for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
          var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
          if (_typeof2(key) === "object" && key !== null) {
            if (!mapHasEqualEntry(set, a, key, item, strict, memo))
              return false;
          } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function objEquiv(a, b, strict, keys, memos, iterationType) {
      var i = 0;
      if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsArray) {
        for (; i < a.length; i++) {
          if (hasOwnProperty(a, i)) {
            if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
              return false;
            }
          } else if (hasOwnProperty(b, i)) {
            return false;
          } else {
            var keysA = Object.keys(a);
            for (; i < keysA.length; i++) {
              var key = keysA[i];
              if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                return false;
              }
            }
            if (keysA.length !== Object.keys(b).length) {
              return false;
            }
            return true;
          }
        }
      }
      for (i = 0; i < keys.length; i++) {
        var _key = keys[i];
        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
          return false;
        }
      }
      return true;
    }
    function isDeepEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kLoose);
    }
    function isDeepStrictEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kStrict);
    }
    module.exports = {
      isDeepEqual,
      isDeepStrictEqual
    };
  }
});

// node_modules/assert/build/assert.js
var require_assert = __commonJS({
  "node_modules/assert/build/assert.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    function _typeof2(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof2 = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof2(obj);
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _require = require_errors();
    var _require$codes = _require.codes;
    var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
    var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var AssertionError = require_assertion_error();
    var _require2 = require_util2();
    var inspect = _require2.inspect;
    var _require$types = require_util2().types;
    var isPromise = _require$types.isPromise;
    var isRegExp = _require$types.isRegExp;
    var objectAssign = Object.assign ? Object.assign : require_es6_object_assign().assign;
    var objectIs = Object.is ? Object.is : require_object_is();
    var isDeepEqual;
    var isDeepStrictEqual;
    function lazyLoadComparison() {
      var comparison = require_comparisons();
      isDeepEqual = comparison.isDeepEqual;
      isDeepStrictEqual = comparison.isDeepStrictEqual;
    }
    var warned = false;
    var assert2 = module.exports = ok;
    var NO_EXCEPTION_SENTINEL = {};
    function innerFail(obj) {
      if (obj.message instanceof Error)
        throw obj.message;
      throw new AssertionError(obj);
    }
    function fail(actual, expected, message, operator, stackStartFn) {
      var argsLen = arguments.length;
      var internalMessage;
      if (argsLen === 0) {
        internalMessage = "Failed";
      } else if (argsLen === 1) {
        message = actual;
        actual = void 0;
      } else {
        if (warned === false) {
          warned = true;
          var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
          warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2)
          operator = "!=";
      }
      if (message instanceof Error)
        throw message;
      var errArgs = {
        actual,
        expected,
        operator: operator === void 0 ? "fail" : operator,
        stackStartFn: stackStartFn || fail
      };
      if (message !== void 0) {
        errArgs.message = message;
      }
      var err = new AssertionError(errArgs);
      if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
      }
      throw err;
    }
    assert2.fail = fail;
    assert2.AssertionError = AssertionError;
    function innerOk(fn, argLen, value, message) {
      if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
          generatedMessage = true;
          message = "No value argument passed to `assert.ok()`";
        } else if (message instanceof Error) {
          throw message;
        }
        var err = new AssertionError({
          actual: value,
          expected: true,
          message,
          operator: "==",
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    function ok() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      innerOk.apply(void 0, [ok, args.length].concat(args));
    }
    assert2.ok = ok;
    assert2.equal = function equal(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual != expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "==",
          stackStartFn: equal
        });
      }
    };
    assert2.notEqual = function notEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual == expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "!=",
          stackStartFn: notEqual
        });
      }
    };
    assert2.deepEqual = function deepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (!isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepEqual",
          stackStartFn: deepEqual
        });
      }
    };
    assert2.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepEqual",
          stackStartFn: notDeepEqual
        });
      }
    };
    assert2.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (!isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepStrictEqual",
          stackStartFn: deepStrictEqual
        });
      }
    };
    assert2.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepStrictEqual",
          stackStartFn: notDeepStrictEqual
        });
      }
    }
    assert2.strictEqual = function strictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (!objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "strictEqual",
          stackStartFn: strictEqual
        });
      }
    };
    assert2.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notStrictEqual",
          stackStartFn: notStrictEqual
        });
      }
    };
    var Comparison = function Comparison2(obj, keys, actual) {
      var _this = this;
      _classCallCheck2(this, Comparison2);
      keys.forEach(function(key) {
        if (key in obj) {
          if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) {
            _this[key] = actual[key];
          } else {
            _this[key] = obj[key];
          }
        }
      });
    };
    function compareExceptionKey(actual, expected, key, message, keys, fn) {
      if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
          var a = new Comparison(actual, keys);
          var b = new Comparison(expected, keys, actual);
          var err = new AssertionError({
            actual: a,
            expected: b,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.actual = actual;
          err.expected = expected;
          err.operator = fn.name;
          throw err;
        }
        innerFail({
          actual,
          expected,
          message,
          operator: fn.name,
          stackStartFn: fn
        });
      }
    }
    function expectedException(actual, expected, msg, fn) {
      if (typeof expected !== "function") {
        if (isRegExp(expected))
          return expected.test(actual);
        if (arguments.length === 2) {
          throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
        }
        if (_typeof2(actual) !== "object" || actual === null) {
          var err = new AssertionError({
            actual,
            expected,
            message: msg,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.operator = fn.name;
          throw err;
        }
        var keys = Object.keys(expected);
        if (expected instanceof Error) {
          keys.push("name", "message");
        } else if (keys.length === 0) {
          throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        keys.forEach(function(key) {
          if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) {
            return;
          }
          compareExceptionKey(actual, expected, key, msg, keys, fn);
        });
        return true;
      }
      if (expected.prototype !== void 0 && actual instanceof expected) {
        return true;
      }
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function getActual(fn) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
      }
      try {
        fn();
      } catch (e) {
        return e;
      }
      return NO_EXCEPTION_SENTINEL;
    }
    function checkIsPromise(obj) {
      return isPromise(obj) || obj !== null && _typeof2(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
    }
    function waitForActual(promiseFn) {
      return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
          resultPromise = promiseFn();
          if (!checkIsPromise(resultPromise)) {
            throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
          }
        } else if (checkIsPromise(promiseFn)) {
          resultPromise = promiseFn;
        } else {
          throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
        }
        return Promise.resolve().then(function() {
          return resultPromise;
        }).then(function() {
          return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
          return e;
        });
      });
    }
    function expectsError(stackStartFn, actual, error, message) {
      if (typeof error === "string") {
        if (arguments.length === 4) {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (_typeof2(actual) === "object" && actual !== null) {
          if (actual.message === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
          }
        } else if (actual === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        }
        message = error;
        error = void 0;
      } else if (error != null && _typeof2(error) !== "object" && typeof error !== "function") {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name) {
          details += " (".concat(error.name, ")");
        }
        details += message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({
          actual: void 0,
          expected: error,
          operator: stackStartFn.name,
          message: "Missing expected ".concat(fnType).concat(details),
          stackStartFn
        });
      }
      if (error && !expectedException(actual, error, message, stackStartFn)) {
        throw actual;
      }
    }
    function expectsNoError(stackStartFn, actual, error, message) {
      if (actual === NO_EXCEPTION_SENTINEL)
        return;
      if (typeof error === "string") {
        message = error;
        error = void 0;
      }
      if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({
          actual,
          expected: error,
          operator: stackStartFn.name,
          message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
          stackStartFn
        });
      }
      throw actual;
    }
    assert2.throws = function throws(promiseFn) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
    };
    assert2.rejects = function rejects(promiseFn) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [rejects, result].concat(args));
      });
    };
    assert2.doesNotThrow = function doesNotThrow(fn) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
    };
    assert2.doesNotReject = function doesNotReject(fn) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
      });
    };
    assert2.ifError = function ifError(err) {
      if (err !== null && err !== void 0) {
        var message = "ifError got unwanted exception: ";
        if (_typeof2(err) === "object" && typeof err.message === "string") {
          if (err.message.length === 0 && err.constructor) {
            message += err.constructor.name;
          } else {
            message += err.message;
          }
        } else {
          message += inspect(err);
        }
        var newErr = new AssertionError({
          actual: err,
          expected: null,
          operator: "ifError",
          message,
          stackStartFn: ifError
        });
        var origStack = err.stack;
        if (typeof origStack === "string") {
          var tmp2 = origStack.split("\n");
          tmp2.shift();
          var tmp1 = newErr.stack.split("\n");
          for (var i = 0; i < tmp2.length; i++) {
            var pos = tmp1.indexOf(tmp2[i]);
            if (pos !== -1) {
              tmp1 = tmp1.slice(0, pos);
              break;
            }
          }
          newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
        }
        throw newErr;
      }
    };
    function strict() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      innerOk.apply(void 0, [strict, args.length].concat(args));
    }
    assert2.strict = objectAssign(strict, assert2, {
      equal: assert2.strictEqual,
      deepEqual: assert2.deepStrictEqual,
      notEqual: assert2.notStrictEqual,
      notDeepEqual: assert2.notDeepStrictEqual
    });
    assert2.strict.strict = assert2.strict;
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/jsonschema/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/jsonschema/lib/helpers.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var uri = require_url();
    var ValidationError = exports.ValidationError = function ValidationError2(message, instance, schema, path, name, argument) {
      if (Array.isArray(path)) {
        this.path = path;
        this.property = path.reduce(function(sum, item) {
          return sum + makeSuffix(item);
        }, "instance");
      } else if (path !== void 0) {
        this.property = path;
      }
      if (message) {
        this.message = message;
      }
      if (schema) {
        var id = schema.$id || schema.id;
        this.schema = id || schema;
      }
      if (instance !== void 0) {
        this.instance = instance;
      }
      this.name = name;
      this.argument = argument;
      this.stack = this.toString();
    };
    ValidationError.prototype.toString = function toString() {
      return this.property + " " + this.message;
    };
    var ValidatorResult = exports.ValidatorResult = function ValidatorResult2(instance, schema, options, ctx) {
      this.instance = instance;
      this.schema = schema;
      this.options = options;
      this.path = ctx.path;
      this.propertyPath = ctx.propertyPath;
      this.errors = [];
      this.throwError = options && options.throwError;
      this.throwFirst = options && options.throwFirst;
      this.throwAll = options && options.throwAll;
      this.disableFormat = options && options.disableFormat === true;
    };
    ValidatorResult.prototype.addError = function addError(detail) {
      var err;
      if (typeof detail == "string") {
        err = new ValidationError(detail, this.instance, this.schema, this.path);
      } else {
        if (!detail)
          throw new Error("Missing error detail");
        if (!detail.message)
          throw new Error("Missing error message");
        if (!detail.name)
          throw new Error("Missing validator type");
        err = new ValidationError(detail.message, this.instance, this.schema, this.path, detail.name, detail.argument);
      }
      this.errors.push(err);
      if (this.throwFirst) {
        throw new ValidatorResultError(this);
      } else if (this.throwError) {
        throw err;
      }
      return err;
    };
    ValidatorResult.prototype.importErrors = function importErrors(res) {
      if (typeof res == "string" || res && res.validatorType) {
        this.addError(res);
      } else if (res && res.errors) {
        this.errors = this.errors.concat(res.errors);
      }
    };
    function stringizer(v, i) {
      return i + ": " + v.toString() + "\n";
    }
    ValidatorResult.prototype.toString = function toString(res) {
      return this.errors.map(stringizer).join("");
    };
    Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
      return !this.errors.length;
    } });
    module.exports.ValidatorResultError = ValidatorResultError;
    function ValidatorResultError(result) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ValidatorResultError);
      }
      this.instance = result.instance;
      this.schema = result.schema;
      this.options = result.options;
      this.errors = result.errors;
    }
    ValidatorResultError.prototype = new Error();
    ValidatorResultError.prototype.constructor = ValidatorResultError;
    ValidatorResultError.prototype.name = "Validation Error";
    var SchemaError = exports.SchemaError = function SchemaError2(msg, schema) {
      this.message = msg;
      this.schema = schema;
      Error.call(this, msg);
      Error.captureStackTrace(this, SchemaError2);
    };
    SchemaError.prototype = Object.create(
      Error.prototype,
      {
        constructor: { value: SchemaError, enumerable: false },
        name: { value: "SchemaError", enumerable: false }
      }
    );
    var SchemaContext = exports.SchemaContext = function SchemaContext2(schema, options, path, base, schemas) {
      this.schema = schema;
      this.options = options;
      if (Array.isArray(path)) {
        this.path = path;
        this.propertyPath = path.reduce(function(sum, item) {
          return sum + makeSuffix(item);
        }, "instance");
      } else {
        this.propertyPath = path;
      }
      this.base = base;
      this.schemas = schemas;
    };
    SchemaContext.prototype.resolve = function resolve(target) {
      return uri.resolve(this.base, target);
    };
    SchemaContext.prototype.makeChild = function makeChild(schema, propertyName) {
      var path = propertyName === void 0 ? this.path : this.path.concat([propertyName]);
      var id = schema.$id || schema.id;
      var base = uri.resolve(this.base, id || "");
      var ctx = new SchemaContext(schema, this.options, path, base, Object.create(this.schemas));
      if (id && !ctx.schemas[base]) {
        ctx.schemas[base] = schema;
      }
      return ctx;
    };
    var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
      // 7.3.1. Dates, Times, and Duration
      "date-time": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
      "date": /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
      "time": /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,
      "duration": /P(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S)|\d+(D|M(\d+D)?|Y(\d+M(\d+D)?)?)(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S))?|\d+W)/i,
      // 7.3.2. Email Addresses
      // TODO: fix the email production
      "email": /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
      "idn-email": /^("(?:[!#-\[\]-\u{10FFFF}]|\\[\t -\u{10FFFF}])*"|[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*)@([!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*|\[[!-Z\^-\u{10FFFF}]*\])$/u,
      // 7.3.3. Hostnames
      // 7.3.4. IP Addresses
      "ip-address": /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
      // FIXME whitespace is invalid
      "ipv6": /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
      // 7.3.5. Resource Identifiers
      // TODO: A more accurate regular expression for "uri" goes:
      // [A-Za-z][+\-.0-9A-Za-z]*:((/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?)?#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])|/?%[0-9A-Fa-f]{2}|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*(#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?)?
      "uri": /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
      "uri-reference": /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/,
      "iri": /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
      "iri-reference": /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~-\u{10FFFF}]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~-\u{10FFFF}])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/u,
      "uuid": /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
      // 7.3.6. uri-template
      "uri-template": /(%[0-9a-f]{2}|[!#$&(-;=?@\[\]_a-z~]|\{[!#&+,./;=?@|]?(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?(,(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?)*\})*/iu,
      // 7.3.7. JSON Pointers
      "json-pointer": /^(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*$/iu,
      "relative-json-pointer": /^\d+(#|(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*)$/iu,
      // hostname regex from: http://stackoverflow.com/a/1420225/5628
      "hostname": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
      "host-name": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
      "utc-millisec": function(input) {
        return typeof input === "string" && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
      },
      // 7.3.8. regex
      "regex": function(input) {
        var result = true;
        try {
          new RegExp(input);
        } catch (e) {
          result = false;
        }
        return result;
      },
      // Other definitions
      // "style" was removed from JSON Schema in draft-4 and is deprecated
      "style": /[\r\n\t ]*[^\r\n\t ][^:]*:[\r\n\t ]*[^\r\n\t ;]*[\r\n\t ]*;?/,
      // "color" was removed from JSON Schema in draft-4 and is deprecated
      "color": /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,
      "phone": /^\+(?:[0-9] ?){6,14}[0-9]$/,
      "alpha": /^[a-zA-Z]+$/,
      "alphanumeric": /^[a-zA-Z0-9]+$/
    };
    FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
    FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
    FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS["ip-address"];
    exports.isFormat = function isFormat(input, format, validator) {
      if (typeof input === "string" && FORMAT_REGEXPS[format] !== void 0) {
        if (FORMAT_REGEXPS[format] instanceof RegExp) {
          return FORMAT_REGEXPS[format].test(input);
        }
        if (typeof FORMAT_REGEXPS[format] === "function") {
          return FORMAT_REGEXPS[format](input);
        }
      } else if (validator && validator.customFormats && typeof validator.customFormats[format] === "function") {
        return validator.customFormats[format](input);
      }
      return true;
    };
    var makeSuffix = exports.makeSuffix = function makeSuffix2(key) {
      key = key.toString();
      if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
        return "." + key;
      }
      if (key.match(/^\d+$/)) {
        return "[" + key + "]";
      }
      return "[" + JSON.stringify(key) + "]";
    };
    exports.deepCompareStrict = function deepCompareStrict(a, b) {
      if (typeof a !== typeof b) {
        return false;
      }
      if (Array.isArray(a)) {
        if (!Array.isArray(b)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        return a.every(function(v, i) {
          return deepCompareStrict(a[i], b[i]);
        });
      }
      if (typeof a === "object") {
        if (!a || !b) {
          return a === b;
        }
        var aKeys = Object.keys(a);
        var bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
        return aKeys.every(function(v) {
          return deepCompareStrict(a[v], b[v]);
        });
      }
      return a === b;
    };
    function deepMerger(target, dst, e, i) {
      if (typeof e === "object") {
        dst[i] = deepMerge(target[i], e);
      } else {
        if (target.indexOf(e) === -1) {
          dst.push(e);
        }
      }
    }
    function copyist(src, dst, key) {
      dst[key] = src[key];
    }
    function copyistWithDeepMerge(target, src, dst, key) {
      if (typeof src[key] !== "object" || !src[key]) {
        dst[key] = src[key];
      } else {
        if (!target[key]) {
          dst[key] = src[key];
        } else {
          dst[key] = deepMerge(target[key], src[key]);
        }
      }
    }
    function deepMerge(target, src) {
      var array = Array.isArray(src);
      var dst = array && [] || {};
      if (array) {
        target = target || [];
        dst = dst.concat(target);
        src.forEach(deepMerger.bind(null, target, dst));
      } else {
        if (target && typeof target === "object") {
          Object.keys(target).forEach(copyist.bind(null, target, dst));
        }
        Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
      }
      return dst;
    }
    module.exports.deepMerge = deepMerge;
    exports.objectGetPath = function objectGetPath(o, s) {
      var parts = s.split("/").slice(1);
      var k;
      while (typeof (k = parts.shift()) == "string") {
        var n = decodeURIComponent(k.replace(/~0/, "~").replace(/~1/g, "/"));
        if (!(n in o))
          return;
        o = o[n];
      }
      return o;
    };
    function pathEncoder(v) {
      return "/" + encodeURIComponent(v).replace(/~/g, "%7E");
    }
    exports.encodePath = function encodePointer(a) {
      return a.map(pathEncoder).join("");
    };
    exports.getDecimalPlaces = function getDecimalPlaces(number) {
      var decimalPlaces = 0;
      if (isNaN(number))
        return decimalPlaces;
      if (typeof number !== "number") {
        number = Number(number);
      }
      var parts = number.toString().split("e");
      if (parts.length === 2) {
        if (parts[1][0] !== "-") {
          return decimalPlaces;
        } else {
          decimalPlaces = Number(parts[1].slice(1));
        }
      }
      var decimalParts = parts[0].split(".");
      if (decimalParts.length === 2) {
        decimalPlaces += decimalParts[1].length;
      }
      return decimalPlaces;
    };
    exports.isSchema = function isSchema(val) {
      return typeof val === "object" && val || typeof val === "boolean";
    };
  }
});

// node_modules/jsonschema/lib/attribute.js
var require_attribute = __commonJS({
  "node_modules/jsonschema/lib/attribute.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var helpers = require_helpers();
    var ValidatorResult = helpers.ValidatorResult;
    var SchemaError = helpers.SchemaError;
    var attribute = {};
    attribute.ignoreProperties = {
      // informative properties
      "id": true,
      "default": true,
      "description": true,
      "title": true,
      // arguments to other properties
      "additionalItems": true,
      "then": true,
      "else": true,
      // special-handled properties
      "$schema": true,
      "$ref": true,
      "extends": true
    };
    var validators = attribute.validators = {};
    validators.type = function validateType(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var types = Array.isArray(schema.type) ? schema.type : [schema.type];
      if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
        var list = types.map(function(v) {
          if (!v)
            return;
          var id = v.$id || v.id;
          return id ? "<" + id + ">" : v + "";
        });
        result.addError({
          name: "type",
          argument: list,
          message: "is not of a type(s) " + list
        });
      }
      return result;
    };
    function testSchemaNoThrow(instance, options, ctx, callback, schema) {
      var throwError = options.throwError;
      var throwAll = options.throwAll;
      options.throwError = false;
      options.throwAll = false;
      var res = this.validateSchema(instance, schema, options, ctx);
      options.throwError = throwError;
      options.throwAll = throwAll;
      if (!res.valid && callback instanceof Function) {
        callback(res);
      }
      return res.valid;
    }
    validators.anyOf = function validateAnyOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var inner = new ValidatorResult(instance, schema, options, ctx);
      if (!Array.isArray(schema.anyOf)) {
        throw new SchemaError("anyOf must be an array");
      }
      if (!schema.anyOf.some(
        testSchemaNoThrow.bind(
          this,
          instance,
          options,
          ctx,
          function(res) {
            inner.importErrors(res);
          }
        )
      )) {
        var list = schema.anyOf.map(function(v, i) {
          var id = v.$id || v.id;
          if (id)
            return "<" + id + ">";
          return v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
        });
        if (options.nestedErrors) {
          result.importErrors(inner);
        }
        result.addError({
          name: "anyOf",
          argument: list,
          message: "is not any of " + list.join(",")
        });
      }
      return result;
    };
    validators.allOf = function validateAllOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema.allOf)) {
        throw new SchemaError("allOf must be an array");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var self2 = this;
      schema.allOf.forEach(function(v, i) {
        var valid = self2.validateSchema(instance, v, options, ctx);
        if (!valid.valid) {
          var id = v.$id || v.id;
          var msg = id || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
          result.addError({
            name: "allOf",
            argument: { id: msg, length: valid.errors.length, valid },
            message: "does not match allOf schema " + msg + " with " + valid.errors.length + " error[s]:"
          });
          result.importErrors(valid);
        }
      });
      return result;
    };
    validators.oneOf = function validateOneOf(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema.oneOf)) {
        throw new SchemaError("oneOf must be an array");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var inner = new ValidatorResult(instance, schema, options, ctx);
      var count = schema.oneOf.filter(
        testSchemaNoThrow.bind(
          this,
          instance,
          options,
          ctx,
          function(res) {
            inner.importErrors(res);
          }
        )
      ).length;
      var list = schema.oneOf.map(function(v, i) {
        var id = v.$id || v.id;
        return id || v.title && JSON.stringify(v.title) || v["$ref"] && "<" + v["$ref"] + ">" || "[subschema " + i + "]";
      });
      if (count !== 1) {
        if (options.nestedErrors) {
          result.importErrors(inner);
        }
        result.addError({
          name: "oneOf",
          argument: list,
          message: "is not exactly one from " + list.join(",")
        });
      }
      return result;
    };
    validators.if = function validateIf(instance, schema, options, ctx) {
      if (instance === void 0)
        return null;
      if (!helpers.isSchema(schema.if))
        throw new Error('Expected "if" keyword to be a schema');
      var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);
      var result = new ValidatorResult(instance, schema, options, ctx);
      var res;
      if (ifValid) {
        if (schema.then === void 0)
          return;
        if (!helpers.isSchema(schema.then))
          throw new Error('Expected "then" keyword to be a schema');
        res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));
        result.importErrors(res);
      } else {
        if (schema.else === void 0)
          return;
        if (!helpers.isSchema(schema.else))
          throw new Error('Expected "else" keyword to be a schema');
        res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));
        result.importErrors(res);
      }
      return result;
    };
    function getEnumerableProperty(object, key) {
      if (Object.hasOwnProperty.call(object, key))
        return object[key];
      if (!(key in object))
        return;
      while (object = Object.getPrototypeOf(object)) {
        if (Object.propertyIsEnumerable.call(object, key))
          return object[key];
      }
    }
    validators.propertyNames = function validatePropertyNames(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var subschema = schema.propertyNames !== void 0 ? schema.propertyNames : {};
      if (!helpers.isSchema(subschema))
        throw new SchemaError('Expected "propertyNames" to be a schema (object or boolean)');
      for (var property in instance) {
        if (getEnumerableProperty(instance, property) !== void 0) {
          var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));
          result.importErrors(res);
        }
      }
      return result;
    };
    validators.properties = function validateProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var properties = schema.properties || {};
      for (var property in properties) {
        var subschema = properties[property];
        if (subschema === void 0) {
          continue;
        } else if (subschema === null) {
          throw new SchemaError('Unexpected null, expected schema in "properties"');
        }
        if (typeof options.preValidateProperty == "function") {
          options.preValidateProperty(instance, property, subschema, options, ctx);
        }
        var prop = getEnumerableProperty(instance, property);
        var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));
        if (res.instance !== result.instance[property])
          result.instance[property] = res.instance;
        result.importErrors(res);
      }
      return result;
    };
    function testAdditionalProperty(instance, schema, options, ctx, property, result) {
      if (!this.types.object(instance))
        return;
      if (schema.properties && schema.properties[property] !== void 0) {
        return;
      }
      if (schema.additionalProperties === false) {
        result.addError({
          name: "additionalProperties",
          argument: property,
          message: "is not allowed to have the additional property " + JSON.stringify(property)
        });
      } else {
        var additionalProperties = schema.additionalProperties || {};
        if (typeof options.preValidateProperty == "function") {
          options.preValidateProperty(instance, property, additionalProperties, options, ctx);
        }
        var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
        if (res.instance !== result.instance[property])
          result.instance[property] = res.instance;
        result.importErrors(res);
      }
    }
    validators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var patternProperties = schema.patternProperties || {};
      for (var property in instance) {
        var test = true;
        for (var pattern in patternProperties) {
          var subschema = patternProperties[pattern];
          if (subschema === void 0) {
            continue;
          } else if (subschema === null) {
            throw new SchemaError('Unexpected null, expected schema in "patternProperties"');
          }
          try {
            var regexp = new RegExp(pattern, "u");
          } catch (_e) {
            regexp = new RegExp(pattern);
          }
          if (!regexp.test(property)) {
            continue;
          }
          test = false;
          if (typeof options.preValidateProperty == "function") {
            options.preValidateProperty(instance, property, subschema, options, ctx);
          }
          var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));
          if (res.instance !== result.instance[property])
            result.instance[property] = res.instance;
          result.importErrors(res);
        }
        if (test) {
          testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
        }
      }
      return result;
    };
    validators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      if (schema.patternProperties) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      for (var property in instance) {
        testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
      }
      return result;
    };
    validators.minProperties = function validateMinProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var keys = Object.keys(instance);
      if (!(keys.length >= schema.minProperties)) {
        result.addError({
          name: "minProperties",
          argument: schema.minProperties,
          message: "does not meet minimum property length of " + schema.minProperties
        });
      }
      return result;
    };
    validators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var keys = Object.keys(instance);
      if (!(keys.length <= schema.maxProperties)) {
        result.addError({
          name: "maxProperties",
          argument: schema.maxProperties,
          message: "does not meet maximum property length of " + schema.maxProperties
        });
      }
      return result;
    };
    validators.items = function validateItems(instance, schema, options, ctx) {
      var self2 = this;
      if (!this.types.array(instance))
        return;
      if (schema.items === void 0)
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      instance.every(function(value, i) {
        if (Array.isArray(schema.items)) {
          var items = schema.items[i] === void 0 ? schema.additionalItems : schema.items[i];
        } else {
          var items = schema.items;
        }
        if (items === void 0) {
          return true;
        }
        if (items === false) {
          result.addError({
            name: "items",
            message: "additionalItems not permitted"
          });
          return false;
        }
        var res = self2.validateSchema(value, items, options, ctx.makeChild(items, i));
        if (res.instance !== result.instance[i])
          result.instance[i] = res.instance;
        result.importErrors(res);
        return true;
      });
      return result;
    };
    validators.contains = function validateContains(instance, schema, options, ctx) {
      var self2 = this;
      if (!this.types.array(instance))
        return;
      if (schema.contains === void 0)
        return;
      if (!helpers.isSchema(schema.contains))
        throw new Error('Expected "contains" keyword to be a schema');
      var result = new ValidatorResult(instance, schema, options, ctx);
      var count = instance.some(function(value, i) {
        var res = self2.validateSchema(value, schema.contains, options, ctx.makeChild(schema.contains, i));
        return res.errors.length === 0;
      });
      if (count === false) {
        result.addError({
          name: "contains",
          argument: schema.contains,
          message: "must contain an item matching given schema"
        });
      }
      return result;
    };
    validators.minimum = function validateMinimum(instance, schema, options, ctx) {
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
        if (!(instance > schema.minimum)) {
          result.addError({
            name: "minimum",
            argument: schema.minimum,
            message: "must be greater than " + schema.minimum
          });
        }
      } else {
        if (!(instance >= schema.minimum)) {
          result.addError({
            name: "minimum",
            argument: schema.minimum,
            message: "must be greater than or equal to " + schema.minimum
          });
        }
      }
      return result;
    };
    validators.maximum = function validateMaximum(instance, schema, options, ctx) {
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
        if (!(instance < schema.maximum)) {
          result.addError({
            name: "maximum",
            argument: schema.maximum,
            message: "must be less than " + schema.maximum
          });
        }
      } else {
        if (!(instance <= schema.maximum)) {
          result.addError({
            name: "maximum",
            argument: schema.maximum,
            message: "must be less than or equal to " + schema.maximum
          });
        }
      }
      return result;
    };
    validators.exclusiveMinimum = function validateExclusiveMinimum(instance, schema, options, ctx) {
      if (typeof schema.exclusiveMinimum === "boolean")
        return;
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var valid = instance > schema.exclusiveMinimum;
      if (!valid) {
        result.addError({
          name: "exclusiveMinimum",
          argument: schema.exclusiveMinimum,
          message: "must be strictly greater than " + schema.exclusiveMinimum
        });
      }
      return result;
    };
    validators.exclusiveMaximum = function validateExclusiveMaximum(instance, schema, options, ctx) {
      if (typeof schema.exclusiveMaximum === "boolean")
        return;
      if (!this.types.number(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var valid = instance < schema.exclusiveMaximum;
      if (!valid) {
        result.addError({
          name: "exclusiveMaximum",
          argument: schema.exclusiveMaximum,
          message: "must be strictly less than " + schema.exclusiveMaximum
        });
      }
      return result;
    };
    var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy2(instance, schema, options, ctx, validationType, errorMessage) {
      if (!this.types.number(instance))
        return;
      var validationArgument = schema[validationType];
      if (validationArgument == 0) {
        throw new SchemaError(validationType + " cannot be zero");
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      var instanceDecimals = helpers.getDecimalPlaces(instance);
      var divisorDecimals = helpers.getDecimalPlaces(validationArgument);
      var maxDecimals = Math.max(instanceDecimals, divisorDecimals);
      var multiplier = Math.pow(10, maxDecimals);
      if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {
        result.addError({
          name: validationType,
          argument: validationArgument,
          message: errorMessage + JSON.stringify(validationArgument)
        });
      }
      return result;
    };
    validators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {
      return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "multipleOf", "is not a multiple of (divisible by) ");
    };
    validators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {
      return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "divisibleBy", "is not divisible by (multiple of) ");
    };
    validators.required = function validateRequired(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (instance === void 0 && schema.required === true) {
        result.addError({
          name: "required",
          message: "is required"
        });
      } else if (this.types.object(instance) && Array.isArray(schema.required)) {
        schema.required.forEach(function(n) {
          if (getEnumerableProperty(instance, n) === void 0) {
            result.addError({
              name: "required",
              argument: n,
              message: "requires property " + JSON.stringify(n)
            });
          }
        });
      }
      return result;
    };
    validators.pattern = function validatePattern(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var pattern = schema.pattern;
      try {
        var regexp = new RegExp(pattern, "u");
      } catch (_e) {
        regexp = new RegExp(pattern);
      }
      if (!instance.match(regexp)) {
        result.addError({
          name: "pattern",
          argument: schema.pattern,
          message: "does not match pattern " + JSON.stringify(schema.pattern.toString())
        });
      }
      return result;
    };
    validators.format = function validateFormat(instance, schema, options, ctx) {
      if (instance === void 0)
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
        result.addError({
          name: "format",
          argument: schema.format,
          message: "does not conform to the " + JSON.stringify(schema.format) + " format"
        });
      }
      return result;
    };
    validators.minLength = function validateMinLength(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var hsp = instance.match(/[\uDC00-\uDFFF]/g);
      var length = instance.length - (hsp ? hsp.length : 0);
      if (!(length >= schema.minLength)) {
        result.addError({
          name: "minLength",
          argument: schema.minLength,
          message: "does not meet minimum length of " + schema.minLength
        });
      }
      return result;
    };
    validators.maxLength = function validateMaxLength(instance, schema, options, ctx) {
      if (!this.types.string(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var hsp = instance.match(/[\uDC00-\uDFFF]/g);
      var length = instance.length - (hsp ? hsp.length : 0);
      if (!(length <= schema.maxLength)) {
        result.addError({
          name: "maxLength",
          argument: schema.maxLength,
          message: "does not meet maximum length of " + schema.maxLength
        });
      }
      return result;
    };
    validators.minItems = function validateMinItems(instance, schema, options, ctx) {
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length >= schema.minItems)) {
        result.addError({
          name: "minItems",
          argument: schema.minItems,
          message: "does not meet minimum length of " + schema.minItems
        });
      }
      return result;
    };
    validators.maxItems = function validateMaxItems(instance, schema, options, ctx) {
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!(instance.length <= schema.maxItems)) {
        result.addError({
          name: "maxItems",
          argument: schema.maxItems,
          message: "does not meet maximum length of " + schema.maxItems
        });
      }
      return result;
    };
    function testArrays(v, i, a) {
      var j, len = a.length;
      for (j = i + 1, len; j < len; j++) {
        if (helpers.deepCompareStrict(v, a[j])) {
          return false;
        }
      }
      return true;
    }
    validators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {
      if (schema.uniqueItems !== true)
        return;
      if (!this.types.array(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!instance.every(testArrays)) {
        result.addError({
          name: "uniqueItems",
          message: "contains duplicate item"
        });
      }
      return result;
    };
    validators.dependencies = function validateDependencies(instance, schema, options, ctx) {
      if (!this.types.object(instance))
        return;
      var result = new ValidatorResult(instance, schema, options, ctx);
      for (var property in schema.dependencies) {
        if (instance[property] === void 0) {
          continue;
        }
        var dep = schema.dependencies[property];
        var childContext = ctx.makeChild(dep, property);
        if (typeof dep == "string") {
          dep = [dep];
        }
        if (Array.isArray(dep)) {
          dep.forEach(function(prop) {
            if (instance[prop] === void 0) {
              result.addError({
                // FIXME there's two different "dependencies" errors here with slightly different outputs
                // Can we make these the same? Or should we create different error types?
                name: "dependencies",
                argument: childContext.propertyPath,
                message: "property " + prop + " not found, required by " + childContext.propertyPath
              });
            }
          });
        } else {
          var res = this.validateSchema(instance, dep, options, childContext);
          if (result.instance !== res.instance)
            result.instance = res.instance;
          if (res && res.errors.length) {
            result.addError({
              name: "dependencies",
              argument: childContext.propertyPath,
              message: "does not meet dependency required by " + childContext.propertyPath
            });
            result.importErrors(res);
          }
        }
      }
      return result;
    };
    validators["enum"] = function validateEnum(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      if (!Array.isArray(schema["enum"])) {
        throw new SchemaError("enum expects an array", schema);
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!schema["enum"].some(helpers.deepCompareStrict.bind(null, instance))) {
        result.addError({
          name: "enum",
          argument: schema["enum"],
          message: "is not one of enum values: " + schema["enum"].map(String).join(",")
        });
      }
      return result;
    };
    validators["const"] = function validateEnum(instance, schema, options, ctx) {
      if (instance === void 0) {
        return null;
      }
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (!helpers.deepCompareStrict(schema["const"], instance)) {
        result.addError({
          name: "const",
          argument: schema["const"],
          message: "does not exactly match expected constant: " + schema["const"]
        });
      }
      return result;
    };
    validators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {
      var self2 = this;
      if (instance === void 0)
        return null;
      var result = new ValidatorResult(instance, schema, options, ctx);
      var notTypes = schema.not || schema.disallow;
      if (!notTypes)
        return null;
      if (!Array.isArray(notTypes))
        notTypes = [notTypes];
      notTypes.forEach(function(type) {
        if (self2.testType(instance, schema, options, ctx, type)) {
          var id = type && (type.$id || type.id);
          var schemaId = id || type;
          result.addError({
            name: "not",
            argument: schemaId,
            message: "is of prohibited type " + schemaId
          });
        }
      });
      return result;
    };
    module.exports = attribute;
  }
});

// node_modules/jsonschema/lib/scan.js
var require_scan = __commonJS({
  "node_modules/jsonschema/lib/scan.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var urilib = require_url();
    var helpers = require_helpers();
    module.exports.SchemaScanResult = SchemaScanResult;
    function SchemaScanResult(found, ref) {
      this.id = found;
      this.ref = ref;
    }
    module.exports.scan = function scan(base, schema) {
      function scanSchema(baseuri, schema2) {
        if (!schema2 || typeof schema2 != "object")
          return;
        if (schema2.$ref) {
          var resolvedUri = urilib.resolve(baseuri, schema2.$ref);
          ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri] + 1 : 0;
          return;
        }
        var id = schema2.$id || schema2.id;
        var ourBase = id ? urilib.resolve(baseuri, id) : baseuri;
        if (ourBase) {
          if (ourBase.indexOf("#") < 0)
            ourBase += "#";
          if (found[ourBase]) {
            if (!helpers.deepCompareStrict(found[ourBase], schema2)) {
              throw new Error("Schema <" + ourBase + "> already exists with different definition");
            }
            return found[ourBase];
          }
          found[ourBase] = schema2;
          if (ourBase[ourBase.length - 1] == "#") {
            found[ourBase.substring(0, ourBase.length - 1)] = schema2;
          }
        }
        scanArray(ourBase + "/items", Array.isArray(schema2.items) ? schema2.items : [schema2.items]);
        scanArray(ourBase + "/extends", Array.isArray(schema2.extends) ? schema2.extends : [schema2.extends]);
        scanSchema(ourBase + "/additionalItems", schema2.additionalItems);
        scanObject(ourBase + "/properties", schema2.properties);
        scanSchema(ourBase + "/additionalProperties", schema2.additionalProperties);
        scanObject(ourBase + "/definitions", schema2.definitions);
        scanObject(ourBase + "/patternProperties", schema2.patternProperties);
        scanObject(ourBase + "/dependencies", schema2.dependencies);
        scanArray(ourBase + "/disallow", schema2.disallow);
        scanArray(ourBase + "/allOf", schema2.allOf);
        scanArray(ourBase + "/anyOf", schema2.anyOf);
        scanArray(ourBase + "/oneOf", schema2.oneOf);
        scanSchema(ourBase + "/not", schema2.not);
      }
      function scanArray(baseuri, schemas) {
        if (!Array.isArray(schemas))
          return;
        for (var i = 0; i < schemas.length; i++) {
          scanSchema(baseuri + "/" + i, schemas[i]);
        }
      }
      function scanObject(baseuri, schemas) {
        if (!schemas || typeof schemas != "object")
          return;
        for (var p in schemas) {
          scanSchema(baseuri + "/" + p, schemas[p]);
        }
      }
      var found = {};
      var ref = {};
      scanSchema(base, schema);
      return new SchemaScanResult(found, ref);
    };
  }
});

// node_modules/jsonschema/lib/validator.js
var require_validator = __commonJS({
  "node_modules/jsonschema/lib/validator.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var urilib = require_url();
    var attribute = require_attribute();
    var helpers = require_helpers();
    var scanSchema = require_scan().scan;
    var ValidatorResult = helpers.ValidatorResult;
    var ValidatorResultError = helpers.ValidatorResultError;
    var SchemaError = helpers.SchemaError;
    var SchemaContext = helpers.SchemaContext;
    var anonymousBase = "/";
    var Validator = function Validator2() {
      this.customFormats = Object.create(Validator2.prototype.customFormats);
      this.schemas = {};
      this.unresolvedRefs = [];
      this.types = Object.create(types);
      this.attributes = Object.create(attribute.validators);
    };
    Validator.prototype.customFormats = {};
    Validator.prototype.schemas = null;
    Validator.prototype.types = null;
    Validator.prototype.attributes = null;
    Validator.prototype.unresolvedRefs = null;
    Validator.prototype.addSchema = function addSchema(schema, base) {
      var self2 = this;
      if (!schema) {
        return null;
      }
      var scan = scanSchema(base || anonymousBase, schema);
      var ourUri = base || schema.$id || schema.id;
      for (var uri in scan.id) {
        this.schemas[uri] = scan.id[uri];
      }
      for (var uri in scan.ref) {
        this.unresolvedRefs.push(uri);
      }
      this.unresolvedRefs = this.unresolvedRefs.filter(function(uri2) {
        return typeof self2.schemas[uri2] === "undefined";
      });
      return this.schemas[ourUri];
    };
    Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
      if (!Array.isArray(schemas))
        return;
      for (var i = 0; i < schemas.length; i++) {
        this.addSubSchema(baseuri, schemas[i]);
      }
    };
    Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
      if (!schemas || typeof schemas != "object")
        return;
      for (var p in schemas) {
        this.addSubSchema(baseuri, schemas[p]);
      }
    };
    Validator.prototype.setSchemas = function setSchemas(schemas) {
      this.schemas = schemas;
    };
    Validator.prototype.getSchema = function getSchema(urn) {
      return this.schemas[urn];
    };
    Validator.prototype.validate = function validate(instance, schema, options, ctx) {
      if (typeof schema !== "boolean" && typeof schema !== "object" || schema === null) {
        throw new SchemaError("Expected `schema` to be an object or boolean");
      }
      if (!options) {
        options = {};
      }
      var id = schema.$id || schema.id;
      var base = urilib.resolve(options.base || anonymousBase, id || "");
      if (!ctx) {
        ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));
        if (!ctx.schemas[base]) {
          ctx.schemas[base] = schema;
        }
        var found = scanSchema(base, schema);
        for (var n in found.id) {
          var sch = found.id[n];
          ctx.schemas[n] = sch;
        }
      }
      if (options.required && instance === void 0) {
        var result = new ValidatorResult(instance, schema, options, ctx);
        result.addError("is required, but is undefined");
        return result;
      }
      var result = this.validateSchema(instance, schema, options, ctx);
      if (!result) {
        throw new Error("Result undefined");
      } else if (options.throwAll && result.errors.length) {
        throw new ValidatorResultError(result);
      }
      return result;
    };
    function shouldResolve(schema) {
      var ref = typeof schema === "string" ? schema : schema.$ref;
      if (typeof ref == "string")
        return ref;
      return false;
    }
    Validator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {
      var result = new ValidatorResult(instance, schema, options, ctx);
      if (typeof schema === "boolean") {
        if (schema === true) {
          schema = {};
        } else if (schema === false) {
          schema = { type: [] };
        }
      } else if (!schema) {
        throw new Error("schema is undefined");
      }
      if (schema["extends"]) {
        if (Array.isArray(schema["extends"])) {
          var schemaobj = { schema, ctx };
          schema["extends"].forEach(this.schemaTraverser.bind(this, schemaobj));
          schema = schemaobj.schema;
          schemaobj.schema = null;
          schemaobj.ctx = null;
          schemaobj = null;
        } else {
          schema = helpers.deepMerge(schema, this.superResolve(schema["extends"], ctx));
        }
      }
      var switchSchema = shouldResolve(schema);
      if (switchSchema) {
        var resolved = this.resolve(schema, switchSchema, ctx);
        var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);
        return this.validateSchema(instance, resolved.subschema, options, subctx);
      }
      var skipAttributes = options && options.skipAttributes || [];
      for (var key in schema) {
        if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
          var validatorErr = null;
          var validator = this.attributes[key];
          if (validator) {
            validatorErr = validator.call(this, instance, schema, options, ctx);
          } else if (options.allowUnknownAttributes === false) {
            throw new SchemaError("Unsupported attribute: " + key, schema);
          }
          if (validatorErr) {
            result.importErrors(validatorErr);
          }
        }
      }
      if (typeof options.rewrite == "function") {
        var value = options.rewrite.call(this, instance, schema, options, ctx);
        result.instance = value;
      }
      return result;
    };
    Validator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {
      schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
    };
    Validator.prototype.superResolve = function superResolve(schema, ctx) {
      var ref = shouldResolve(schema);
      if (ref) {
        return this.resolve(schema, ref, ctx).subschema;
      }
      return schema;
    };
    Validator.prototype.resolve = function resolve(schema, switchSchema, ctx) {
      switchSchema = ctx.resolve(switchSchema);
      if (ctx.schemas[switchSchema]) {
        return { subschema: ctx.schemas[switchSchema], switchSchema };
      }
      var parsed = urilib.parse(switchSchema);
      var fragment = parsed && parsed.hash;
      var document2 = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
      if (!document2 || !ctx.schemas[document2]) {
        throw new SchemaError("no such schema <" + switchSchema + ">", schema);
      }
      var subschema = helpers.objectGetPath(ctx.schemas[document2], fragment.substr(1));
      if (subschema === void 0) {
        throw new SchemaError("no such schema " + fragment + " located in <" + document2 + ">", schema);
      }
      return { subschema, switchSchema };
    };
    Validator.prototype.testType = function validateType(instance, schema, options, ctx, type) {
      if (type === void 0) {
        return;
      } else if (type === null) {
        throw new SchemaError('Unexpected null in "type" keyword');
      }
      if (typeof this.types[type] == "function") {
        return this.types[type].call(this, instance);
      }
      if (type && typeof type == "object") {
        var res = this.validateSchema(instance, type, options, ctx);
        return res === void 0 || !(res && res.errors.length);
      }
      return true;
    };
    var types = Validator.prototype.types = {};
    types.string = function testString(instance) {
      return typeof instance == "string";
    };
    types.number = function testNumber(instance) {
      return typeof instance == "number" && isFinite(instance);
    };
    types.integer = function testInteger(instance) {
      return typeof instance == "number" && instance % 1 === 0;
    };
    types.boolean = function testBoolean(instance) {
      return typeof instance == "boolean";
    };
    types.array = function testArray(instance) {
      return Array.isArray(instance);
    };
    types["null"] = function testNull(instance) {
      return instance === null;
    };
    types.date = function testDate(instance) {
      return instance instanceof Date;
    };
    types.any = function testAny(instance) {
      return true;
    };
    types.object = function testObject(instance) {
      return instance && typeof instance === "object" && !Array.isArray(instance) && !(instance instanceof Date);
    };
    module.exports = Validator;
  }
});

// node_modules/jsonschema/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/jsonschema/lib/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var Validator = module.exports.Validator = require_validator();
    module.exports.ValidatorResult = require_helpers().ValidatorResult;
    module.exports.ValidatorResultError = require_helpers().ValidatorResultError;
    module.exports.ValidationError = require_helpers().ValidationError;
    module.exports.SchemaError = require_helpers().SchemaError;
    module.exports.SchemaScanResult = require_scan().SchemaScanResult;
    module.exports.scan = require_scan().scan;
    module.exports.validate = function(instance, schema, options) {
      var v = new Validator();
      return v.validate(instance, schema, options);
    };
  }
});

// node_modules/@web3auth/ethereum-provider/dist/ethereumProvider.esm.js
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function resemblesAddress(str) {
  return str.length === 2 + 20 * 2;
}
function createWalletMiddleware(_ref) {
  var getAccounts = _ref.getAccounts, getPrivateKey = _ref.getPrivateKey, processDecryptMessage = _ref.processDecryptMessage, processEncryptionPublicKey = _ref.processEncryptionPublicKey, processEthSignMessage = _ref.processEthSignMessage, processPersonalMessage = _ref.processPersonalMessage, processTransaction = _ref.processTransaction, processSignTransaction = _ref.processSignTransaction, processTypedMessage = _ref.processTypedMessage, processTypedMessageV3 = _ref.processTypedMessageV3, processTypedMessageV4 = _ref.processTypedMessageV4;
  if (!getAccounts) {
    throw new Error("opts.getAccounts is required");
  }
  function validateAndNormalizeKeyholder(_x, _x2) {
    return _validateAndNormalizeKeyholder.apply(this, arguments);
  }
  function _validateAndNormalizeKeyholder() {
    _validateAndNormalizeKeyholder = _asyncToGenerator(import_regenerator.default.mark(function _callee(address, req) {
      var accounts, normalizedAccounts, normalizedAddress;
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof address === "string" && address.length > 0)) {
                _context.next = 8;
                break;
              }
              _context.next = 3;
              return getAccounts(req);
            case 3:
              accounts = _context.sent;
              normalizedAccounts = accounts.map(function(_address) {
                return _address.toLowerCase();
              });
              normalizedAddress = address.toLowerCase();
              if (!normalizedAccounts.includes(normalizedAddress)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", normalizedAddress);
            case 8:
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams({
                message: "Invalid parameters: must provide an Ethereum address."
              });
            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _validateAndNormalizeKeyholder.apply(this, arguments);
  }
  function lookupAccounts(_x3, _x4) {
    return _lookupAccounts.apply(this, arguments);
  }
  function _lookupAccounts() {
    _lookupAccounts = _asyncToGenerator(import_regenerator.default.mark(function _callee2(req, res) {
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return getAccounts(req);
            case 2:
              res.result = _context2.sent;
            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _lookupAccounts.apply(this, arguments);
  }
  function lookupDefaultAccount(_x5, _x6) {
    return _lookupDefaultAccount.apply(this, arguments);
  }
  function _lookupDefaultAccount() {
    _lookupDefaultAccount = _asyncToGenerator(import_regenerator.default.mark(function _callee3(req, res) {
      var accounts;
      return import_regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return getAccounts(req);
            case 2:
              accounts = _context3.sent;
              res.result = accounts[0] || null;
            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _lookupDefaultAccount.apply(this, arguments);
  }
  function sendTransaction(_x7, _x8) {
    return _sendTransaction.apply(this, arguments);
  }
  function _sendTransaction() {
    _sendTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee4(req, res) {
      var txParams;
      return import_regenerator.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (processTransaction) {
                _context4.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              txParams = req.params[0] || {
                from: ""
              };
              _context4.next = 5;
              return validateAndNormalizeKeyholder(txParams.from, req);
            case 5:
              txParams.from = _context4.sent;
              _context4.next = 8;
              return processTransaction(txParams, req);
            case 8:
              res.result = _context4.sent;
            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendTransaction.apply(this, arguments);
  }
  function signTransaction(_x9, _x10) {
    return _signTransaction.apply(this, arguments);
  }
  function _signTransaction() {
    _signTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee5(req, res) {
      var txParams;
      return import_regenerator.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (processSignTransaction) {
                _context5.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              txParams = req.params[0] || {
                from: ""
              };
              _context5.next = 5;
              return validateAndNormalizeKeyholder(txParams.from, req);
            case 5:
              txParams.from = _context5.sent;
              _context5.next = 8;
              return processSignTransaction(txParams, req);
            case 8:
              res.result = _context5.sent;
            case 9:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _signTransaction.apply(this, arguments);
  }
  function ethSign(_x11, _x12) {
    return _ethSign.apply(this, arguments);
  }
  function _ethSign() {
    _ethSign = _asyncToGenerator(import_regenerator.default.mark(function _callee6(req, res) {
      var address, message, extraParams, msgParams;
      return import_regenerator.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (processEthSignMessage) {
                _context6.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              _context6.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context6.sent;
              message = req.params[1];
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              });
              _context6.next = 10;
              return processEthSignMessage(msgParams, req);
            case 10:
              res.result = _context6.sent;
            case 11:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));
    return _ethSign.apply(this, arguments);
  }
  function signTypedData2(_x13, _x14) {
    return _signTypedData.apply(this, arguments);
  }
  function _signTypedData() {
    _signTypedData = _asyncToGenerator(import_regenerator.default.mark(function _callee7(req, res) {
      var message, address, version, extraParams, msgParams;
      return import_regenerator.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (processTypedMessage) {
                _context7.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              message = req.params[0];
              _context7.next = 5;
              return validateAndNormalizeKeyholder(req.params[1], req);
            case 5:
              address = _context7.sent;
              version = "V1";
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              });
              _context7.next = 11;
              return processTypedMessage(msgParams, req, version);
            case 11:
              res.result = _context7.sent;
            case 12:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));
    return _signTypedData.apply(this, arguments);
  }
  function signTypedDataV3(_x15, _x16) {
    return _signTypedDataV.apply(this, arguments);
  }
  function _signTypedDataV() {
    _signTypedDataV = _asyncToGenerator(import_regenerator.default.mark(function _callee8(req, res) {
      var address, message, version, msgParams;
      return import_regenerator.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (processTypedMessageV3) {
                _context8.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              _context8.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context8.sent;
              message = req.params[1];
              version = "V3";
              msgParams = {
                data: message,
                from: address,
                version
              };
              _context8.next = 10;
              return processTypedMessageV3(msgParams, req, version);
            case 10:
              res.result = _context8.sent;
            case 11:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));
    return _signTypedDataV.apply(this, arguments);
  }
  function signTypedDataV4(_x17, _x18) {
    return _signTypedDataV2.apply(this, arguments);
  }
  function _signTypedDataV2() {
    _signTypedDataV2 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(req, res) {
      var address, message, version, msgParams;
      return import_regenerator.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (processTypedMessageV4) {
                _context9.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              _context9.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context9.sent;
              message = req.params[1];
              version = "V4";
              msgParams = {
                data: message,
                from: address,
                version
              };
              _context9.next = 10;
              return processTypedMessageV4(msgParams, req, version);
            case 10:
              res.result = _context9.sent;
            case 11:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));
    return _signTypedDataV2.apply(this, arguments);
  }
  function personalSign2(_x19, _x20) {
    return _personalSign.apply(this, arguments);
  }
  function _personalSign() {
    _personalSign = _asyncToGenerator(import_regenerator.default.mark(function _callee10(req, res) {
      var firstParam, secondParam, extraParams, address, message, warning, msgParams;
      return import_regenerator.default.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (processPersonalMessage) {
                _context10.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              firstParam = req.params[0];
              secondParam = req.params[1];
              extraParams = req.params[2] || {};
              if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
                warning = "The eth_personalSign method requires params ordered ";
                warning += "[message, address]. This was previously handled incorrectly, ";
                warning += "and has been corrected automatically. ";
                warning += "Please switch this param order for smooth behavior in the future.";
                res.warning = warning;
                address = firstParam;
                message = secondParam;
              } else {
                message = firstParam;
                address = secondParam;
              }
              _context10.next = 8;
              return validateAndNormalizeKeyholder(address, req);
            case 8:
              address = _context10.sent;
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: message
              });
              _context10.next = 12;
              return processPersonalMessage(msgParams, req);
            case 12:
              res.result = _context10.sent;
            case 13:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));
    return _personalSign.apply(this, arguments);
  }
  function encryptionPublicKey(_x21, _x22) {
    return _encryptionPublicKey.apply(this, arguments);
  }
  function _encryptionPublicKey() {
    _encryptionPublicKey = _asyncToGenerator(import_regenerator.default.mark(function _callee11(req, res) {
      var address;
      return import_regenerator.default.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (processEncryptionPublicKey) {
                _context11.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              _context11.next = 4;
              return validateAndNormalizeKeyholder(req.params[0], req);
            case 4:
              address = _context11.sent;
              _context11.next = 7;
              return processEncryptionPublicKey(address, req);
            case 7:
              res.result = _context11.sent;
            case 8:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    }));
    return _encryptionPublicKey.apply(this, arguments);
  }
  function decryptMessage(_x23, _x24) {
    return _decryptMessage.apply(this, arguments);
  }
  function _decryptMessage() {
    _decryptMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee12(req, res) {
      var ciphertext, address, extraParams, msgParams;
      return import_regenerator.default.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (processDecryptMessage) {
                _context12.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              ciphertext = req.params[0];
              _context12.next = 5;
              return validateAndNormalizeKeyholder(req.params[1], req);
            case 5:
              address = _context12.sent;
              extraParams = req.params[2] || {};
              msgParams = _objectSpread$5(_objectSpread$5({}, extraParams), {}, {
                from: address,
                data: ciphertext
              });
              res.result = processDecryptMessage(msgParams, req);
            case 9:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));
    return _decryptMessage.apply(this, arguments);
  }
  function fetchPrivateKey(_x25, _x26) {
    return _fetchPrivateKey.apply(this, arguments);
  }
  function _fetchPrivateKey() {
    _fetchPrivateKey = _asyncToGenerator(import_regenerator.default.mark(function _callee13(req, res) {
      return import_regenerator.default.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (getPrivateKey) {
                _context13.next = 2;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
            case 2:
              res.result = getPrivateKey(req);
            case 3:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    }));
    return _fetchPrivateKey.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    // account lookups
    eth_accounts: createAsyncMiddleware(lookupAccounts),
    eth_private_key: createAsyncMiddleware(fetchPrivateKey),
    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),
    // tx signatures
    eth_sendTransaction: createAsyncMiddleware(sendTransaction),
    eth_signTransaction: createAsyncMiddleware(signTransaction),
    // message signatures
    eth_sign: createAsyncMiddleware(ethSign),
    eth_signTypedData: createAsyncMiddleware(signTypedData2),
    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),
    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),
    personal_sign: createAsyncMiddleware(personalSign2),
    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),
    eth_decrypt: createAsyncMiddleware(decryptMessage)
  });
}
function createEthMiddleware(providerHandlers) {
  var getAccounts = providerHandlers.getAccounts, getPrivateKey = providerHandlers.getPrivateKey, processTransaction = providerHandlers.processTransaction, processSignTransaction = providerHandlers.processSignTransaction, processEthSignMessage = providerHandlers.processEthSignMessage, processTypedMessage = providerHandlers.processTypedMessage, processTypedMessageV3 = providerHandlers.processTypedMessageV3, processTypedMessageV4 = providerHandlers.processTypedMessageV4, processPersonalMessage = providerHandlers.processPersonalMessage, processEncryptionPublicKey = providerHandlers.processEncryptionPublicKey, processDecryptMessage = providerHandlers.processDecryptMessage;
  var ethMiddleware = mergeMiddleware([createScaffoldMiddleware({
    eth_syncing: false
  }), createWalletMiddleware({
    getAccounts,
    getPrivateKey,
    processTransaction,
    processEthSignMessage,
    processSignTransaction,
    processTypedMessage,
    processTypedMessageV3,
    processTypedMessageV4,
    processPersonalMessage,
    processEncryptionPublicKey,
    processDecryptMessage
  })]);
  return ethMiddleware;
}
function createChainSwitchMiddleware(_ref) {
  var addChain = _ref.addChain, switchChain = _ref.switchChain;
  function addNewChain(_x, _x2) {
    return _addNewChain.apply(this, arguments);
  }
  function _addNewChain() {
    _addNewChain = _asyncToGenerator(import_regenerator.default.mark(function _callee(req, res) {
      var _req$params;
      var chainParams;
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : void 0;
              if (chainParams) {
                _context.next = 3;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing chain params");
            case 3:
              if (chainParams.chainId) {
                _context.next = 5;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing chainId in chainParams");
            case 5:
              if (!(!chainParams.rpcUrls || chainParams.rpcUrls.length === 0)) {
                _context.next = 7;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing rpcUrls in chainParams");
            case 7:
              if (chainParams.nativeCurrency) {
                _context.next = 9;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing nativeCurrency in chainParams");
            case 9:
              _context.next = 11;
              return addChain(chainParams);
            case 11:
              res.result = _context.sent;
            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _addNewChain.apply(this, arguments);
  }
  function updateChain(_x3, _x4) {
    return _updateChain.apply(this, arguments);
  }
  function _updateChain() {
    _updateChain = _asyncToGenerator(import_regenerator.default.mark(function _callee2(req, res) {
      var _req$params2;
      var chainParams;
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : void 0;
              if (chainParams) {
                _context2.next = 3;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing chainId");
            case 3:
              _context2.next = 5;
              return switchChain(chainParams);
            case 5:
              res.result = _context2.sent;
            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _updateChain.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),
    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)
  });
}
function createAccountMiddleware(_ref2) {
  var updatePrivatekey = _ref2.updatePrivatekey;
  function updateAccount(_x5, _x6) {
    return _updateAccount.apply(this, arguments);
  }
  function _updateAccount() {
    _updateAccount = _asyncToGenerator(import_regenerator.default.mark(function _callee3(req, res) {
      var _req$params3;
      var accountParams;
      return import_regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : void 0;
              if (accountParams !== null && accountParams !== void 0 && accountParams.privateKey) {
                _context3.next = 3;
                break;
              }
              throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("Missing privateKey");
            case 3:
              _context3.next = 5;
              return updatePrivatekey(accountParams);
            case 5:
              res.result = _context3.sent;
            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _updateAccount.apply(this, arguments);
  }
  return createScaffoldMiddleware({
    wallet_updateAccount: createAsyncMiddleware(updateAccount)
  });
}
function createChainIdMiddleware(chainId) {
  return function(req, res, next, end) {
    if (req.method === "eth_chainId") {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return function(req, res, next, end) {
    if (req.method === "eth_provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createJsonRpcClient(providerConfig) {
  var chainId = providerConfig.chainId, rpcTarget = providerConfig.rpcTarget;
  var fetchMiddleware = createFetchMiddleware({
    rpcTarget
  });
  var networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}
function getProviderHandlers$1(_ref) {
  var connector = _ref.connector;
  return {
    getPrivateKey: function() {
      var _getPrivateKey = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function getPrivateKey() {
        return _getPrivateKey.apply(this, arguments);
      }
      return getPrivateKey;
    }(),
    getAccounts: function() {
      var _getAccounts = _asyncToGenerator(import_regenerator.default.mark(function _callee2(_) {
        var accounts;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                accounts = connector.accounts;
                if (!(accounts && accounts.length)) {
                  _context2.next = 3;
                  break;
                }
                return _context2.abrupt("return", accounts);
              case 3:
                throw new Error("Failed to get accounts");
              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      function getAccounts(_x) {
        return _getAccounts.apply(this, arguments);
      }
      return getAccounts;
    }(),
    processTransaction: function() {
      var _processTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee3(txParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return connector.sendTransaction(txParams);
              case 2:
                result = _context3.sent;
                return _context3.abrupt("return", result);
              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function processTransaction(_x2, _x3) {
        return _processTransaction.apply(this, arguments);
      }
      return processTransaction;
    }(),
    processSignTransaction: function() {
      var _processSignTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee4(txParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return connector.signTransaction(txParams);
              case 2:
                result = _context4.sent;
                return _context4.abrupt("return", result);
              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function processSignTransaction(_x4, _x5) {
        return _processSignTransaction.apply(this, arguments);
      }
      return processSignTransaction;
    }(),
    processEthSignMessage: function() {
      var _processEthSignMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee5(msgParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return connector.signMessage([msgParams.from, msgParams.data]);
              case 2:
                result = _context5.sent;
                return _context5.abrupt("return", result);
              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      function processEthSignMessage(_x6, _x7) {
        return _processEthSignMessage.apply(this, arguments);
      }
      return processEthSignMessage;
    }(),
    processPersonalMessage: function() {
      var _processPersonalMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee6(msgParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return connector.signPersonalMessage([msgParams.data, msgParams.from]);
              case 2:
                result = _context6.sent;
                return _context6.abrupt("return", result);
              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      function processPersonalMessage(_x8, _x9) {
        return _processPersonalMessage.apply(this, arguments);
      }
      return processPersonalMessage;
    }(),
    processTypedMessage: function() {
      var _processTypedMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee7(msgParams, _) {
        var result;
        return import_regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context7.sent;
                return _context7.abrupt("return", result);
              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      function processTypedMessage(_x10, _x11) {
        return _processTypedMessage.apply(this, arguments);
      }
      return processTypedMessage;
    }(),
    processTypedMessageV3: function() {
      var _processTypedMessageV = _asyncToGenerator(import_regenerator.default.mark(function _callee8(msgParams) {
        var result;
        return import_regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context8.sent;
                return _context8.abrupt("return", result);
              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));
      function processTypedMessageV3(_x12) {
        return _processTypedMessageV.apply(this, arguments);
      }
      return processTypedMessageV3;
    }(),
    processTypedMessageV4: function() {
      var _processTypedMessageV2 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(msgParams) {
        var result;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return connector.signTypedData([msgParams.from, msgParams.data]);
              case 2:
                result = _context9.sent;
                return _context9.abrupt("return", result);
              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      function processTypedMessageV4(_x13) {
        return _processTypedMessageV2.apply(this, arguments);
      }
      return processTypedMessageV4;
    }(),
    processEncryptionPublicKey: function() {
      var _processEncryptionPublicKey = _asyncToGenerator(import_regenerator.default.mark(function _callee10(_) {
        return import_regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));
      function processEncryptionPublicKey(_x14) {
        return _processEncryptionPublicKey.apply(this, arguments);
      }
      return processEncryptionPublicKey;
    }(),
    processDecryptMessage: function processDecryptMessage(_) {
      throw import_eth_rpc_errors.ethErrors.rpc.methodNotSupported();
    }
  };
}
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function decGWEIToHexWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "dec",
    toNumericBase: "hex",
    fromDenomination: "GWEI",
    toDenomination: "WEI"
  });
}
function hexWEIToDecGWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: "hex",
    toNumericBase: "dec",
    fromDenomination: "WEI",
    toDenomination: "GWEI"
  });
}
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function normalizeGWEIDecimalNumbers(n) {
  var numberAsWEIHex = decGWEIToHexWEI(n);
  var numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);
  return numberAsGWEI;
}
function fetchEip1159GasEstimates(_x) {
  return _fetchEip1159GasEstimates.apply(this, arguments);
}
function _fetchEip1159GasEstimates() {
  _fetchEip1159GasEstimates = _asyncToGenerator(import_regenerator.default.mark(function _callee(url) {
    var estimates, normalizedEstimates;
    return import_regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return get(url);
          case 2:
            estimates = _context.sent;
            normalizedEstimates = _objectSpread$3(_objectSpread$3({}, estimates), {}, {
              estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),
              low: _objectSpread$3(_objectSpread$3({}, estimates.low), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)
              }),
              medium: _objectSpread$3(_objectSpread$3({}, estimates.medium), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)
              }),
              high: _objectSpread$3(_objectSpread$3({}, estimates.high), {}, {
                suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),
                suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)
              })
            });
            return _context.abrupt("return", normalizedEstimates);
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchEip1159GasEstimates.apply(this, arguments);
}
function fetchLegacyGasPriceEstimates(_x2) {
  return _fetchLegacyGasPriceEstimates.apply(this, arguments);
}
function _fetchLegacyGasPriceEstimates() {
  _fetchLegacyGasPriceEstimates = _asyncToGenerator(import_regenerator.default.mark(function _callee2(url) {
    var result;
    return import_regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return get(url, {
              referrer: url,
              referrerPolicy: "no-referrer-when-downgrade",
              method: "GET",
              mode: "cors"
            });
          case 2:
            result = _context2.sent;
            return _context2.abrupt("return", {
              low: result.SafeGasPrice,
              medium: result.ProposeGasPrice,
              high: result.FastGasPrice
            });
          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchLegacyGasPriceEstimates.apply(this, arguments);
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function signTx(_x, _x2, _x3) {
  return _signTx.apply(this, arguments);
}
function _signTx() {
  _signTx = _asyncToGenerator(import_regenerator.default.mark(function _callee11(txParams, privKey, txFormatter) {
    var finalTxParams, common, unsignedEthTx, signedTx;
    return import_regenerator.default.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return txFormatter.formatTransaction(txParams);
          case 2:
            finalTxParams = _context11.sent;
            _context11.next = 5;
            return txFormatter.getCommonConfiguration();
          case 5:
            common = _context11.sent;
            unsignedEthTx = import_tx.TransactionFactory.fromTxData(finalTxParams, {
              common
            });
            signedTx = unsignedEthTx.sign(Buffer.from(privKey, "hex")).serialize();
            return _context11.abrupt("return", signedTx);
          case 9:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee11);
  }));
  return _signTx.apply(this, arguments);
}
function getProviderHandlers(_ref) {
  var txFormatter = _ref.txFormatter, privKey = _ref.privKey, getProviderEngineProxy = _ref.getProviderEngineProxy;
  return {
    getAccounts: function() {
      var _getAccounts = _asyncToGenerator(import_regenerator.default.mark(function _callee(_) {
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", ["0x".concat((0, import_util.privateToAddress)(Buffer.from(privKey, "hex")).toString("hex"))]);
              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      function getAccounts(_x4) {
        return _getAccounts.apply(this, arguments);
      }
      return getAccounts;
    }(),
    getPrivateKey: function() {
      var _getPrivateKey = _asyncToGenerator(import_regenerator.default.mark(function _callee2(_) {
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", privKey);
              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      function getPrivateKey(_x5) {
        return _getPrivateKey.apply(this, arguments);
      }
      return getPrivateKey;
    }(),
    processTransaction: function() {
      var _processTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee3(txParams, _) {
        var providerEngineProxy, signedTx, txHash;
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context3.next = 3;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 3:
                _context3.next = 5;
                return signTx(txParams, privKey, txFormatter);
              case 5:
                signedTx = _context3.sent;
                _context3.next = 8;
                return providerEngineProxy.request({
                  method: "eth_sendRawTransaction",
                  params: ["0x".concat(signedTx.toString("hex"))]
                });
              case 8:
                txHash = _context3.sent;
                return _context3.abrupt("return", txHash);
              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      function processTransaction(_x6, _x7) {
        return _processTransaction.apply(this, arguments);
      }
      return processTransaction;
    }(),
    processSignTransaction: function() {
      var _processSignTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee4(txParams, _) {
        var providerEngineProxy, signedTx;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context4.next = 3;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 3:
                _context4.next = 5;
                return signTx(txParams, privKey, txFormatter);
              case 5:
                signedTx = _context4.sent;
                return _context4.abrupt("return", "0x".concat(signedTx.toString("hex")));
              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      function processSignTransaction(_x8, _x9) {
        return _processSignTransaction.apply(this, arguments);
      }
      return processSignTransaction;
    }(),
    processEthSignMessage: function() {
      var _processEthSignMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee5(msgParams, _) {
        var rawMessageSig;
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                rawMessageSig = signMessage(privKey, msgParams.data);
                return _context5.abrupt("return", rawMessageSig);
              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      function processEthSignMessage(_x10, _x11) {
        return _processEthSignMessage.apply(this, arguments);
      }
      return processEthSignMessage;
    }(),
    processPersonalMessage: function() {
      var _processPersonalMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee6(msgParams, _) {
        var privKeyBuffer, sig;
        return import_regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                privKeyBuffer = Buffer.from(privKey, "hex");
                sig = (0, import_eth_sig_util.personalSign)({
                  privateKey: privKeyBuffer,
                  data: msgParams.data
                });
                return _context6.abrupt("return", sig);
              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      function processPersonalMessage(_x12, _x13) {
        return _processPersonalMessage.apply(this, arguments);
      }
      return processPersonalMessage;
    }(),
    processTypedMessage: function() {
      var _processTypedMessage = _asyncToGenerator(import_regenerator.default.mark(function _callee7(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, params, data, sig;
        return import_regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                log.debug("processTypedMessage", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context7.next = 5;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context7.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context7.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                params = _objectSpread$2(_objectSpread$2({}, msgParams), {}, {
                  version: import_eth_sig_util.SignTypedDataVersion.V1
                });
                validateTypedMessageParams(params, finalChainId);
                data = typeof params.data === "string" ? JSON.parse(params.data) : params.data;
                sig = (0, import_eth_sig_util.signTypedData)({
                  privateKey: privKeyBuffer,
                  data,
                  version: import_eth_sig_util.SignTypedDataVersion.V1
                });
                return _context7.abrupt("return", sig);
              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      function processTypedMessage(_x14, _x15) {
        return _processTypedMessage.apply(this, arguments);
      }
      return processTypedMessage;
    }(),
    processTypedMessageV3: function() {
      var _processTypedMessageV = _asyncToGenerator(import_regenerator.default.mark(function _callee8(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, data, sig;
        return import_regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                log.debug("processTypedMessageV3", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context8.next = 5;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context8.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context8.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                validateTypedMessageParams(msgParams, finalChainId);
                data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
                sig = (0, import_eth_sig_util.signTypedData)({
                  privateKey: privKeyBuffer,
                  data,
                  version: import_eth_sig_util.SignTypedDataVersion.V3
                });
                return _context8.abrupt("return", sig);
              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));
      function processTypedMessageV3(_x16, _x17) {
        return _processTypedMessageV.apply(this, arguments);
      }
      return processTypedMessageV3;
    }(),
    processTypedMessageV4: function() {
      var _processTypedMessageV2 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(msgParams, _) {
        var privKeyBuffer, providerEngineProxy, chainId, finalChainId, data, sig;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                log.debug("processTypedMessageV4", msgParams);
                privKeyBuffer = Buffer.from(privKey, "hex");
                providerEngineProxy = getProviderEngineProxy();
                if (providerEngineProxy) {
                  _context9.next = 5;
                  break;
                }
                throw import_eth_rpc_errors.ethErrors.provider.custom({
                  message: "Provider is not initialized",
                  code: 4902
                });
              case 5:
                _context9.next = 7;
                return providerEngineProxy.request({
                  method: "eth_chainId"
                });
              case 7:
                chainId = _context9.sent;
                finalChainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
                validateTypedMessageParams(msgParams, finalChainId);
                data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
                sig = (0, import_eth_sig_util.signTypedData)({
                  privateKey: privKeyBuffer,
                  data,
                  version: import_eth_sig_util.SignTypedDataVersion.V4
                });
                return _context9.abrupt("return", sig);
              case 13:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      function processTypedMessageV4(_x18, _x19) {
        return _processTypedMessageV2.apply(this, arguments);
      }
      return processTypedMessageV4;
    }(),
    processEncryptionPublicKey: function() {
      var _processEncryptionPublicKey = _asyncToGenerator(import_regenerator.default.mark(function _callee10(address, _) {
        return import_regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                log.info("processEncryptionPublicKey", address);
                return _context10.abrupt("return", (0, import_eth_sig_util.getEncryptionPublicKey)(privKey));
              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));
      function processEncryptionPublicKey(_x20, _x21) {
        return _processEncryptionPublicKey.apply(this, arguments);
      }
      return processEncryptionPublicKey;
    }(),
    processDecryptMessage: function processDecryptMessage(msgParams, _) {
      log.info("processDecryptMessage", msgParams);
      var stripped = (0, import_util.stripHexPrefix)(msgParams.data);
      var buff = Buffer.from(stripped, "hex");
      var decrypted = (0, import_eth_sig_util.decrypt)({
        encryptedData: JSON.parse(buff.toString("utf8")),
        privateKey: privKey
      });
      return decrypted;
    }
  };
}
function bnLessThan(a, b) {
  if (a === null || a === void 0 || b === null || b === void 0) {
    return null;
  }
  return new BigNumber(a, 10).lt(b, 10);
}
function bnToHex(inputBn) {
  return (0, import_util.addHexPrefix)(inputBn.toString(16));
}
function hexToBn(inputHex) {
  if (import_bn.default.isBN(inputHex))
    return inputHex;
  return new import_bn.default((0, import_util.stripHexPrefix)(inputHex), 16);
}
function BnMultiplyByFraction(targetBN, numerator, denominator) {
  var numberBN = new import_bn.default(numerator);
  var denomBN = new import_bn.default(denominator);
  return targetBN.mul(numberBN).div(denomBN);
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var import_regenerator, import_eth_rpc_errors, import_tx, import_util, import_eth_sig_util, import_assert, import_jsonschema, import_common, import_bn, WalletConnectProvider, BIG_NUMBER_WEI_MULTIPLIER, BIG_NUMBER_GWEI_MULTIPLIER, BIG_NUMBER_ETH_MULTIPLIER, toBigNumber, toNormalizedDenomination, toSpecifiedDenomination, baseChange, converter, conversionUtil, validateTypedMessageParams, LegacyGasAPIEndpoint, EIP1559APIEndpoint, TRANSACTION_ENVELOPE_TYPES, TRANSACTION_TYPES, GAS_ESTIMATE_TYPES, TransactionFormatter, EthereumPrivateKeyProvider;
var init_ethereumProvider_esm = __esm({
  "node_modules/@web3auth/ethereum-provider/dist/ethereumProvider.esm.js"() {
    init_process();
    init_buffer();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_get();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_defineProperty();
    import_regenerator = __toESM(require_regenerator());
    init_baseControllers_esm();
    init_openloginJrpc_esm();
    init_base_esm();
    init_baseProvider_esm();
    import_eth_rpc_errors = __toESM(require_dist());
    import_tx = __toESM(require_dist5());
    import_util = __toESM(require_dist3());
    import_eth_sig_util = __toESM(require_dist6());
    init_typeof();
    init_httpHelpers_esm();
    import_assert = __toESM(require_assert());
    import_jsonschema = __toESM(require_lib3());
    init_bignumber();
    import_common = __toESM(require_dist4());
    import_bn = __toESM(require_bn());
    WalletConnectProvider = function(_BaseProvider) {
      _inherits(WalletConnectProvider2, _BaseProvider);
      var _super = _createSuper$1(WalletConnectProvider2);
      function WalletConnectProvider2(_ref) {
        var _this;
        var config = _ref.config, state = _ref.state, connector = _ref.connector;
        _classCallCheck(this, WalletConnectProvider2);
        _this = _super.call(this, {
          config: {
            chainConfig: _objectSpread$4(_objectSpread$4({}, config.chainConfig), {}, {
              chainNamespace: CHAIN_NAMESPACES.EIP155
            }),
            skipLookupNetwork: !!config.skipLookupNetwork
          },
          state: _objectSpread$4(_objectSpread$4({}, state || {}), {}, {
            chainId: "loading",
            accounts: []
          })
        });
        _defineProperty(_assertThisInitialized(_this), "connector", null);
        _this.connector = connector || null;
        return _this;
      }
      _createClass(WalletConnectProvider2, [{
        key: "enable",
        value: function() {
          var _enable = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.connector) {
                      _context.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Connector is not initialized, pass wallet connect connector in constructor",
                      code: 4902
                    });
                  case 2:
                    _context.next = 4;
                    return this.setupProvider(this.connector);
                  case 4:
                    return _context.abrupt("return", this._providerEngineProxy.request({
                      method: "eth_accounts"
                    }));
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function enable() {
            return _enable.apply(this, arguments);
          }
          return enable;
        }()
      }, {
        key: "setupProvider",
        value: function() {
          var _setupProvider = _asyncToGenerator(import_regenerator.default.mark(function _callee2(connector) {
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this.onConnectorStateUpdate(connector);
                    _context2.next = 3;
                    return this.setupEngine(connector);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function setupProvider(_x) {
            return _setupProvider.apply(this, arguments);
          }
          return setupProvider;
        }()
      }, {
        key: "switchChain",
        value: function() {
          var _switchChain = _asyncToGenerator(import_regenerator.default.mark(function _callee3(_ref2) {
            var chainId, _ref2$addChain, addChain, _ref2$lookup, lookup, currentChainConfig, rpcTarget, displayName;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    chainId = _ref2.chainId, _ref2$addChain = _ref2.addChain, addChain = _ref2$addChain === void 0 ? true : _ref2$addChain, _ref2$lookup = _ref2.lookup, lookup = _ref2$lookup === void 0 ? true : _ref2$lookup;
                    if (this.connector) {
                      _context3.next = 3;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Connector is not initialized, pass wallet connect connector in constructor",
                      code: 4902
                    });
                  case 3:
                    currentChainConfig = this.getChainConfig(chainId);
                    this.update({
                      chainId: "loading"
                    });
                    rpcTarget = currentChainConfig.rpcTarget, displayName = currentChainConfig.displayName;
                    if (!addChain) {
                      _context3.next = 15;
                      break;
                    }
                    _context3.prev = 7;
                    _context3.next = 10;
                    return this.connector.sendCustomRequest({
                      method: "wallet_addEthereumChain",
                      params: [{
                        chainId,
                        chainName: displayName,
                        rpcUrls: [rpcTarget]
                      }]
                    });
                  case 10:
                    _context3.next = 15;
                    break;
                  case 12:
                    _context3.prev = 12;
                    _context3.t0 = _context3["catch"](7);
                    log.error(_context3.t0);
                  case 15:
                    _context3.prev = 15;
                    _context3.next = 18;
                    return this.connector.sendCustomRequest({
                      method: "wallet_switchEthereumChain",
                      params: [{
                        chainId
                      }]
                    });
                  case 18:
                    _context3.next = 25;
                    break;
                  case 20:
                    _context3.prev = 20;
                    _context3.t1 = _context3["catch"](15);
                    log.error(_context3.t1);
                    if (!(_context3.t1.message !== "JSON RPC response format is invalid")) {
                      _context3.next = 25;
                      break;
                    }
                    throw _context3.t1;
                  case 25:
                    this.configure({
                      chainConfig: currentChainConfig
                    });
                    if (!lookup) {
                      _context3.next = 29;
                      break;
                    }
                    _context3.next = 29;
                    return this.lookupNetwork(this.connector);
                  case 29:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[7, 12], [15, 20]]);
          }));
          function switchChain(_x2) {
            return _switchChain.apply(this, arguments);
          }
          return switchChain;
        }()
      }, {
        key: "addChain",
        value: function() {
          var _addChain = _asyncToGenerator(import_regenerator.default.mark(function _callee4(chainConfig) {
            var rpcTarget, displayName;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this.connector) {
                      _context4.next = 2;
                      break;
                    }
                    throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
                  case 2:
                    rpcTarget = chainConfig.rpcTarget, displayName = chainConfig.displayName;
                    _context4.prev = 3;
                    _context4.next = 6;
                    return this.connector.sendCustomRequest({
                      method: "wallet_addEthereumChain",
                      params: [{
                        chainId: chainConfig.chainId,
                        chainName: displayName,
                        rpcUrls: [rpcTarget]
                      }]
                    });
                  case 6:
                    _get(_getPrototypeOf(WalletConnectProvider2.prototype), "addChain", this).call(this, chainConfig);
                    _context4.next = 13;
                    break;
                  case 9:
                    _context4.prev = 9;
                    _context4.t0 = _context4["catch"](3);
                    log.error(_context4.t0);
                    throw _context4.t0;
                  case 13:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[3, 9]]);
          }));
          function addChain(_x3) {
            return _addChain.apply(this, arguments);
          }
          return addChain;
        }()
      }, {
        key: "lookupNetwork",
        value: function() {
          var _lookupNetwork = _asyncToGenerator(import_regenerator.default.mark(function _callee5(connector) {
            var chainId, connectedHexChainId;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (connector.connected) {
                      _context5.next = 2;
                      break;
                    }
                    throw WalletLoginError.notConnectedError("Wallet connect connector is not connected");
                  case 2:
                    if (this.provider) {
                      _context5.next = 4;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Provider is not initialized",
                      code: 4902
                    });
                  case 4:
                    chainId = this.config.chainConfig.chainId;
                    connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : "0x".concat(connector.chainId.toString(16));
                    if (!(chainId !== connectedHexChainId)) {
                      _context5.next = 8;
                      break;
                    }
                    throw WalletInitializationError.rpcConnectionError("Invalid network, net_version is: ".concat(connectedHexChainId, ", expected: ").concat(chainId));
                  case 8:
                    this.provider.emit("connect", {
                      chainId
                    });
                    this.provider.emit("chainChanged", this.state.chainId);
                    return _context5.abrupt("return", connectedHexChainId);
                  case 11:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function lookupNetwork(_x4) {
            return _lookupNetwork.apply(this, arguments);
          }
          return lookupNetwork;
        }()
      }, {
        key: "setupEngine",
        value: function() {
          var _setupEngine = _asyncToGenerator(import_regenerator.default.mark(function _callee6(connector) {
            var providerHandlers, ethMiddleware, engine, _createJsonRpcClient, networkMiddleware, provider;
            return import_regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    providerHandlers = getProviderHandlers$1({
                      connector
                    });
                    this.update({
                      accounts: connector.accounts || []
                    });
                    ethMiddleware = createEthMiddleware(providerHandlers);
                    engine = new JRPCEngine();
                    _createJsonRpcClient = createJsonRpcClient(this.config.chainConfig), networkMiddleware = _createJsonRpcClient.networkMiddleware;
                    engine.push(ethMiddleware);
                    engine.push(networkMiddleware);
                    provider = providerFromEngine(engine);
                    this.updateProviderEngineProxy(provider);
                    if (this.config.skipLookupNetwork) {
                      _context6.next = 12;
                      break;
                    }
                    _context6.next = 12;
                    return this.lookupNetwork(connector);
                  case 12:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));
          function setupEngine(_x5) {
            return _setupEngine.apply(this, arguments);
          }
          return setupEngine;
        }()
      }, {
        key: "onConnectorStateUpdate",
        value: function() {
          var _onConnectorStateUpdate = _asyncToGenerator(import_regenerator.default.mark(function _callee8(connector) {
            var _this2 = this;
            return import_regenerator.default.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    connector.on("session_update", function() {
                      var _ref3 = _asyncToGenerator(import_regenerator.default.mark(function _callee7(error, payload) {
                        var _payload$params$, accounts, connectedChainId, rpcUrl, connectedHexChainId, maybeConfig;
                        return import_regenerator.default.wrap(function _callee7$(_context7) {
                          while (1) {
                            switch (_context7.prev = _context7.next) {
                              case 0:
                                if (_this2.provider) {
                                  _context7.next = 2;
                                  break;
                                }
                                throw WalletLoginError.notConnectedError("Wallet connect connector is not connected");
                              case 2:
                                if (!error) {
                                  _context7.next = 5;
                                  break;
                                }
                                _this2.provider.emit("error", error);
                                return _context7.abrupt("return");
                              case 5:
                                _payload$params$ = payload.params[0], accounts = _payload$params$.accounts, connectedChainId = _payload$params$.chainId, rpcUrl = _payload$params$.rpcUrl;
                                if (accounts !== null && accounts !== void 0 && accounts.length && _this2.state.accounts[0] !== accounts[0]) {
                                  _this2.update({
                                    accounts
                                  });
                                  _this2.provider.emit("accountsChanged", accounts);
                                }
                                connectedHexChainId = "0x".concat(connectedChainId.toString(16));
                                if (!(connectedChainId && _this2.state.chainId !== connectedHexChainId)) {
                                  _context7.next = 13;
                                  break;
                                }
                                maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {};
                                _this2.configure({
                                  chainConfig: _objectSpread$4(_objectSpread$4({}, maybeConfig), {}, {
                                    chainId: connectedHexChainId,
                                    rpcTarget: rpcUrl,
                                    chainNamespace: CHAIN_NAMESPACES.EIP155
                                  })
                                });
                                _context7.next = 13;
                                return _this2.setupEngine(connector);
                              case 13:
                              case "end":
                                return _context7.stop();
                            }
                          }
                        }, _callee7);
                      }));
                      return function(_x7, _x8) {
                        return _ref3.apply(this, arguments);
                      };
                    }());
                  case 1:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8);
          }));
          function onConnectorStateUpdate(_x6) {
            return _onConnectorStateUpdate.apply(this, arguments);
          }
          return onConnectorStateUpdate;
        }()
      }]);
      return WalletConnectProvider2;
    }(BaseProvider);
    _defineProperty(WalletConnectProvider, "getProviderInstance", function() {
      var _ref4 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(params) {
        var providerFactory;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                providerFactory = new WalletConnectProvider({
                  config: {
                    chainConfig: params.chainConfig,
                    skipLookupNetwork: params.skipLookupNetwork
                  }
                });
                _context9.next = 3;
                return providerFactory.setupProvider(params.connector);
              case 3:
                return _context9.abrupt("return", providerFactory);
              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      return function(_x9) {
        return _ref4.apply(this, arguments);
      };
    }());
    BIG_NUMBER_WEI_MULTIPLIER = new bignumber_default("1e18");
    BIG_NUMBER_GWEI_MULTIPLIER = new bignumber_default("1e9");
    BIG_NUMBER_ETH_MULTIPLIER = new bignumber_default("1");
    toBigNumber = {
      hex: function hex(n) {
        return typeof n === "string" ? new bignumber_default((0, import_util.stripHexPrefix)(n), 16) : new bignumber_default(n, 16);
      },
      dec: function dec(n) {
        return new bignumber_default(n, 10);
      }
    };
    toNormalizedDenomination = {
      WEI: function WEI(bigNumber) {
        return bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER);
      },
      GWEI: function GWEI(bigNumber) {
        return bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER);
      },
      ETH: function ETH(bigNumber) {
        return bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER);
      }
    };
    toSpecifiedDenomination = {
      WEI: function WEI2(bigNumber) {
        return bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, bignumber_default.ROUND_HALF_UP);
      },
      GWEI: function GWEI2(bigNumber) {
        return bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, bignumber_default.ROUND_HALF_UP);
      },
      ETH: function ETH2(bigNumber) {
        return bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, bignumber_default.ROUND_HALF_UP);
      }
    };
    baseChange = {
      hex: function hex2(n) {
        return n.toString(16);
      },
      dec: function dec2(n) {
        return new bignumber_default(n).toString(10);
      }
    };
    converter = function converter2(params) {
      var value = params.value, fromNumericBase = params.fromNumericBase, fromDenomination = params.fromDenomination, toNumericBase = params.toNumericBase, toDenomination = params.toDenomination, numberOfDecimals = params.numberOfDecimals;
      var convertedValue = toBigNumber[fromNumericBase](value);
      if (fromDenomination) {
        convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
      }
      if (toDenomination) {
        convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
      }
      if (numberOfDecimals) {
        convertedValue = convertedValue.dp(numberOfDecimals, bignumber_default.ROUND_HALF_DOWN);
      }
      if (toNumericBase) {
        convertedValue = baseChange[toNumericBase](convertedValue);
      }
      return convertedValue;
    };
    conversionUtil = function conversionUtil2(value, _ref) {
      var _ref$fromNumericBase = _ref.fromNumericBase, fromNumericBase = _ref$fromNumericBase === void 0 ? "hex" : _ref$fromNumericBase, toNumericBase = _ref.toNumericBase, fromDenomination = _ref.fromDenomination, toDenomination = _ref.toDenomination, numberOfDecimals = _ref.numberOfDecimals;
      return converter({
        fromNumericBase,
        toNumericBase,
        fromDenomination,
        toDenomination,
        numberOfDecimals,
        value: value || "0"
      });
    };
    validateTypedMessageParams = function validateTypedMessageParams2(parameters, activeChainId) {
      var _data$domain;
      try {
        import_assert.default.ok(parameters && _typeof(parameters) === "object", "Params must be an object.");
        import_assert.default.ok("data" in parameters, 'Params must include a "data" field.');
        import_assert.default.ok("from" in parameters, 'Params must include a "from" field.');
        import_assert.default.ok(typeof parameters.from === "string" && (0, import_util.isValidAddress)(parameters.from), '"from" field must be a valid, lowercase, hexadecimal Ethereum address string.');
        var data = null;
        var chainId = null;
        switch (parameters.version) {
          case import_eth_sig_util.SignTypedDataVersion.V1:
            if (typeof parameters.data === "string") {
              import_assert.default.doesNotThrow(function() {
                data = JSON.parse(parameters.data);
              }, '"data" must be a valid JSON string.');
            } else {
              data = parameters.data;
            }
            import_assert.default.ok(Array.isArray(data), "params.data must be an array.");
            import_assert.default.doesNotThrow(function() {
              (0, import_eth_sig_util.typedSignatureHash)(data);
            }, "Signing data must be valid EIP-712 typed data.");
            break;
          case import_eth_sig_util.SignTypedDataVersion.V3:
          case import_eth_sig_util.SignTypedDataVersion.V4:
            if (typeof parameters.data === "string") {
              import_assert.default.doesNotThrow(function() {
                data = JSON.parse(parameters.data);
              }, '"data" must be a valid JSON string.');
            } else {
              data = parameters.data;
            }
            import_assert.default.ok(data.primaryType in data.types, 'Primary type of "'.concat(data.primaryType, '" has no type definition.'));
            var validation = import_jsonschema.default.validate(data, import_eth_sig_util.TYPED_MESSAGE_SCHEMA.properties);
            import_assert.default.strictEqual(validation.errors.length, 0, "Signing data must conform to EIP-712 schema. See https://git.io/fNtcx.");
            chainId = (_data$domain = data.domain) === null || _data$domain === void 0 ? void 0 : _data$domain.chainId;
            if (chainId) {
              import_assert.default.ok(!Number.isNaN(activeChainId), 'Cannot sign messages for chainId "'.concat(chainId, '", because Web3Auth is switching networks.'));
              if (typeof chainId === "string") {
                chainId = Number.parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
              }
              import_assert.default.strictEqual(chainId, activeChainId, 'Provided chainId "'.concat(chainId, '" must match the active chainId "').concat(activeChainId, '"'));
            }
            break;
          default:
            import_assert.default.fail('Unknown typed data version "'.concat(parameters.version, '"'));
        }
      } catch (error) {
        throw import_eth_rpc_errors.ethErrors.rpc.invalidInput({
          message: error === null || error === void 0 ? void 0 : error.message
        });
      }
    };
    LegacyGasAPIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices";
    EIP1559APIEndpoint = "https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees";
    TRANSACTION_ENVELOPE_TYPES = {
      LEGACY: "0x0",
      ACCESS_LIST: "0x1",
      FEE_MARKET: "0x2"
    };
    TRANSACTION_TYPES = {
      SENT_ETHER: "sentEther",
      CONTRACT_INTERACTION: "contractInteraction",
      DEPLOY_CONTRACT: "contractDeployment",
      STANDARD_TRANSACTION: "transaction"
    };
    GAS_ESTIMATE_TYPES = {
      FEE_MARKET: "fee-market",
      LEGACY: "legacy",
      ETH_GASPRICE: "eth_gasPrice",
      NONE: "none"
    };
    TransactionFormatter = function() {
      function TransactionFormatter2(_ref) {
        var getProviderEngineProxy = _ref.getProviderEngineProxy;
        _classCallCheck(this, TransactionFormatter2);
        _defineProperty(this, "chainConfig", null);
        _defineProperty(this, "getProviderEngineProxy", void 0);
        _defineProperty(this, "isEIP1559Compatible", false);
        this.getProviderEngineProxy = getProviderEngineProxy;
      }
      _createClass(TransactionFormatter2, [{
        key: "providerProxy",
        get: function get2() {
          return this.getProviderEngineProxy();
        }
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.providerProxy.request({
                      method: "eth_provider_config",
                      params: []
                    });
                  case 2:
                    this.chainConfig = _context.sent;
                    _context.next = 5;
                    return this.getEIP1559Compatibility();
                  case 5:
                    this.isEIP1559Compatible = _context.sent;
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "getCommonConfiguration",
        value: function() {
          var _getCommonConfiguration = _asyncToGenerator(import_regenerator.default.mark(function _callee2() {
            var _this$chainConfig, name, chainId, hardfork, customChainParams;
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.chainConfig) {
                      _context2.next = 2;
                      break;
                    }
                    throw new Error("Chain config not initialized");
                  case 2:
                    _this$chainConfig = this.chainConfig, name = _this$chainConfig.displayName, chainId = _this$chainConfig.chainId;
                    hardfork = this.isEIP1559Compatible ? import_common.Hardfork.London : import_common.Hardfork.Berlin;
                    customChainParams = {
                      name,
                      chainId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
                      networkId: chainId === "loading" ? 0 : Number.parseInt(chainId, 16),
                      defaultHardfork: hardfork
                    };
                    return _context2.abrupt("return", import_common.Common.custom(customChainParams));
                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function getCommonConfiguration() {
            return _getCommonConfiguration.apply(this, arguments);
          }
          return getCommonConfiguration;
        }()
      }, {
        key: "formatTransaction",
        value: function() {
          var _formatTransaction = _asyncToGenerator(import_regenerator.default.mark(function _callee3(txParams) {
            var clonedTxParams, defaultGasLimit, _defaultGasLimit, _yield$this$getDefaul, defaultGasPrice, defaultMaxFeePerGas, defaultMaxPriorityFeePerGas;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (this.chainConfig) {
                      _context3.next = 2;
                      break;
                    }
                    throw new Error("Chain config not initialized");
                  case 2:
                    clonedTxParams = _objectSpread$1({}, txParams);
                    if (!(clonedTxParams.nonce === void 0)) {
                      _context3.next = 7;
                      break;
                    }
                    _context3.next = 6;
                    return this.providerProxy.request({
                      method: "eth_getTransactionCount",
                      params: [txParams.from, "latest"]
                    });
                  case 6:
                    clonedTxParams.nonce = _context3.sent;
                  case 7:
                    if (!(!this.isEIP1559Compatible && clonedTxParams.gasPrice)) {
                      _context3.next = 19;
                      break;
                    }
                    if (clonedTxParams.maxFeePerGas)
                      delete clonedTxParams.maxFeePerGas;
                    if (clonedTxParams.maxPriorityFeePerGas)
                      delete clonedTxParams.maxPriorityFeePerGas;
                    if (clonedTxParams.gas) {
                      _context3.next = 17;
                      break;
                    }
                    _context3.next = 13;
                    return this.getDefaultGasLimit(clonedTxParams);
                  case 13:
                    defaultGasLimit = _context3.sent;
                    if (defaultGasLimit) {
                      clonedTxParams.gasLimit = defaultGasLimit;
                    }
                    _context3.next = 18;
                    break;
                  case 17:
                    clonedTxParams.gasLimit = clonedTxParams.gas;
                  case 18:
                    return _context3.abrupt("return", clonedTxParams);
                  case 19:
                    if (clonedTxParams.gas) {
                      _context3.next = 26;
                      break;
                    }
                    _context3.next = 22;
                    return this.getDefaultGasLimit(clonedTxParams);
                  case 22:
                    _defaultGasLimit = _context3.sent;
                    if (_defaultGasLimit) {
                      clonedTxParams.gasLimit = _defaultGasLimit;
                    }
                    _context3.next = 27;
                    break;
                  case 26:
                    clonedTxParams.gasLimit = clonedTxParams.gas;
                  case 27:
                    _context3.next = 29;
                    return this.getDefaultGasFees(clonedTxParams);
                  case 29:
                    _yield$this$getDefaul = _context3.sent;
                    defaultGasPrice = _yield$this$getDefaul.gasPrice;
                    defaultMaxFeePerGas = _yield$this$getDefaul.maxFeePerGas;
                    defaultMaxPriorityFeePerGas = _yield$this$getDefaul.maxPriorityFeePerGas;
                    if (this.isEIP1559Compatible) {
                      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;
                        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === "string" ? (0, import_util.stripHexPrefix)(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === "string" ? (0, import_util.stripHexPrefix)(clonedTxParams.gasPrice) : clonedTxParams.gasPrice) ? defaultMaxPriorityFeePerGas : clonedTxParams.gasPrice;
                      } else {
                        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {
                          clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;
                        }
                        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                          clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;
                        }
                        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {
                          clonedTxParams.maxFeePerGas = defaultGasPrice;
                        }
                        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {
                          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;
                        }
                      }
                      delete clonedTxParams.gasPrice;
                    } else {
                      delete clonedTxParams.maxPriorityFeePerGas;
                      delete clonedTxParams.maxFeePerGas;
                    }
                    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {
                      clonedTxParams.gasPrice = defaultGasPrice;
                    }
                    clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;
                    clonedTxParams.chainId = this.chainConfig.chainId;
                    return _context3.abrupt("return", clonedTxParams);
                  case 38:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function formatTransaction(_x) {
            return _formatTransaction.apply(this, arguments);
          }
          return formatTransaction;
        }()
      }, {
        key: "fetchEthGasPriceEstimate",
        value: function() {
          var _fetchEthGasPriceEstimate = _asyncToGenerator(import_regenerator.default.mark(function _callee4() {
            var gasPrice;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this.providerProxy.request({
                      method: "eth_gasPrice",
                      params: []
                    });
                  case 2:
                    gasPrice = _context4.sent;
                    return _context4.abrupt("return", {
                      gasPrice: hexWEIToDecGWEI(gasPrice).toString()
                    });
                  case 4:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function fetchEthGasPriceEstimate() {
            return _fetchEthGasPriceEstimate.apply(this, arguments);
          }
          return fetchEthGasPriceEstimate;
        }()
      }, {
        key: "getEIP1559Compatibility",
        value: function() {
          var _getEIP1559Compatibility = _asyncToGenerator(import_regenerator.default.mark(function _callee5() {
            var latestBlock, supportsEIP1559;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return this.providerProxy.request({
                      method: "eth_getBlockByNumber",
                      params: ["latest", false]
                    });
                  case 2:
                    latestBlock = _context5.sent;
                    supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== void 0;
                    return _context5.abrupt("return", !!supportsEIP1559);
                  case 5:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function getEIP1559Compatibility() {
            return _getEIP1559Compatibility.apply(this, arguments);
          }
          return getEIP1559Compatibility;
        }()
      }, {
        key: "fetchGasFeeEstimateData",
        value: function() {
          var _fetchGasFeeEstimateData = _asyncToGenerator(import_regenerator.default.mark(function _callee6() {
            var isLegacyGasAPICompatible, chainId, gasData, estimates, _estimates, _estimates2;
            return import_regenerator.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    if (this.chainConfig) {
                      _context6.next = 2;
                      break;
                    }
                    throw new Error("Chain config not initialized");
                  case 2:
                    isLegacyGasAPICompatible = this.chainConfig.chainId === "0x1";
                    chainId = Number.parseInt(this.chainConfig.chainId, 16);
                    _context6.prev = 4;
                    if (!this.isEIP1559Compatible) {
                      _context6.next = 12;
                      break;
                    }
                    _context6.next = 8;
                    return fetchEip1159GasEstimates(EIP1559APIEndpoint.replace("<chain_id>", "".concat(chainId)));
                  case 8:
                    estimates = _context6.sent;
                    gasData = {
                      gasFeeEstimates: estimates,
                      gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET
                    };
                    _context6.next = 20;
                    break;
                  case 12:
                    if (!isLegacyGasAPICompatible) {
                      _context6.next = 19;
                      break;
                    }
                    _context6.next = 15;
                    return fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace("<chain_id>", "".concat(chainId)));
                  case 15:
                    _estimates = _context6.sent;
                    gasData = {
                      gasFeeEstimates: _estimates,
                      gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY
                    };
                    _context6.next = 20;
                    break;
                  case 19:
                    throw new Error("Main gas fee/price estimation failed. Use fallback");
                  case 20:
                    _context6.next = 34;
                    break;
                  case 22:
                    _context6.prev = 22;
                    _context6.t0 = _context6["catch"](4);
                    _context6.prev = 24;
                    _context6.next = 27;
                    return this.fetchEthGasPriceEstimate();
                  case 27:
                    _estimates2 = _context6.sent;
                    gasData = {
                      gasFeeEstimates: _estimates2,
                      gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE
                    };
                    _context6.next = 34;
                    break;
                  case 31:
                    _context6.prev = 31;
                    _context6.t1 = _context6["catch"](24);
                    throw new Error("Gas fee/price estimation failed. Message: ".concat(_context6.t1.message));
                  case 34:
                    return _context6.abrupt("return", gasData);
                  case 35:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this, [[4, 22], [24, 31]]);
          }));
          function fetchGasFeeEstimateData() {
            return _fetchGasFeeEstimateData.apply(this, arguments);
          }
          return fetchGasFeeEstimateData;
        }()
      }, {
        key: "getDefaultGasFees",
        value: function() {
          var _getDefaultGasFees = _asyncToGenerator(import_regenerator.default.mark(function _callee7(txParams) {
            var _yield$this$fetchGasF, gasFeeEstimates, gasEstimateType, _gasFeeEstimates$medi, suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas, _yield$this$fetchEthG, gasPrice;
            return import_regenerator.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    if (!(!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas)) {
                      _context7.next = 2;
                      break;
                    }
                    return _context7.abrupt("return", {});
                  case 2:
                    _context7.prev = 2;
                    _context7.next = 5;
                    return this.fetchGasFeeEstimateData();
                  case 5:
                    _yield$this$fetchGasF = _context7.sent;
                    gasFeeEstimates = _yield$this$fetchGasF.gasFeeEstimates;
                    gasEstimateType = _yield$this$fetchGasF.gasEstimateType;
                    if (!(this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET)) {
                      _context7.next = 16;
                      break;
                    }
                    _gasFeeEstimates$medi = gasFeeEstimates.medium;
                    _gasFeeEstimates$medi = _gasFeeEstimates$medi === void 0 ? {} : _gasFeeEstimates$medi;
                    suggestedMaxPriorityFeePerGas = _gasFeeEstimates$medi.suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas = _gasFeeEstimates$medi.suggestedMaxFeePerGas;
                    if (!(suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas)) {
                      _context7.next = 14;
                      break;
                    }
                    return _context7.abrupt("return", {
                      maxFeePerGas: (0, import_util.addHexPrefix)(decGWEIToHexWEI(suggestedMaxFeePerGas)),
                      maxPriorityFeePerGas: (0, import_util.addHexPrefix)(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))
                    });
                  case 14:
                    _context7.next = 22;
                    break;
                  case 16:
                    if (!(gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY)) {
                      _context7.next = 20;
                      break;
                    }
                    return _context7.abrupt("return", {
                      gasPrice: (0, import_util.addHexPrefix)(decGWEIToHexWEI(gasFeeEstimates.medium))
                    });
                  case 20:
                    if (!(gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE)) {
                      _context7.next = 22;
                      break;
                    }
                    return _context7.abrupt("return", {
                      gasPrice: (0, import_util.addHexPrefix)(decGWEIToHexWEI(gasFeeEstimates.gasPrice))
                    });
                  case 22:
                    _context7.next = 27;
                    break;
                  case 24:
                    _context7.prev = 24;
                    _context7.t0 = _context7["catch"](2);
                    log.error(_context7.t0);
                  case 27:
                    _context7.next = 29;
                    return this.fetchEthGasPriceEstimate();
                  case 29:
                    _yield$this$fetchEthG = _context7.sent;
                    gasPrice = _yield$this$fetchEthG.gasPrice;
                    return _context7.abrupt("return", {
                      gasPrice: (0, import_util.addHexPrefix)(decGWEIToHexWEI(gasPrice))
                    });
                  case 32:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this, [[2, 24]]);
          }));
          function getDefaultGasFees(_x2) {
            return _getDefaultGasFees.apply(this, arguments);
          }
          return getDefaultGasFees;
        }()
      }, {
        key: "estimateTxGas",
        value: function() {
          var _estimateTxGas = _asyncToGenerator(import_regenerator.default.mark(function _callee8(txMeta) {
            var txParams, gas;
            return import_regenerator.default.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    txParams = _objectSpread$1({}, txMeta);
                    delete txParams.gasPrice;
                    delete txParams.maxFeePerGas;
                    delete txParams.maxPriorityFeePerGas;
                    _context8.next = 6;
                    return this.providerProxy.request({
                      method: "eth_estimateGas",
                      params: [txParams]
                    });
                  case 6:
                    gas = _context8.sent;
                    return _context8.abrupt("return", gas);
                  case 8:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));
          function estimateTxGas(_x3) {
            return _estimateTxGas.apply(this, arguments);
          }
          return estimateTxGas;
        }()
      }, {
        key: "analyzeGasUsage",
        value: function() {
          var _analyzeGasUsage = _asyncToGenerator(import_regenerator.default.mark(function _callee9(txMeta) {
            var block, blockGasLimitBN, saferGasLimitBN, estimatedGasHex;
            return import_regenerator.default.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return this.providerProxy.request({
                      method: "eth_getBlockByNumber",
                      params: ["latest", false]
                    });
                  case 2:
                    block = _context9.sent;
                    blockGasLimitBN = hexToBn(block.gasLimit);
                    saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);
                    estimatedGasHex = bnToHex(saferGasLimitBN);
                    _context9.prev = 6;
                    _context9.next = 9;
                    return this.estimateTxGas(txMeta);
                  case 9:
                    estimatedGasHex = _context9.sent;
                    _context9.next = 15;
                    break;
                  case 12:
                    _context9.prev = 12;
                    _context9.t0 = _context9["catch"](6);
                    log.warn(_context9.t0);
                  case 15:
                    return _context9.abrupt("return", {
                      blockGasLimit: block.gasLimit,
                      estimatedGasHex
                    });
                  case 16:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this, [[6, 12]]);
          }));
          function analyzeGasUsage(_x4) {
            return _analyzeGasUsage.apply(this, arguments);
          }
          return analyzeGasUsage;
        }()
      }, {
        key: "addGasBuffer",
        value: function addGasBuffer(initialGasLimitHex, blockGasLimitHex) {
          var multiplier = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1.5;
          var initialGasLimitBn = hexToBn(initialGasLimitHex);
          var blockGasLimitBn = hexToBn(blockGasLimitHex);
          var upperGasLimitBn = blockGasLimitBn.muln(0.9);
          var bufferedGasLimitBn = initialGasLimitBn.muln(multiplier);
          if (initialGasLimitBn.gt(upperGasLimitBn))
            return bnToHex(initialGasLimitBn);
          if (bufferedGasLimitBn.lt(upperGasLimitBn))
            return bnToHex(bufferedGasLimitBn);
          return bnToHex(upperGasLimitBn);
        }
      }, {
        key: "determineTransactionCategory",
        value: function() {
          var _determineTransactionCategory = _asyncToGenerator(import_regenerator.default.mark(function _callee10(txParameters) {
            var data, to, code, txCategory, codeIsEmpty;
            return import_regenerator.default.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    data = txParameters.data, to = txParameters.to;
                    code = "";
                    if (!(data && !to)) {
                      _context10.next = 6;
                      break;
                    }
                    txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;
                    _context10.next = 17;
                    break;
                  case 6:
                    _context10.prev = 6;
                    _context10.next = 9;
                    return this.providerProxy.request({
                      method: "eth_getCode",
                      params: [to, "latest"]
                    });
                  case 9:
                    code = _context10.sent;
                    _context10.next = 15;
                    break;
                  case 12:
                    _context10.prev = 12;
                    _context10.t0 = _context10["catch"](6);
                    log.warn(_context10.t0);
                  case 15:
                    codeIsEmpty = !code || code === "0x" || code === "0x0";
                    txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;
                  case 17:
                    return _context10.abrupt("return", {
                      transactionCategory: txCategory,
                      code
                    });
                  case 18:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this, [[6, 12]]);
          }));
          function determineTransactionCategory(_x5) {
            return _determineTransactionCategory.apply(this, arguments);
          }
          return determineTransactionCategory;
        }()
      }, {
        key: "getDefaultGasLimit",
        value: function() {
          var _getDefaultGasLimit = _asyncToGenerator(import_regenerator.default.mark(function _callee11(txParams) {
            var _yield$this$determine, transactionCategory, TWENTY_ONE_THOUSAND, _yield$this$analyzeGa, blockGasLimit, estimatedGasHex, gasLimit;
            return import_regenerator.default.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this.determineTransactionCategory(_objectSpread$1({}, txParams));
                  case 2:
                    _yield$this$determine = _context11.sent;
                    transactionCategory = _yield$this$determine.transactionCategory;
                    if (!txParams.gas) {
                      _context11.next = 6;
                      break;
                    }
                    return _context11.abrupt("return", txParams.gas);
                  case 6:
                    if (!(txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER)) {
                      _context11.next = 11;
                      break;
                    }
                    if (!txParams.data) {
                      _context11.next = 9;
                      break;
                    }
                    throw Error("TxGasUtil - Trying to call a function on a non-contract address");
                  case 9:
                    TWENTY_ONE_THOUSAND = 21e3;
                    return _context11.abrupt("return", (0, import_util.addHexPrefix)(TWENTY_ONE_THOUSAND.toString(16)));
                  case 11:
                    _context11.next = 13;
                    return this.analyzeGasUsage(txParams);
                  case 13:
                    _yield$this$analyzeGa = _context11.sent;
                    blockGasLimit = _yield$this$analyzeGa.blockGasLimit;
                    estimatedGasHex = _yield$this$analyzeGa.estimatedGasHex;
                    gasLimit = this.addGasBuffer((0, import_util.addHexPrefix)(estimatedGasHex), blockGasLimit);
                    return _context11.abrupt("return", gasLimit);
                  case 18:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));
          function getDefaultGasLimit(_x6) {
            return _getDefaultGasLimit.apply(this, arguments);
          }
          return getDefaultGasLimit;
        }()
      }]);
      return TransactionFormatter2;
    }();
    EthereumPrivateKeyProvider = function(_BaseProvider) {
      _inherits(EthereumPrivateKeyProvider2, _BaseProvider);
      var _super = _createSuper(EthereumPrivateKeyProvider2);
      function EthereumPrivateKeyProvider2(_ref) {
        var config = _ref.config, state = _ref.state;
        _classCallCheck(this, EthereumPrivateKeyProvider2);
        return _super.call(this, {
          config: {
            chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {
              chainNamespace: CHAIN_NAMESPACES.EIP155
            })
          },
          state
        });
      }
      _createClass(EthereumPrivateKeyProvider2, [{
        key: "enable",
        value: function() {
          var _enable = _asyncToGenerator(import_regenerator.default.mark(function _callee() {
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.state.privateKey) {
                      _context.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Private key is not found in state, plz pass it in constructor state param",
                      code: 4902
                    });
                  case 2:
                    _context.next = 4;
                    return this.setupProvider(this.state.privateKey);
                  case 4:
                    return _context.abrupt("return", this._providerEngineProxy.request({
                      method: "eth_accounts"
                    }));
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function enable() {
            return _enable.apply(this, arguments);
          }
          return enable;
        }()
      }, {
        key: "setupProvider",
        value: function() {
          var _setupProvider = _asyncToGenerator(import_regenerator.default.mark(function _callee2(privKey) {
            var txFormatter, providerHandlers, ethMiddleware, chainSwitchMiddleware, engine, _createJsonRpcClient, networkMiddleware, provider;
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    txFormatter = new TransactionFormatter({
                      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
                    });
                    providerHandlers = getProviderHandlers({
                      txFormatter,
                      privKey,
                      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
                    });
                    ethMiddleware = createEthMiddleware(providerHandlers);
                    chainSwitchMiddleware = this.getChainSwitchMiddleware();
                    engine = new JRPCEngine();
                    _createJsonRpcClient = createJsonRpcClient(this.config.chainConfig), networkMiddleware = _createJsonRpcClient.networkMiddleware;
                    engine.push(ethMiddleware);
                    engine.push(chainSwitchMiddleware);
                    engine.push(this.getAccountMiddleware());
                    engine.push(networkMiddleware);
                    provider = providerFromEngine(engine);
                    this.updateProviderEngineProxy(provider);
                    _context2.next = 14;
                    return txFormatter.init();
                  case 14:
                    _context2.next = 16;
                    return this.lookupNetwork();
                  case 16:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function setupProvider(_x) {
            return _setupProvider.apply(this, arguments);
          }
          return setupProvider;
        }()
      }, {
        key: "updateAccount",
        value: function() {
          var _updateAccount = _asyncToGenerator(import_regenerator.default.mark(function _callee3(params) {
            var existingKey;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (this._providerEngineProxy) {
                      _context3.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Provider is not initialized",
                      code: 4902
                    });
                  case 2:
                    _context3.next = 4;
                    return this._providerEngineProxy.request({
                      method: "eth_private_key"
                    });
                  case 4:
                    existingKey = _context3.sent;
                    if (!(existingKey !== params.privateKey)) {
                      _context3.next = 14;
                      break;
                    }
                    _context3.next = 8;
                    return this.setupProvider(params.privateKey);
                  case 8:
                    _context3.t0 = this._providerEngineProxy;
                    _context3.next = 11;
                    return this._providerEngineProxy.request({
                      method: "eth_accounts"
                    });
                  case 11:
                    _context3.t1 = _context3.sent;
                    _context3.t2 = {
                      accounts: _context3.t1
                    };
                    _context3.t0.emit.call(_context3.t0, "accountsChanged", _context3.t2);
                  case 14:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function updateAccount(_x2) {
            return _updateAccount.apply(this, arguments);
          }
          return updateAccount;
        }()
      }, {
        key: "switchChain",
        value: function() {
          var _switchChain = _asyncToGenerator(import_regenerator.default.mark(function _callee4(params) {
            var chainConfig, privKey;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this._providerEngineProxy) {
                      _context4.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Provider is not initialized",
                      code: 4902
                    });
                  case 2:
                    chainConfig = this.getChainConfig(params.chainId);
                    this.update({
                      chainId: "loading"
                    });
                    this.configure({
                      chainConfig
                    });
                    _context4.next = 7;
                    return this._providerEngineProxy.request({
                      method: "eth_private_key"
                    });
                  case 7:
                    privKey = _context4.sent;
                    _context4.next = 10;
                    return this.setupProvider(privKey);
                  case 10:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function switchChain(_x3) {
            return _switchChain.apply(this, arguments);
          }
          return switchChain;
        }()
      }, {
        key: "lookupNetwork",
        value: function() {
          var _lookupNetwork = _asyncToGenerator(import_regenerator.default.mark(function _callee5() {
            var chainId, network;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (this._providerEngineProxy) {
                      _context5.next = 2;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.custom({
                      message: "Provider is not initialized",
                      code: 4902
                    });
                  case 2:
                    chainId = this.config.chainConfig.chainId;
                    if (chainId) {
                      _context5.next = 5;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.rpc.invalidParams("chainId is required while lookupNetwork");
                  case 5:
                    _context5.next = 7;
                    return this._providerEngineProxy.request({
                      method: "net_version",
                      params: []
                    });
                  case 7:
                    network = _context5.sent;
                    if (!(parseInt(chainId, 16) !== parseInt(network, 10))) {
                      _context5.next = 10;
                      break;
                    }
                    throw import_eth_rpc_errors.ethErrors.provider.chainDisconnected("Invalid network, net_version is: ".concat(network));
                  case 10:
                    if (this.state.chainId !== chainId) {
                      this._providerEngineProxy.emit("chainChanged", chainId);
                      this._providerEngineProxy.emit("connect", {
                        chainId
                      });
                    }
                    this.update({
                      chainId
                    });
                    return _context5.abrupt("return", network);
                  case 13:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function lookupNetwork() {
            return _lookupNetwork.apply(this, arguments);
          }
          return lookupNetwork;
        }()
      }, {
        key: "getChainSwitchMiddleware",
        value: function getChainSwitchMiddleware() {
          var _this = this;
          var chainSwitchHandlers = {
            addChain: function() {
              var _addChain = _asyncToGenerator(import_regenerator.default.mark(function _callee6(params) {
                var chainId, chainName, rpcUrls, blockExplorerUrls, nativeCurrency;
                return import_regenerator.default.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        chainId = params.chainId, chainName = params.chainName, rpcUrls = params.rpcUrls, blockExplorerUrls = params.blockExplorerUrls, nativeCurrency = params.nativeCurrency;
                        _this.addChain({
                          chainNamespace: "eip155",
                          chainId,
                          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "ETH",
                          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Ether",
                          displayName: chainName,
                          rpcTarget: rpcUrls[0],
                          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || ""
                        });
                      case 2:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));
              function addChain(_x4) {
                return _addChain.apply(this, arguments);
              }
              return addChain;
            }(),
            switchChain: function() {
              var _switchChain2 = _asyncToGenerator(import_regenerator.default.mark(function _callee7(params) {
                var chainId;
                return import_regenerator.default.wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        chainId = params.chainId;
                        _context7.next = 3;
                        return _this.switchChain({
                          chainId
                        });
                      case 3:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7);
              }));
              function switchChain(_x5) {
                return _switchChain2.apply(this, arguments);
              }
              return switchChain;
            }()
          };
          var chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
          return chainSwitchMiddleware;
        }
      }, {
        key: "getAccountMiddleware",
        value: function getAccountMiddleware() {
          var _this2 = this;
          var accountHandlers = {
            updatePrivatekey: function() {
              var _updatePrivatekey = _asyncToGenerator(import_regenerator.default.mark(function _callee8(params) {
                var privateKey;
                return import_regenerator.default.wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        privateKey = params.privateKey;
                        _context8.next = 3;
                        return _this2.updateAccount({
                          privateKey
                        });
                      case 3:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8);
              }));
              function updatePrivatekey(_x6) {
                return _updatePrivatekey.apply(this, arguments);
              }
              return updatePrivatekey;
            }()
          };
          return createAccountMiddleware(accountHandlers);
        }
      }]);
      return EthereumPrivateKeyProvider2;
    }(BaseProvider);
    _defineProperty(EthereumPrivateKeyProvider, "getProviderInstance", function() {
      var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee9(params) {
        var providerFactory;
        return import_regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                providerFactory = new EthereumPrivateKeyProvider({
                  config: {
                    chainConfig: params.chainConfig
                  }
                });
                _context9.next = 3;
                return providerFactory.setupProvider(params.privKey);
              case 3:
                return _context9.abrupt("return", providerFactory);
              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));
      return function(_x7) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
});

export {
  WalletConnectProvider,
  getProviderHandlers,
  TransactionFormatter,
  EthereumPrivateKeyProvider,
  init_ethereumProvider_esm
};
/*! Bundled license information:

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

assert/build/internal/util/comparisons.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=chunk-X5RKVSQF.js.map
