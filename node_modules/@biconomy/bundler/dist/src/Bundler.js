"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bundler = void 0;
const utils_1 = require("ethers/lib/utils");
const common_1 = require("@biconomy/common");
const HelperFunction_1 = require("./utils/HelperFunction");
const Constants_1 = require("./utils/Constants");
const providers_1 = require("@ethersproject/providers");
/**
 * This class implements IBundler interface.
 * Implementation sends UserOperation to a bundler URL as per ERC4337 standard.
 * Checkout the proposal for more details on Bundlers.
 */
class Bundler {
    constructor(bundlerConfig) {
        this.bundlerConfig = bundlerConfig;
        this.UserOpReceiptIntervals = {
            ...Constants_1.UserOpReceiptIntervals,
            ...bundlerConfig.userOpReceiptIntervals
        };
    }
    getBundlerUrl() {
        return `${this.bundlerConfig.bundlerUrl}`;
    }
    /**
     *
     * @param chainId
     * @description This function will fetch gasPrices from bundler
     * @returns Promise<UserOpGasPricesResponse>
     */
    async estimateUserOpGas(userOp) {
        // expected dummySig and possibly dummmy paymasterAndData should be provided by the caller
        // bundler doesn't know account and paymaster implementation
        userOp = (0, HelperFunction_1.transformUserOP)(userOp);
        common_1.Logger.log('userOp sending for fee estimate ', userOp);
        const bundlerUrl = this.getBundlerUrl();
        const response = await (0, common_1.sendRequest)({
            url: bundlerUrl,
            method: common_1.HttpMethod.Post,
            body: {
                method: 'eth_estimateUserOperationGas',
                params: [userOp, this.bundlerConfig.entryPointAddress],
                id: (0, common_1.getTimestampInSeconds)(),
                jsonrpc: '2.0'
            }
        });
        const userOpGasResponse = response.result;
        for (const key in userOpGasResponse) {
            if (key === 'maxFeePerGas' || key === 'maxPriorityFeePerGas')
                continue;
            if (!userOpGasResponse[key]) {
                throw new Error(`Got undefined ${key} from bundler`);
            }
        }
        return userOpGasResponse;
    }
    /**
     *
     * @param userOp
     * @description This function will send signed userOp to bundler to get mined on chain
     * @returns Promise<UserOpResponse>
     */
    async sendUserOp(userOp) {
        const chainId = this.bundlerConfig.chainId;
        // transformUserOP will convert all bigNumber values to string
        userOp = (0, HelperFunction_1.transformUserOP)(userOp);
        const hexifiedUserOp = (0, common_1.deepHexlify)(await (0, utils_1.resolveProperties)(userOp));
        const params = [hexifiedUserOp, this.bundlerConfig.entryPointAddress];
        const bundlerUrl = this.getBundlerUrl();
        const sendUserOperationResponse = await (0, common_1.sendRequest)({
            url: bundlerUrl,
            method: common_1.HttpMethod.Post,
            body: {
                method: 'eth_sendUserOperation',
                params: params,
                id: (0, common_1.getTimestampInSeconds)(),
                jsonrpc: '2.0'
            }
        });
        const response = {
            userOpHash: sendUserOperationResponse.result,
            wait: (confirmations) => {
                const provider = new providers_1.JsonRpcProvider(common_1.RPC_PROVIDER_URLS[chainId]);
                return new Promise(async (resolve, reject) => {
                    const intervalId = setInterval(async () => {
                        try {
                            const userOpResponse = await this.getUserOpReceipt(sendUserOperationResponse.result);
                            if (userOpResponse && userOpResponse.receipt && userOpResponse.receipt.blockNumber) {
                                if (confirmations) {
                                    const latestBlock = await provider.getBlockNumber();
                                    const confirmedBlocks = latestBlock - userOpResponse.receipt.blockNumber;
                                    if (confirmations >= confirmedBlocks) {
                                        clearInterval(intervalId);
                                        resolve(userOpResponse);
                                    }
                                }
                                clearInterval(intervalId);
                                resolve(userOpResponse);
                            }
                        }
                        catch (error) {
                            clearInterval(intervalId);
                            reject(error);
                        }
                    }, this.UserOpReceiptIntervals[chainId]);
                });
            }
        };
        return response;
    }
    /**
     *
     * @param userOpHash
     * @description This function will return userOpReceipt for a given userOpHash
     * @returns Promise<UserOpReceipt>
     */
    async getUserOpReceipt(userOpHash) {
        const bundlerUrl = this.getBundlerUrl();
        const response = await (0, common_1.sendRequest)({
            url: bundlerUrl,
            method: common_1.HttpMethod.Post,
            body: {
                method: 'eth_getUserOperationReceipt',
                params: [userOpHash],
                id: (0, common_1.getTimestampInSeconds)(),
                jsonrpc: '2.0'
            }
        });
        const userOpReceipt = response.result;
        return userOpReceipt;
    }
    /**
     *
     * @param userOpHash
     * @param chainId
     * @description this function will return UserOpByHashResponse for given UserOpHash
     * @returns Promise<UserOpByHashResponse>
     */
    async getUserOpByHash(userOpHash) {
        const bundlerUrl = this.getBundlerUrl();
        const response = await (0, common_1.sendRequest)({
            url: bundlerUrl,
            method: common_1.HttpMethod.Post,
            body: {
                method: 'eth_getUserOperationByHash',
                params: [userOpHash],
                id: (0, common_1.getTimestampInSeconds)(),
                jsonrpc: '2.0'
            }
        });
        const userOpByHashResponse = response.result;
        return userOpByHashResponse;
    }
}
exports.Bundler = Bundler;
//# sourceMappingURL=Bundler.js.map