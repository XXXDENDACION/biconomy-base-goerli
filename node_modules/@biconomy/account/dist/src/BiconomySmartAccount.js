"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BiconomySmartAccount = void 0;
const providers_1 = require("@ethersproject/providers");
const ethers_1 = require("ethers");
const SmartAccount_1 = require("./SmartAccount");
const common_1 = require("@biconomy/common");
const core_types_1 = require("@biconomy/core-types");
const node_client_1 = __importDefault(require("@biconomy/node-client"));
const paymaster_1 = require("@biconomy/paymaster");
const Constants_1 = require("./utils/Constants");
class BiconomySmartAccount extends SmartAccount_1.SmartAccount {
    constructor(biconomySmartAccountConfig) {
        const { signer, rpcUrl, entryPointAddress, bundler, paymaster, chainId, nodeClientUrl } = biconomySmartAccountConfig;
        const _entryPointAddress = entryPointAddress !== null && entryPointAddress !== void 0 ? entryPointAddress : Constants_1.DEFAULT_ENTRYPOINT_ADDRESS;
        super({
            bundler,
            entryPointAddress: _entryPointAddress
        });
        this.biconomySmartAccountConfig = biconomySmartAccountConfig;
        const _rpcUrl = rpcUrl !== null && rpcUrl !== void 0 ? rpcUrl : common_1.RPC_PROVIDER_URLS[chainId];
        if (!_rpcUrl) {
            throw new Error(`Chain Id ${chainId} is not supported. Please refer to the following link for supported chains list https://docs.biconomy.io/build-with-biconomy-sdk/gasless-transactions#supported-chains`);
        }
        this.provider = new providers_1.JsonRpcProvider(_rpcUrl);
        this.nodeClient = new node_client_1.default({ txServiceUrl: nodeClientUrl !== null && nodeClientUrl !== void 0 ? nodeClientUrl : common_1.NODE_CLIENT_URL });
        this.signer = signer;
        if (paymaster) {
            this.paymaster = paymaster;
        }
        if (bundler)
            this.bundler = bundler;
    }
    /**
     * @description This function will initialise BiconomyAccount class state
     * @returns Promise<BiconomyAccount>
     */
    async init(initilizationData) {
        try {
            let _accountIndex, signerAddress;
            if (initilizationData) {
                _accountIndex = initilizationData.accountIndex;
                signerAddress = initilizationData.signerAddress;
            }
            if (!_accountIndex)
                _accountIndex = 0;
            this.isProviderDefined();
            this.isSignerDefined();
            if (signerAddress) {
                this.owner = signerAddress;
            }
            else {
                this.owner = await this.signer.getAddress();
            }
            this.chainId = await this.provider.getNetwork().then((net) => net.chainId);
            await this.initializeAccountAtIndex(_accountIndex);
            this._isInitialised = true;
        }
        catch (error) {
            common_1.Logger.error(`Failed to call init: ${error}`);
            throw error;
        }
        return this;
    }
    isInitialized() {
        if (!this._isInitialised)
            throw new Error('BiconomySmartAccount is not initialized. Please call init() on BiconomySmartAccount instance before interacting with any other function');
        return true;
    }
    setProxyContractState() {
        if (!Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES[this.smartAccountInfo.implementationAddress])
            throw new Error('Could not find attached implementation address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.');
        const proxyInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.BICONOMY_IMPLEMENTATION_ADDRESSES[this.address],
            contractAddress: this.address,
            provider: this.provider
        };
        this.proxy = (0, common_1.getSAProxyContract)(proxyInstanceDto);
    }
    setEntryPointContractState() {
        const _entryPointAddress = this.smartAccountInfo.entryPointAddress;
        this.setEntryPointAddress(_entryPointAddress);
        if (!Constants_1.ENTRYPOINT_ADDRESSES[_entryPointAddress])
            throw new Error('Could not find attached entrypoint address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.');
        const entryPointInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.ENTRYPOINT_ADDRESSES[_entryPointAddress],
            contractAddress: _entryPointAddress,
            provider: this.provider
        };
        this.entryPoint = (0, common_1.getEntryPointContract)(entryPointInstanceDto);
    }
    setFactoryContractState() {
        const _factoryAddress = this.smartAccountInfo.factoryAddress;
        if (!Constants_1.BICONOMY_FACTORY_ADDRESSES[_factoryAddress])
            throw new Error('Could not find attached factory address against your smart account. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.');
        const factoryInstanceDto = {
            smartAccountType: core_types_1.SmartAccountType.BICONOMY,
            version: Constants_1.BICONOMY_FACTORY_ADDRESSES[_factoryAddress],
            contractAddress: _factoryAddress,
            provider: this.provider
        };
        this.factory = (0, common_1.getSAFactoryContract)(factoryInstanceDto);
    }
    async setContractsState() {
        this.setProxyContractState();
        this.setEntryPointContractState();
        this.setFactoryContractState();
    }
    async initializeAccountAtIndex(accountIndex) {
        this.accountIndex = accountIndex;
        this.address = await this.getSmartAccountAddress(accountIndex);
        await this.setContractsState();
        await this.setInitCode(this.accountIndex);
    }
    async getSmartAccountAddress(accountIndex = 0) {
        try {
            this.isSignerDefined();
            let smartAccountsList = (await this.getSmartAccountsByOwner({
                chainId: this.chainId,
                owner: this.owner,
                index: accountIndex
            })).data;
            if (!smartAccountsList)
                throw new Error('Failed to get smart account address. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.');
            smartAccountsList = smartAccountsList.filter((smartAccount) => {
                return accountIndex === smartAccount.index;
            });
            if (smartAccountsList.length === 0)
                throw new Error('Failed to get smart account address. Please raise an issue on https://github.com/bcnmy/biconomy-client-sdk for further investigation.');
            this.smartAccountInfo = smartAccountsList[0];
            return this.smartAccountInfo.smartAccountAddress;
        }
        catch (error) {
            common_1.Logger.error(`Failed to get smart account address: ${error}`);
            throw error;
        }
    }
    async setInitCode(accountIndex = 0) {
        this.initCode = ethers_1.ethers.utils.hexConcat([
            this.factory.address,
            this.factory.interface.encodeFunctionData('deployCounterFactualAccount', [
                this.owner,
                ethers_1.ethers.BigNumber.from(accountIndex)
            ])
        ]);
        return this.initCode;
    }
    /**
     * @description an overrided function to showcase overriding example
     * @returns
     */
    nonce() {
        this.isProxyDefined();
        return this.proxy.nonce();
    }
    /**
     *
     * @param to { target } address of transaction
     * @param value  represents amount of native tokens
     * @param data represent data associated with transaction
     * @returns
     */
    getExecuteCallData(to, value, data) {
        this.isInitialized();
        this.isProxyDefined();
        const executeCallData = this.proxy.interface.encodeFunctionData('executeCall', [
            to,
            value,
            data
        ]);
        return executeCallData;
    }
    /**
     *
     * @param to { target } array of addresses in transaction
     * @param value  represents array of amount of native tokens associated with each transaction
     * @param data represent array of data associated with each transaction
     * @returns
     */
    getExecuteBatchCallData(to, value, data) {
        this.isInitialized();
        this.isProxyDefined();
        const executeBatchCallData = this.proxy.interface.encodeFunctionData('executeBatchCall', [
            to,
            value,
            data
        ]);
        return executeBatchCallData;
    }
    getDummySignature() {
        return '0x73c3ac716c487ca34bb858247b5ccf1dc354fbaabdd089af3b2ac8e78ba85a4959a2d76250325bd67c11771c31fccda87c33ceec17cc0de912690521bb95ffcb1b';
    }
    getDummyPaymasterData() {
        return '0x';
    }
    async buildUserOp(transactions, overrides, skipBundlerGasEstimation) {
        this.isInitialized();
        // TODO: validate to, value and data fields
        // TODO: validate overrides if supplied
        const to = transactions.map((element) => element.to);
        const data = transactions.map((element) => { var _a; return (_a = element.data) !== null && _a !== void 0 ? _a : '0x'; });
        const value = transactions.map((element) => { var _a; return (_a = element.value) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from('0'); });
        this.isProxyDefined();
        let callData = '';
        if (transactions.length === 1) {
            callData = this.getExecuteCallData(to[0], value[0], data[0]);
        }
        else {
            callData = this.getExecuteBatchCallData(to, value, data);
        }
        let nonce = ethers_1.BigNumber.from(0);
        try {
            nonce = await this.nonce();
        }
        catch (error) {
            // Not throwing this error as nonce would be 0 if this.nonce() throw exception, which is expected flow for undeployed account
        }
        let userOp = {
            sender: this.address,
            nonce,
            initCode: nonce.eq(0) ? this.initCode : '0x',
            callData: callData
        };
        // for this Smart Account dummy ECDSA signature will be used to estimate gas
        userOp.signature = this.getDummySignature();
        userOp = await this.estimateUserOpGas(userOp, overrides, skipBundlerGasEstimation);
        common_1.Logger.log('userOp after estimation ', userOp);
        // Do not populate paymasterAndData as part of buildUserOp as it may not have all necessary details
        userOp.paymasterAndData = '0x'; // await this.getPaymasterAndData(userOp)
        return userOp;
    }
    validateUserOpAndRequest(userOp, tokenPaymasterRequest) {
        var _a;
        if (!userOp.callData) {
            throw new Error('Userop callData cannot be undefined');
        }
        const feeTokenAddress = (_a = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.feeQuote) === null || _a === void 0 ? void 0 : _a.tokenAddress;
        common_1.Logger.log('requested fee token is ', feeTokenAddress);
        if (!feeTokenAddress || feeTokenAddress == ethers_1.ethers.constants.AddressZero) {
            throw new Error('Invalid or missing token address. Token address must be part of the feeQuote in tokenPaymasterRequest');
        }
        const spender = tokenPaymasterRequest === null || tokenPaymasterRequest === void 0 ? void 0 : tokenPaymasterRequest.spender;
        common_1.Logger.log('fee token approval to be checked and added for spender: ', spender);
        if (!spender || spender == ethers_1.ethers.constants.AddressZero) {
            throw new Error('Invalid or missing spender address. Sepnder address must be part of tokenPaymasterRequest');
        }
    }
    /**
     *
     * @param userOp partial user operation without signature and paymasterAndData
     * @param tokenPaymasterRequest This dto provides information about fee quote. Fee quote is received from earlier request getFeeQuotesOrData() to the Biconomy paymaster.
     *  maxFee and token decimals from the quote, along with the spender is required to append approval transaction.
     * @notice This method should be called when gas is paid in ERC20 token using TokenPaymaster
     * @description Optional method to update the userOp.calldata with batched transaction which approves the paymaster spender with necessary amount(if required)
     * @returns updated userOp with new callData, callGasLimit
     */
    async buildTokenPaymasterUserOp(userOp, tokenPaymasterRequest) {
        this.validateUserOpAndRequest(userOp, tokenPaymasterRequest);
        try {
            let batchTo = [];
            let batchValue = [];
            let batchData = [];
            let newCallData = userOp.callData;
            common_1.Logger.log('received information about fee token address and quote ', tokenPaymasterRequest);
            if (this.paymaster && this.paymaster instanceof paymaster_1.BiconomyPaymaster) {
                // Make a call to paymaster.buildTokenApprovalTransaction() with necessary details
                // Review: might request this form of an array of Transaction
                const approvalRequest = await this.paymaster.buildTokenApprovalTransaction(tokenPaymasterRequest, this.provider);
                common_1.Logger.log('approvalRequest is for erc20 token ', approvalRequest.to);
                if (approvalRequest.data == '0x' || approvalRequest.to == ethers_1.ethers.constants.AddressZero) {
                    return userOp;
                }
                if (!userOp.callData) {
                    throw new Error('Userop callData cannot be undefined');
                }
                const decodedDataSmartWallet = this.proxy.interface.parseTransaction({
                    data: userOp.callData.toString()
                });
                if (!decodedDataSmartWallet) {
                    throw new Error('Could not parse call data of smart wallet for userOp');
                }
                const smartWalletExecFunctionName = decodedDataSmartWallet.name;
                if (smartWalletExecFunctionName === 'executeCall') {
                    common_1.Logger.log('originally an executeCall for Biconomy Account');
                    const methodArgsSmartWalletExecuteCall = decodedDataSmartWallet.args;
                    const toOriginal = methodArgsSmartWalletExecuteCall[0];
                    const valueOriginal = methodArgsSmartWalletExecuteCall[1];
                    const dataOriginal = methodArgsSmartWalletExecuteCall[2];
                    batchTo.push(toOriginal);
                    batchValue.push(valueOriginal);
                    batchData.push(dataOriginal);
                }
                else if (smartWalletExecFunctionName === 'executeBatchCall') {
                    common_1.Logger.log('originally an executeBatchCall for Biconomy Account');
                    const methodArgsSmartWalletExecuteCall = decodedDataSmartWallet.args;
                    batchTo = methodArgsSmartWalletExecuteCall[0];
                    batchValue = methodArgsSmartWalletExecuteCall[1];
                    batchData = methodArgsSmartWalletExecuteCall[2];
                }
                if (approvalRequest.to && approvalRequest.data && approvalRequest.value) {
                    batchTo = [approvalRequest.to, ...batchTo];
                    batchValue = [approvalRequest.value, ...batchValue];
                    batchData = [approvalRequest.data, ...batchData];
                    newCallData = this.getExecuteBatchCallData(batchTo, batchValue, batchData);
                }
                let finalUserOp = {
                    ...userOp,
                    callData: newCallData
                };
                // Requesting to update gas limits again (especially callGasLimit needs to be re-calculated)
                finalUserOp = await this.estimateUserOpGas(finalUserOp);
                common_1.Logger.log('userOp after estimation ', finalUserOp);
                return finalUserOp;
            }
        }
        catch (error) {
            common_1.Logger.log('Failed to update userOp. sending back original op');
            common_1.Logger.error('Failed to update callData with error', error);
            return userOp;
        }
        return userOp;
    }
    async getAllTokenBalances(balancesDto) {
        return this.nodeClient.getAllTokenBalances(balancesDto);
    }
    async getTotalBalanceInUsd(balancesDto) {
        return this.nodeClient.getTotalBalanceInUsd(balancesDto);
    }
    async getSmartAccountsByOwner(smartAccountByOwnerDto) {
        return this.nodeClient.getSmartAccountsByOwner(smartAccountByOwnerDto);
    }
    async getTransactionsByAddress(chainId, address) {
        return this.nodeClient.getTransactionByAddress(chainId, address);
    }
    async getTransactionByHash(txHash) {
        return this.nodeClient.getTransactionByHash(txHash);
    }
    async getAllSupportedChains() {
        return this.nodeClient.getAllSupportedChains();
    }
}
exports.BiconomySmartAccount = BiconomySmartAccount;
//# sourceMappingURL=BiconomySmartAccount.js.map