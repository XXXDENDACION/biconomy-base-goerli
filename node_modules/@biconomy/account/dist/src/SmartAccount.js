"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartAccount = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const Preverificaiton_1 = require("./utils/Preverificaiton");
const common_1 = require("@biconomy/common");
const common_2 = require("@biconomy/common");
class SmartAccount {
    constructor(_smartAccountConfig) {
        this.initCode = '0x';
        this.smartAccountConfig = _smartAccountConfig;
    }
    setEntryPointAddress(entryPointAddress) {
        this.smartAccountConfig.entryPointAddress = entryPointAddress;
    }
    validateUserOp(userOp, requiredFields) {
        for (const field of requiredFields) {
            if (!userOp[field]) {
                throw new Error(`${field} is missing`);
            }
        }
        return true;
    }
    isProxyDefined() {
        if (!this.proxy)
            throw new Error('Proxy is undefined');
        return true;
    }
    isSignerDefined() {
        if (!this.signer)
            throw new Error('Signer is undefined');
        return true;
    }
    isProviderDefined() {
        if (!this.provider)
            throw new Error('Provider is undefined');
        return true;
    }
    async calculateUserOpGasValues(userOp) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!this.provider)
            throw new Error('Provider is not present for making rpc calls');
        const feeData = await this.provider.getFeeData();
        userOp.maxFeePerGas =
            (_c = (_b = (_a = userOp.maxFeePerGas) !== null && _a !== void 0 ? _a : feeData.maxFeePerGas) !== null && _b !== void 0 ? _b : feeData.gasPrice) !== null && _c !== void 0 ? _c : (await this.provider.getGasPrice());
        userOp.maxPriorityFeePerGas =
            (_f = (_e = (_d = userOp.maxPriorityFeePerGas) !== null && _d !== void 0 ? _d : feeData.maxPriorityFeePerGas) !== null && _e !== void 0 ? _e : feeData.gasPrice) !== null && _f !== void 0 ? _f : (await this.provider.getGasPrice());
        if (userOp.initCode)
            userOp.verificationGasLimit =
                (_g = userOp.verificationGasLimit) !== null && _g !== void 0 ? _g : (await this.getVerificationGasLimit(userOp.initCode));
        userOp.callGasLimit =
            (_h = userOp.callGasLimit) !== null && _h !== void 0 ? _h : (await this.provider.estimateGas({
                from: this.smartAccountConfig.entryPointAddress,
                to: userOp.sender,
                data: userOp.callData
            }));
        userOp.preVerificationGas = (_j = userOp.preVerificationGas) !== null && _j !== void 0 ? _j : this.getPreVerificationGas(userOp);
        return userOp;
    }
    async estimateUserOpGas(userOp, overrides, skipBundlerGasEstimation) {
        var _a, _b, _c, _d;
        const requiredFields = ['sender', 'nonce', 'initCode', 'callData'];
        this.validateUserOp(userOp, requiredFields);
        let finalUserOp = userOp;
        const skipBundlerCall = skipBundlerGasEstimation !== null && skipBundlerGasEstimation !== void 0 ? skipBundlerGasEstimation : false;
        // Override gas values in userOp if provided in overrides params
        if (overrides) {
            userOp = { ...userOp, ...overrides };
        }
        common_2.Logger.log('userOp in estimation', userOp);
        if (!this.bundler || skipBundlerCall) {
            if (!this.provider)
                throw new Error('Provider is not present for making rpc calls');
            // if no bundler url is provided run offchain logic to assign following values of UserOp
            // maxFeePerGas, maxPriorityFeePerGas, verificationGasLimit, callGasLimit, preVerificationGas
            finalUserOp = await this.calculateUserOpGasValues(finalUserOp);
        }
        else {
            // Making call to bundler to get gas estimations for userOp
            const { callGasLimit, verificationGasLimit, preVerificationGas, maxFeePerGas, maxPriorityFeePerGas } = await this.bundler.estimateUserOpGas(userOp);
            if (!userOp.maxFeePerGas &&
                !userOp.maxPriorityFeePerGas &&
                (!maxFeePerGas || !maxPriorityFeePerGas)) {
                const feeData = await this.provider.getFeeData();
                finalUserOp.maxFeePerGas =
                    (_b = (_a = feeData.maxFeePerGas) !== null && _a !== void 0 ? _a : feeData.gasPrice) !== null && _b !== void 0 ? _b : (await this.provider.getGasPrice());
                finalUserOp.maxPriorityFeePerGas =
                    (_d = (_c = feeData.maxPriorityFeePerGas) !== null && _c !== void 0 ? _c : feeData.gasPrice) !== null && _d !== void 0 ? _d : (await this.provider.getGasPrice());
            }
            else {
                finalUserOp.maxFeePerGas = maxFeePerGas !== null && maxFeePerGas !== void 0 ? maxFeePerGas : userOp.maxFeePerGas;
                finalUserOp.maxPriorityFeePerGas = maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : userOp.maxPriorityFeePerGas;
            }
            finalUserOp.verificationGasLimit = verificationGasLimit !== null && verificationGasLimit !== void 0 ? verificationGasLimit : userOp.verificationGasLimit;
            finalUserOp.callGasLimit = callGasLimit !== null && callGasLimit !== void 0 ? callGasLimit : userOp.callGasLimit;
            finalUserOp.preVerificationGas = preVerificationGas !== null && preVerificationGas !== void 0 ? preVerificationGas : userOp.preVerificationGas;
        }
        return finalUserOp;
    }
    async isAccountDeployed(address) {
        this.isProviderDefined();
        let contractCode;
        try {
            contractCode = await this.provider.getCode(address);
            return contractCode !== '0x';
        }
        catch (error) {
            throw error;
        }
    }
    // Would only be used if paymaster is attached
    async getPaymasterAndData(userOp) {
        if (this.paymaster) {
            const paymasterAndDataResponse = await this.paymaster.getPaymasterAndData(userOp);
            return paymasterAndDataResponse.paymasterAndData;
        }
        return '0x';
    }
    nonce() {
        this.isProxyDefined();
        return this.proxy.nonce();
    }
    async signUserOpHash(userOpHash, signer) {
        if (signer) {
            return signer.signMessage((0, utils_1.arrayify)(userOpHash));
        }
        if (this.signer) {
            return this.signer.signMessage((0, utils_1.arrayify)(userOpHash));
        }
        throw new Error('No signer provided to sign userOp');
    }
    getPreVerificationGas(userOp) {
        return (0, Preverificaiton_1.calcPreVerificationGas)(userOp);
    }
    async getVerificationGasLimit(initCode) {
        // Verification gas should be max(initGas(wallet deployment) + validateUserOp + validatePaymasterUserOp , postOp)
        const initGas = await this.estimateCreationGas(initCode);
        const validateUserOpGas = ethers_1.BigNumber.from(Preverificaiton_1.DefaultGasLimits.validatePaymasterUserOpGas + Preverificaiton_1.DefaultGasLimits.validateUserOpGas);
        const postOpGas = ethers_1.BigNumber.from(Preverificaiton_1.DefaultGasLimits.postOpGas);
        let verificationGasLimit = ethers_1.BigNumber.from(validateUserOpGas).add(initGas);
        if (ethers_1.BigNumber.from(postOpGas).gt(verificationGasLimit)) {
            verificationGasLimit = postOpGas;
        }
        return verificationGasLimit;
    }
    async getUserOpHash(userOp) {
        const userOpHash = (0, utils_1.keccak256)((0, common_1.packUserOp)(userOp, true));
        const enc = utils_1.defaultAbiCoder.encode(['bytes32', 'address', 'uint256'], [userOpHash, this.entryPoint.address, this.chainId]);
        return (0, utils_1.keccak256)(enc);
    }
    async estimateCreationGas(initCode) {
        if (initCode == null || initCode === '0x')
            return ethers_1.BigNumber.from('0');
        const deployerAddress = initCode.substring(0, 42);
        const deployerCallData = '0x' + initCode.substring(42);
        return await this.provider.estimateGas({ to: deployerAddress, data: deployerCallData });
    }
    async signUserOp(userOp) {
        const requiredFields = [
            'sender',
            'nonce',
            'initCode',
            'callData',
            'callGasLimit',
            'verificationGasLimit',
            'preVerificationGas',
            'maxFeePerGas',
            'maxPriorityFeePerGas',
            'paymasterAndData'
        ];
        this.validateUserOp(userOp, requiredFields);
        const userOpHash = await this.getUserOpHash(userOp);
        let signature = await this.signUserOpHash(userOpHash, this.signer);
        const potentiallyIncorrectV = parseInt(signature.slice(-2), 16);
        if (![27, 28].includes(potentiallyIncorrectV)) {
            const correctV = potentiallyIncorrectV + 27;
            signature = signature.slice(0, -2) + correctV.toString(16);
        }
        if (signature.slice(0, 2) !== '0x') {
            signature = '0x' + signature;
        }
        userOp.signature = signature;
        return userOp;
    }
    /**
     *
     * @param userOp
     * @description This function call will take 'unsignedUserOp' as an input, sign it with the owner key, and send it to the bundler.
     * @returns Promise<UserOpResponse>
     */
    async sendUserOp(userOp) {
        common_2.Logger.log('userOp received in base account ', userOp);
        const userOperation = await this.signUserOp(userOp);
        const bundlerResponse = await this.sendSignedUserOp(userOperation);
        return bundlerResponse;
    }
    /**
     *
     * @param userOp
     * @description This function call will take 'signedUserOp' as input and send it to the bundler
     * @returns
     */
    async sendSignedUserOp(userOp) {
        const requiredFields = [
            'sender',
            'nonce',
            'initCode',
            'callData',
            'callGasLimit',
            'verificationGasLimit',
            'preVerificationGas',
            'maxFeePerGas',
            'maxPriorityFeePerGas',
            'paymasterAndData',
            'signature'
        ];
        this.validateUserOp(userOp, requiredFields);
        common_2.Logger.log('userOp validated');
        if (!this.bundler)
            throw new Error('Bundler is not provided');
        const bundlerResponse = await this.bundler.sendUserOp(userOp);
        return bundlerResponse;
    }
}
exports.SmartAccount = SmartAccount;
//# sourceMappingURL=SmartAccount.js.map