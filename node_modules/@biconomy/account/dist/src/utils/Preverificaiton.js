"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcPreVerificationGas = exports.DefaultGasLimits = exports.DefaultGasOverheads = void 0;
const common_1 = require("@biconomy/common"); // '@account-abstraction/utils'
const utils_1 = require("ethers/lib/utils");
const ethers_1 = require("ethers");
exports.DefaultGasOverheads = {
    fixed: 21000,
    perUserOp: 18300,
    perUserOpWord: 4,
    zeroByte: 4,
    nonZeroByte: 16,
    bundleSize: 1,
    sigSize: 65
};
exports.DefaultGasLimits = {
    validateUserOpGas: 100000,
    validatePaymasterUserOpGas: 100000,
    postOpGas: 10877
};
/**
 * calculate the preVerificationGas of the given UserOperation
 * preVerificationGas (by definition) is the cost overhead that can't be calculated on-chain.
 * it is based on parameters that are defined by the Ethereum protocol for external transactions.
 * @param userOp filled userOp to calculate. The only possible missing fields can be the signature and preVerificationGas itself
 * @param overheads gas overheads to use, to override the default values
 */
function calcPreVerificationGas(userOp, overheads) {
    const ov = { ...exports.DefaultGasOverheads, ...(overheads !== null && overheads !== void 0 ? overheads : {}) };
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    const p = {
        // dummy values, in case the UserOp is incomplete.
        paymasterAndData: '0x',
        preVerificationGas: ethers_1.BigNumber.from(21000),
        signature: (0, utils_1.hexlify)(Buffer.alloc(ov.sigSize, 1)),
        ...userOp
    };
    const packed = (0, utils_1.arrayify)((0, common_1.packUserOp)(p, false));
    const lengthInWord = (packed.length + 31) / 32;
    /**
     * general explanation
     * 21000 base gas
     * ~ 18300 gas per userOp : corresponds to _validateAccountAndPaymasterValidationData() method,
     * Some lines in _handlePostOp() after actualGasCost calculation and compensate() method called in handleOps() method
     * plus any gas overhead that can't be tracked on-chain
     * (if bundler needs to charge the premium one way is to increase this value for ops to sign)
     */
    const callDataCost = packed
        .map((x) => (x === 0 ? ov.zeroByte : ov.nonZeroByte))
        .reduce((sum, x) => sum + x);
    const ret = Math.round(callDataCost + ov.fixed / ov.bundleSize + ov.perUserOp + ov.perUserOpWord * lengthInWord);
    return ethers_1.BigNumber.from(ret);
}
exports.calcPreVerificationGas = calcPreVerificationGas;
//# sourceMappingURL=Preverificaiton.js.map